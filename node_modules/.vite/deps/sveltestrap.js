import {
  writable
} from "./chunk-QB7JMMTY.js";
import {
  fade
} from "./chunk-Q5AVRMXF.js";
import "./chunk-M6MB33T7.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_location,
  add_render_callback,
  afterUpdate,
  append_dev,
  append_styles,
  assign,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_in_transition,
  create_out_transition,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  prevent_default,
  run_all,
  safe_not_equal,
  select_option,
  select_options,
  select_value,
  setContext,
  set_attributes,
  set_data_dev,
  set_input_value,
  set_style,
  space,
  src_url_equal,
  svg_element,
  text,
  to_number,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_each_argument,
  validate_slots,
  validate_store
} from "./chunk-L7AXC632.js";

// node_modules/sveltestrap/src/utils.js
function getOriginalBodyPadding() {
  const style = window ? window.getComputedStyle(document.body, null) : {};
  return parseInt(style && style.getPropertyValue("padding-right") || 0, 10);
}
function getScrollbarWidth() {
  let scrollDiv = document.createElement("div");
  scrollDiv.style.position = "absolute";
  scrollDiv.style.top = "-9999px";
  scrollDiv.style.width = "50px";
  scrollDiv.style.height = "50px";
  scrollDiv.style.overflow = "scroll";
  document.body.appendChild(scrollDiv);
  const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  return scrollbarWidth;
}
function setScrollbarWidth(padding) {
  document.body.style.paddingRight = padding > 0 ? `${padding}px` : null;
}
function isBodyOverflowing() {
  return window ? document.body.clientWidth < window.innerWidth : false;
}
function isObject(value) {
  const type = typeof value;
  return value != null && (type == "object" || type == "function");
}
function conditionallyUpdateScrollbar() {
  const scrollbarWidth = getScrollbarWidth();
  const fixedContent = document.querySelectorAll(
    ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top"
  )[0];
  const bodyPadding = fixedContent ? parseInt(fixedContent.style.paddingRight || 0, 10) : 0;
  if (isBodyOverflowing()) {
    setScrollbarWidth(bodyPadding + scrollbarWidth);
  }
}
function getColumnSizeClass(isXs, colWidth, colSize) {
  if (colSize === true || colSize === "") {
    return isXs ? "col" : `col-${colWidth}`;
  } else if (colSize === "auto") {
    return isXs ? "col-auto" : `col-${colWidth}-auto`;
  }
  return isXs ? `col-${colSize}` : `col-${colWidth}-${colSize}`;
}
function browserEvent(target, ...args) {
  target.addEventListener(...args);
  return () => target.removeEventListener(...args);
}
function getNewCarouselActiveIndex(direction, items, activeIndex) {
  if (direction === "prev") {
    return activeIndex === 0 ? items.length - 1 : activeIndex - 1;
  } else if (direction === "next") {
    return activeIndex === items.length - 1 ? 0 : activeIndex + 1;
  }
}
function toClassName(value) {
  let result = "";
  if (typeof value === "string" || typeof value === "number") {
    result += value;
  } else if (typeof value === "object") {
    if (Array.isArray(value)) {
      result = value.map(toClassName).filter(Boolean).join(" ");
    } else {
      for (let key in value) {
        if (value[key]) {
          result && (result += " ");
          result += key;
        }
      }
    }
  }
  return result;
}
function classnames(...args) {
  return args.map(toClassName).filter(Boolean).join(" ");
}
function getTransitionDuration(element2) {
  if (!element2)
    return 0;
  let { transitionDuration, transitionDelay } = window.getComputedStyle(element2);
  const floatTransitionDuration = Number.parseFloat(transitionDuration);
  const floatTransitionDelay = Number.parseFloat(transitionDelay);
  if (!floatTransitionDuration && !floatTransitionDelay) {
    return 0;
  }
  transitionDuration = transitionDuration.split(",")[0];
  transitionDelay = transitionDelay.split(",")[0];
  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * 1e3;
}
function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c == "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}

// node_modules/sveltestrap/src/Accordion.svelte
var file = "node_modules/sveltestrap/src/Accordion.svelte";
function create_fragment(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  let div_levels = [{ class: ctx[0] }, ctx[2]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file, 29, 0, 643);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & 1) && { class: ctx2[0] },
        dirty & 4 && ctx2[2]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["flush", "stayOpen", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $open;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Accordion", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { flush = false } = $$props;
  let { stayOpen = false } = $$props;
  let { class: className = "" } = $$props;
  const open = writable();
  validate_store(open, "open");
  component_subscribe($$self, open, (value) => $$invalidate(8, $open = value));
  setContext("accordion", {
    open,
    stayOpen,
    toggle: (id) => {
      if ($open === id)
        open.set();
      else
        open.set(id);
      dispatch("toggle", { [id]: $open === id });
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("flush" in $$new_props)
      $$invalidate(3, flush = $$new_props.flush);
    if ("stayOpen" in $$new_props)
      $$invalidate(4, stayOpen = $$new_props.stayOpen);
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    createEventDispatcher,
    setContext,
    writable,
    dispatch,
    flush,
    stayOpen,
    className,
    open,
    classes,
    $open
  });
  $$self.$inject_state = ($$new_props) => {
    if ("flush" in $$props)
      $$invalidate(3, flush = $$new_props.flush);
    if ("stayOpen" in $$props)
      $$invalidate(4, stayOpen = $$new_props.stayOpen);
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 40) {
      $:
        $$invalidate(0, classes = classnames(className, "accordion", { "accordion-flush": flush }));
    }
  };
  return [classes, open, $$restProps, flush, stayOpen, className, $$scope, slots];
}
var Accordion = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { flush: 3, stayOpen: 4, class: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Accordion",
      options,
      id: create_fragment.name
    });
  }
  get flush() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flush(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stayOpen() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stayOpen(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Accordion_default = Accordion;

// node_modules/sveltestrap/src/AccordionHeader.svelte
var file2 = "node_modules/sveltestrap/src/AccordionHeader.svelte";
function create_fragment2(ctx) {
  let h2;
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let h2_levels = [{ class: "accordion-header" }, ctx[1]];
  let h2_data = {};
  for (let i = 0; i < h2_levels.length; i += 1) {
    h2_data = assign(h2_data, h2_levels[i]);
  }
  const block = {
    c: function create() {
      h2 = element("h2");
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr_dev(button, "type", "button");
      attr_dev(button, "class", ctx[0]);
      add_location(button, file2, 9, 2, 219);
      set_attributes(h2, h2_data);
      add_location(h2, file2, 8, 0, 170);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h2, anchor);
      append_dev(h2, button);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[5], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1) {
        attr_dev(button, "class", ctx2[0]);
      }
      set_attributes(h2, h2_data = get_spread_update(h2_levels, [
        { class: "accordion-header" },
        dirty & 2 && ctx2[1]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h2);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionHeader", slots, ["default"]);
  let { class: className = "" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(0, classes = classnames(className, "accordion-button"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots, click_handler];
}
var AccordionHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionHeader",
      options,
      id: create_fragment2.name
    });
  }
  get class() {
    throw new Error("<AccordionHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AccordionHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionHeader_default = AccordionHeader;

// node_modules/sveltestrap/src/transitions.js
function backdropIn(node) {
  node.style.display = "block";
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t === 0) {
        node.classList.add("show");
      }
    }
  };
}
function backdropOut(node) {
  node.classList.remove("show");
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t === 0) {
        node.style.display = "none";
      }
    }
  };
}
function collapseOut(node, params) {
  const dimension = params.horizontal ? "width" : "height";
  node.style[dimension] = `${node.getBoundingClientRect()[dimension]}px`;
  node.classList.add("collapsing");
  node.classList.remove("collapse", "show");
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t > 0) {
        node.style[dimension] = "";
      } else if (t === 0) {
        node.classList.remove("collapsing");
        node.classList.add("collapse");
      }
    }
  };
}
function collapseIn(node, params) {
  const horizontal = params.horizontal;
  const dimension = horizontal ? "width" : "height";
  node.classList.add("collapsing");
  node.classList.remove("collapse", "show");
  node.style[dimension] = 0;
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t < 1) {
        if (horizontal) {
          node.style.width = `${node.scrollWidth}px`;
        } else {
          node.style.height = `${node.scrollHeight}px`;
        }
      } else {
        node.classList.remove("collapsing");
        node.classList.add("collapse", "show");
        node.style[dimension] = "";
      }
    }
  };
}
function modalIn(node) {
  node.style.display = "block";
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t > 0) {
        node.classList.add("show");
      }
    }
  };
}
function modalOut(node) {
  node.classList.remove("show");
  const duration = getTransitionDuration(node);
  return {
    duration,
    tick: (t) => {
      if (t === 1) {
        node.style.display = "none";
      }
    }
  };
}

// node_modules/sveltestrap/src/toggle.js
var defaultToggleEvents = ["touchstart", "click"];
var toggle_default = (toggler, togglerFn) => {
  let unbindEvents;
  if (typeof toggler === "string" && typeof window !== "undefined" && document && document.createElement) {
    let selection = document.querySelectorAll(toggler);
    if (!selection.length) {
      selection = document.querySelectorAll(`#${toggler}`);
    }
    if (!selection.length) {
      throw new Error(
        `The target '${toggler}' could not be identified in the dom, tip: check spelling`
      );
    }
    defaultToggleEvents.forEach((event) => {
      selection.forEach((element2) => {
        element2.addEventListener(event, togglerFn);
      });
    });
    unbindEvents = () => {
      defaultToggleEvents.forEach((event) => {
        selection.forEach((element2) => {
          element2.removeEventListener(event, togglerFn);
        });
      });
    };
  }
  return () => {
    if (typeof unbindEvents === "function") {
      unbindEvents();
      unbindEvents = void 0;
    }
  };
};

// node_modules/sveltestrap/src/Collapse.svelte
var file3 = "node_modules/sveltestrap/src/Collapse.svelte";
function create_if_block(ctx) {
  let div;
  let div_style_value;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[16].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[15], null);
  let div_levels = [
    {
      style: div_style_value = ctx[2] ? void 0 : "overflow: hidden;"
    },
    ctx[9],
    { class: ctx[8] }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file3, 61, 2, 1551);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "introstart", ctx[17], false, false, false),
          listen_dev(div, "introend", ctx[18], false, false, false),
          listen_dev(div, "outrostart", ctx[19], false, false, false),
          listen_dev(div, "outroend", ctx[20], false, false, false),
          listen_dev(
            div,
            "introstart",
            function() {
              if (is_function(ctx[3]))
                ctx[3].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "introend",
            function() {
              if (is_function(ctx[4]))
                ctx[4].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outrostart",
            function() {
              if (is_function(ctx[5]))
                ctx[5].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outroend",
            function() {
              if (is_function(ctx[6]))
                ctx[6].apply(this, arguments);
            },
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[15],
            !current ? get_all_dirty_from_scope(ctx[15]) : get_slot_changes(default_slot_template, ctx[15], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & 4 && div_style_value !== (div_style_value = ctx[2] ? void 0 : "overflow: hidden;")) && { style: div_style_value },
        dirty & 512 && ctx[9],
        (!current || dirty & 256) && { class: ctx[8] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      add_render_callback(() => {
        if (div_outro)
          div_outro.end(1);
        div_intro = create_in_transition(div, collapseIn, { horizontal: ctx[1] });
        div_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro)
        div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(div, collapseOut, { horizontal: ctx[1] });
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_outro)
        div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(61:0) {#if isOpen}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  add_render_callback(ctx[21]);
  let if_block = ctx[0] && create_if_block(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(window, "resize", ctx[21]);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "isOpen",
    "class",
    "horizontal",
    "navbar",
    "onEntering",
    "onEntered",
    "onExiting",
    "onExited",
    "expand",
    "toggler"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Collapse", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { isOpen = false } = $$props;
  let { class: className = "" } = $$props;
  let { horizontal = false } = $$props;
  let { navbar = false } = $$props;
  let { onEntering = () => dispatch("opening") } = $$props;
  let { onEntered = () => dispatch("open") } = $$props;
  let { onExiting = () => dispatch("closing") } = $$props;
  let { onExited = () => dispatch("close") } = $$props;
  let { expand = false } = $$props;
  let { toggler = null } = $$props;
  onMount(() => toggle_default(toggler, (e) => {
    $$invalidate(0, isOpen = !isOpen);
    e.preventDefault();
  }));
  let windowWidth = 0;
  let _wasMaximized = false;
  const minWidth = {};
  minWidth["xs"] = 0;
  minWidth["sm"] = 576;
  minWidth["md"] = 768;
  minWidth["lg"] = 992;
  minWidth["xl"] = 1200;
  function notify() {
    dispatch("update", isOpen);
  }
  function introstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function introend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outrostart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outroend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function onwindowresize() {
    $$invalidate(7, windowWidth = window.innerWidth);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("class" in $$new_props)
      $$invalidate(10, className = $$new_props.class);
    if ("horizontal" in $$new_props)
      $$invalidate(1, horizontal = $$new_props.horizontal);
    if ("navbar" in $$new_props)
      $$invalidate(2, navbar = $$new_props.navbar);
    if ("onEntering" in $$new_props)
      $$invalidate(3, onEntering = $$new_props.onEntering);
    if ("onEntered" in $$new_props)
      $$invalidate(4, onEntered = $$new_props.onEntered);
    if ("onExiting" in $$new_props)
      $$invalidate(5, onExiting = $$new_props.onExiting);
    if ("onExited" in $$new_props)
      $$invalidate(6, onExited = $$new_props.onExited);
    if ("expand" in $$new_props)
      $$invalidate(11, expand = $$new_props.expand);
    if ("toggler" in $$new_props)
      $$invalidate(12, toggler = $$new_props.toggler);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    collapseIn,
    collapseOut,
    classnames,
    toggle: toggle_default,
    dispatch,
    isOpen,
    className,
    horizontal,
    navbar,
    onEntering,
    onEntered,
    onExiting,
    onExited,
    expand,
    toggler,
    windowWidth,
    _wasMaximized,
    minWidth,
    notify,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("className" in $$props)
      $$invalidate(10, className = $$new_props.className);
    if ("horizontal" in $$props)
      $$invalidate(1, horizontal = $$new_props.horizontal);
    if ("navbar" in $$props)
      $$invalidate(2, navbar = $$new_props.navbar);
    if ("onEntering" in $$props)
      $$invalidate(3, onEntering = $$new_props.onEntering);
    if ("onEntered" in $$props)
      $$invalidate(4, onEntered = $$new_props.onEntered);
    if ("onExiting" in $$props)
      $$invalidate(5, onExiting = $$new_props.onExiting);
    if ("onExited" in $$props)
      $$invalidate(6, onExited = $$new_props.onExited);
    if ("expand" in $$props)
      $$invalidate(11, expand = $$new_props.expand);
    if ("toggler" in $$props)
      $$invalidate(12, toggler = $$new_props.toggler);
    if ("windowWidth" in $$props)
      $$invalidate(7, windowWidth = $$new_props.windowWidth);
    if ("_wasMaximized" in $$props)
      $$invalidate(13, _wasMaximized = $$new_props._wasMaximized);
    if ("classes" in $$props)
      $$invalidate(8, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1030) {
      $:
        $$invalidate(8, classes = classnames(className, {
          "collapse-horizontal": horizontal,
          "navbar-collapse": navbar
        }));
    }
    if ($$self.$$.dirty & 26757) {
      $:
        if (navbar && expand) {
          if (windowWidth >= minWidth[expand] && !isOpen) {
            $$invalidate(0, isOpen = true);
            $$invalidate(13, _wasMaximized = true);
            notify();
          } else if (windowWidth < minWidth[expand] && _wasMaximized) {
            $$invalidate(0, isOpen = false);
            $$invalidate(13, _wasMaximized = false);
            notify();
          }
        }
    }
  };
  return [
    isOpen,
    horizontal,
    navbar,
    onEntering,
    onEntered,
    onExiting,
    onExited,
    windowWidth,
    classes,
    $$restProps,
    className,
    expand,
    toggler,
    _wasMaximized,
    minWidth,
    $$scope,
    slots,
    introstart_handler,
    introend_handler,
    outrostart_handler,
    outroend_handler,
    onwindowresize
  ];
}
var Collapse = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      isOpen: 0,
      class: 10,
      horizontal: 1,
      navbar: 2,
      onEntering: 3,
      onEntered: 4,
      onExiting: 5,
      onExited: 6,
      expand: 11,
      toggler: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Collapse",
      options,
      id: create_fragment3.name
    });
  }
  get isOpen() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get horizontal() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set horizontal(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navbar() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navbar(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onEntering() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onEntering(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onEntered() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onEntered(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onExiting() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onExiting(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onExited() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onExited(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expand() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expand(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggler() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggler(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Collapse_default = Collapse;

// node_modules/sveltestrap/src/AccordionItem.svelte
var file4 = "node_modules/sveltestrap/src/AccordionItem.svelte";
var get_header_slot_changes = (dirty) => ({});
var get_header_slot_context = (ctx) => ({});
function create_default_slot_1(ctx) {
  let t0;
  let t1;
  let current;
  const header_slot_template = ctx[9].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[16], get_header_slot_context);
  const block = {
    c: function create() {
      if (header_slot)
        header_slot.c();
      t0 = space();
      t1 = text(ctx[0]);
    },
    m: function mount(target, anchor) {
      if (header_slot) {
        header_slot.m(target, anchor);
      }
      insert_dev(target, t0, anchor);
      insert_dev(target, t1, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(header_slot_template, ctx2[16], dirty, get_header_slot_changes),
            get_header_slot_context
          );
        }
      }
      if (!current || dirty & 1)
        set_data_dev(t1, ctx2[0]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (header_slot)
        header_slot.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(31:2) <AccordionHeader     on:click={() => onToggle()}     class={!accordionOpen && 'collapsed'}   >",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[16], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "accordion-body");
      add_location(div, file4, 45, 4, 1133);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(default_slot_template, ctx2[16], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: '(38:2) <Collapse     isOpen={accordionOpen}     class=\\"accordion-collapse\\"     on:introstart     on:introend     on:outrostart     on:outroend   >',
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let div;
  let accordionheader;
  let t;
  let collapse;
  let current;
  accordionheader = new AccordionHeader_default({
    props: {
      class: !ctx[2] && "collapsed",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  accordionheader.$on("click", ctx[10]);
  collapse = new Collapse_default({
    props: {
      isOpen: ctx[2],
      class: "accordion-collapse",
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  collapse.$on("introstart", ctx[11]);
  collapse.$on("introend", ctx[12]);
  collapse.$on("outrostart", ctx[13]);
  collapse.$on("outroend", ctx[14]);
  const block = {
    c: function create() {
      div = element("div");
      create_component(accordionheader.$$.fragment);
      t = space();
      create_component(collapse.$$.fragment);
      attr_dev(div, "class", ctx[3]);
      add_location(div, file4, 29, 0, 783);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(accordionheader, div, null);
      append_dev(div, t);
      mount_component(collapse, div, null);
      ctx[15](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const accordionheader_changes = {};
      if (dirty & 4)
        accordionheader_changes.class = !ctx2[2] && "collapsed";
      if (dirty & 65537) {
        accordionheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordionheader.$set(accordionheader_changes);
      const collapse_changes = {};
      if (dirty & 4)
        collapse_changes.isOpen = ctx2[2];
      if (dirty & 65536) {
        collapse_changes.$$scope = { dirty, ctx: ctx2 };
      }
      collapse.$set(collapse_changes);
      if (!current || dirty & 8) {
        attr_dev(div, "class", ctx2[3]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(accordionheader.$$.fragment, local);
      transition_in(collapse.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(accordionheader.$$.fragment, local);
      transition_out(collapse.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(accordionheader);
      destroy_component(collapse);
      ctx[15](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let classes;
  let accordionOpen;
  let $open;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionItem", slots, ["header", "default"]);
  let { class: className = "" } = $$props;
  let { header = "" } = $$props;
  let { active = false } = $$props;
  let accordionId;
  const dispatch = createEventDispatcher();
  const { stayOpen, toggle, open } = getContext("accordion");
  validate_store(open, "open");
  component_subscribe($$self, open, (value) => $$invalidate(8, $open = value));
  onMount(() => {
    if (active)
      toggle(accordionId);
  });
  const onToggle = () => {
    if (stayOpen)
      $$invalidate(6, active = !active);
    toggle(accordionId);
    dispatch("toggle", !accordionOpen);
  };
  const writable_props = ["class", "header", "active"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AccordionItem> was created with unknown prop '${key}'`);
  });
  const click_handler = () => onToggle();
  function introstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function introend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outrostart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outroend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      accordionId = $$value;
      $$invalidate(1, accordionId);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(7, className = $$props2.class);
    if ("header" in $$props2)
      $$invalidate(0, header = $$props2.header);
    if ("active" in $$props2)
      $$invalidate(6, active = $$props2.active);
    if ("$$scope" in $$props2)
      $$invalidate(16, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    getContext,
    onMount,
    classnames,
    Collapse: Collapse_default,
    AccordionHeader: AccordionHeader_default,
    className,
    header,
    active,
    accordionId,
    dispatch,
    stayOpen,
    toggle,
    open,
    onToggle,
    accordionOpen,
    classes,
    $open
  });
  $$self.$inject_state = ($$props2) => {
    if ("className" in $$props2)
      $$invalidate(7, className = $$props2.className);
    if ("header" in $$props2)
      $$invalidate(0, header = $$props2.header);
    if ("active" in $$props2)
      $$invalidate(6, active = $$props2.active);
    if ("accordionId" in $$props2)
      $$invalidate(1, accordionId = $$props2.accordionId);
    if ("accordionOpen" in $$props2)
      $$invalidate(2, accordionOpen = $$props2.accordionOpen);
    if ("classes" in $$props2)
      $$invalidate(3, classes = $$props2.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      $:
        $$invalidate(3, classes = classnames(className, "accordion-item"));
    }
    if ($$self.$$.dirty & 322) {
      $:
        $$invalidate(2, accordionOpen = stayOpen ? active : $open === accordionId);
    }
  };
  return [
    header,
    accordionId,
    accordionOpen,
    classes,
    open,
    onToggle,
    active,
    className,
    $open,
    slots,
    click_handler,
    introstart_handler,
    introend_handler,
    outrostart_handler,
    outroend_handler,
    div_binding,
    $$scope
  ];
}
var AccordionItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { class: 7, header: 0, active: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionItem",
      options,
      id: create_fragment4.name
    });
  }
  get class() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionItem_default = AccordionItem;

// node_modules/sveltestrap/src/Alert.svelte
var file5 = "node_modules/sveltestrap/src/Alert.svelte";
var get_heading_slot_changes = (dirty) => ({});
var get_heading_slot_context = (ctx) => ({});
function create_if_block2(ctx) {
  let div;
  let t0;
  let t1;
  let current_block_type_index;
  let if_block2;
  let div_transition;
  let current;
  let if_block0 = (ctx[3] || ctx[10].heading) && create_if_block_3(ctx);
  let if_block1 = ctx[5] && create_if_block_2(ctx);
  const if_block_creators = [create_if_block_1, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [ctx[9], { class: ctx[7] }, { role: "alert" }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if_block2.c();
      set_attributes(div, div_data);
      add_location(div, file5, 26, 2, 808);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t1);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (ctx[3] || ctx[10].heading) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & 1032) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx[5]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_2(ctx);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block2.c();
        } else {
          if_block2.p(ctx, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 512 && ctx[9],
        (!current || dirty & 128) && { class: ctx[7] },
        { role: "alert" }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, fade, ctx[4], true);
        div_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, fade, ctx[4], false);
      div_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if_blocks[current_block_type_index].d();
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(26:0) {#if isOpen}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let h4;
  let t;
  let current;
  const heading_slot_template = ctx[18].heading;
  const heading_slot = create_slot(heading_slot_template, ctx, ctx[17], get_heading_slot_context);
  const block = {
    c: function create() {
      h4 = element("h4");
      t = text(ctx[3]);
      if (heading_slot)
        heading_slot.c();
      attr_dev(h4, "class", "alert-heading");
      add_location(h4, file5, 33, 6, 961);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h4, anchor);
      append_dev(h4, t);
      if (heading_slot) {
        heading_slot.m(h4, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & 8)
        set_data_dev(t, ctx2[3]);
      if (heading_slot) {
        if (heading_slot.p && (!current || dirty & 131072)) {
          update_slot_base(
            heading_slot,
            heading_slot_template,
            ctx2,
            ctx2[17],
            !current ? get_all_dirty_from_scope(ctx2[17]) : get_slot_changes(heading_slot_template, ctx2[17], dirty, get_heading_slot_changes),
            get_heading_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(heading_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(heading_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h4);
      if (heading_slot)
        heading_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(33:4) {#if heading || $$slots.heading}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let button;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      attr_dev(button, "type", "button");
      attr_dev(button, "class", ctx[6]);
      attr_dev(button, "aria-label", ctx[2]);
      add_location(button, file5, 38, 6, 1077);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(ctx[8]))
              ctx[8].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 64) {
        attr_dev(button, "class", ctx[6]);
      }
      if (dirty & 4) {
        attr_dev(button, "aria-label", ctx[2]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(38:4) {#if showClose}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let current;
  const default_slot_template = ctx[18].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[17], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[17],
            !current ? get_all_dirty_from_scope(ctx2[17]) : get_slot_changes(default_slot_template, ctx2[17], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(48:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(46:4) {#if children}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block2(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let showClose;
  let handleToggle;
  let classes;
  let closeClassNames;
  const omit_props_names = [
    "class",
    "children",
    "color",
    "closeClassName",
    "closeAriaLabel",
    "dismissible",
    "heading",
    "isOpen",
    "toggle",
    "fade",
    "transition"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Alert", slots, ["heading", "default"]);
  const $$slots = compute_slots(slots);
  let { class: className = "" } = $$props;
  let { children = void 0 } = $$props;
  let { color = "success" } = $$props;
  let { closeClassName = "" } = $$props;
  let { closeAriaLabel = "Close" } = $$props;
  let { dismissible = false } = $$props;
  let { heading = void 0 } = $$props;
  let { isOpen = true } = $$props;
  let { toggle = void 0 } = $$props;
  let { fade: fade2 = true } = $$props;
  let { transition = { duration: fade2 ? 400 : 0 } } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(11, className = $$new_props.class);
    if ("children" in $$new_props)
      $$invalidate(1, children = $$new_props.children);
    if ("color" in $$new_props)
      $$invalidate(12, color = $$new_props.color);
    if ("closeClassName" in $$new_props)
      $$invalidate(13, closeClassName = $$new_props.closeClassName);
    if ("closeAriaLabel" in $$new_props)
      $$invalidate(2, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("dismissible" in $$new_props)
      $$invalidate(14, dismissible = $$new_props.dismissible);
    if ("heading" in $$new_props)
      $$invalidate(3, heading = $$new_props.heading);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("toggle" in $$new_props)
      $$invalidate(15, toggle = $$new_props.toggle);
    if ("fade" in $$new_props)
      $$invalidate(16, fade2 = $$new_props.fade);
    if ("transition" in $$new_props)
      $$invalidate(4, transition = $$new_props.transition);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    fadeTransition: fade,
    classnames,
    className,
    children,
    color,
    closeClassName,
    closeAriaLabel,
    dismissible,
    heading,
    isOpen,
    toggle,
    fade: fade2,
    transition,
    closeClassNames,
    showClose,
    classes,
    handleToggle
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(11, className = $$new_props.className);
    if ("children" in $$props)
      $$invalidate(1, children = $$new_props.children);
    if ("color" in $$props)
      $$invalidate(12, color = $$new_props.color);
    if ("closeClassName" in $$props)
      $$invalidate(13, closeClassName = $$new_props.closeClassName);
    if ("closeAriaLabel" in $$props)
      $$invalidate(2, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("dismissible" in $$props)
      $$invalidate(14, dismissible = $$new_props.dismissible);
    if ("heading" in $$props)
      $$invalidate(3, heading = $$new_props.heading);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("toggle" in $$props)
      $$invalidate(15, toggle = $$new_props.toggle);
    if ("fade" in $$props)
      $$invalidate(16, fade2 = $$new_props.fade);
    if ("transition" in $$props)
      $$invalidate(4, transition = $$new_props.transition);
    if ("closeClassNames" in $$props)
      $$invalidate(6, closeClassNames = $$new_props.closeClassNames);
    if ("showClose" in $$props)
      $$invalidate(5, showClose = $$new_props.showClose);
    if ("classes" in $$props)
      $$invalidate(7, classes = $$new_props.classes);
    if ("handleToggle" in $$props)
      $$invalidate(8, handleToggle = $$new_props.handleToggle);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 49152) {
      $:
        $$invalidate(5, showClose = dismissible || toggle);
    }
    if ($$self.$$.dirty & 32768) {
      $:
        $$invalidate(8, handleToggle = toggle || (() => $$invalidate(0, isOpen = false)));
    }
    if ($$self.$$.dirty & 6176) {
      $:
        $$invalidate(7, classes = classnames(className, "alert", `alert-${color}`, { "alert-dismissible": showClose }));
    }
    if ($$self.$$.dirty & 8192) {
      $:
        $$invalidate(6, closeClassNames = classnames("btn-close", closeClassName));
    }
  };
  return [
    isOpen,
    children,
    closeAriaLabel,
    heading,
    transition,
    showClose,
    closeClassNames,
    classes,
    handleToggle,
    $$restProps,
    $$slots,
    className,
    color,
    closeClassName,
    dismissible,
    toggle,
    fade2,
    $$scope,
    slots
  ];
}
var Alert = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      class: 11,
      children: 1,
      color: 12,
      closeClassName: 13,
      closeAriaLabel: 2,
      dismissible: 14,
      heading: 3,
      isOpen: 0,
      toggle: 15,
      fade: 16,
      transition: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Alert",
      options,
      id: create_fragment5.name
    });
  }
  get class() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeClassName() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeClassName(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeAriaLabel() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeAriaLabel(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dismissible() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dismissible(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get heading() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set heading(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fade() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fade(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transition() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Alert_default = Alert;

// node_modules/sveltestrap/src/Badge.svelte
var file6 = "node_modules/sveltestrap/src/Badge.svelte";
function create_else_block_1(ctx) {
  let span;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_22, create_else_block_2];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let span_levels = [ctx[3], { class: ctx[2] }];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if_block.c();
      set_attributes(span, span_data);
      add_location(span, file6, 27, 2, 500);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if_blocks[current_block_type_index].m(span, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(span, null);
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & 8 && ctx2[3],
        (!current || dirty & 4) && { class: ctx2[2] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(27:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let a;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_12, create_else_block2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let a_levels = [
    ctx[3],
    { href: ctx[1] },
    { class: ctx[2] }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if_block.c();
      set_attributes(a, a_data);
      add_location(a, file6, 19, 2, 366);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if_blocks[current_block_type_index].m(a, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(a, null);
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & 8 && ctx2[3],
        (!current || dirty & 2) && { href: ctx2[1] },
        (!current || dirty & 4) && { class: ctx2[2] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(19:0) {#if href}",
    ctx
  });
  return block;
}
function create_else_block_2(ctx) {
  let current;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_2.name,
    type: "else",
    source: "(31:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[0]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1)
        set_data_dev(t, ctx2[0]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(29:4) {#if children}",
    ctx
  });
  return block;
}
function create_else_block2(ctx) {
  let current;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(23:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[0]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1)
        set_data_dev(t, ctx2[0]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(21:4) {#if children}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block3, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "children", "color", "href", "pill"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Badge", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { children = void 0 } = $$props;
  let { color = "secondary" } = $$props;
  let { href = void 0 } = $$props;
  let { pill = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("children" in $$new_props)
      $$invalidate(0, children = $$new_props.children);
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("href" in $$new_props)
      $$invalidate(1, href = $$new_props.href);
    if ("pill" in $$new_props)
      $$invalidate(6, pill = $$new_props.pill);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    children,
    color,
    href,
    pill,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("children" in $$props)
      $$invalidate(0, children = $$new_props.children);
    if ("color" in $$props)
      $$invalidate(5, color = $$new_props.color);
    if ("href" in $$props)
      $$invalidate(1, href = $$new_props.href);
    if ("pill" in $$props)
      $$invalidate(6, pill = $$new_props.pill);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 112) {
      $:
        $$invalidate(2, classes = classnames(className, "badge", `bg-${color}`, pill ? "rounded-pill" : false));
    }
  };
  return [children, href, classes, $$restProps, className, color, pill, $$scope, slots];
}
var Badge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      class: 4,
      children: 0,
      color: 5,
      href: 1,
      pill: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Badge",
      options,
      id: create_fragment6.name
    });
  }
  get class() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pill() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pill(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Badge_default = Badge;

// node_modules/sveltestrap/src/Breadcrumb.svelte
var file7 = "node_modules/sveltestrap/src/Breadcrumb.svelte";
function create_else_block3(ctx) {
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(16:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(14:4) {#if children}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let nav;
  let ol;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block4, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let nav_levels = [ctx[3], { class: ctx[0] }];
  let nav_data = {};
  for (let i = 0; i < nav_levels.length; i += 1) {
    nav_data = assign(nav_data, nav_levels[i]);
  }
  const block = {
    c: function create() {
      nav = element("nav");
      ol = element("ol");
      if_block.c();
      attr_dev(ol, "class", ctx[2]);
      add_location(ol, file7, 12, 2, 284);
      set_attributes(nav, nav_data);
      add_location(nav, file7, 11, 0, 241);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, nav, anchor);
      append_dev(nav, ol);
      if_blocks[current_block_type_index].m(ol, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(ol, null);
      }
      if (!current || dirty & 4) {
        attr_dev(ol, "class", ctx2[2]);
      }
      set_attributes(nav, nav_data = get_spread_update(nav_levels, [
        dirty & 8 && ctx2[3],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(nav);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let listClasses;
  const omit_props_names = ["class", "children", "listClassName"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Breadcrumb", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { children = void 0 } = $$props;
  let { listClassName = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, className = $$new_props.class);
    if ("children" in $$new_props)
      $$invalidate(1, children = $$new_props.children);
    if ("listClassName" in $$new_props)
      $$invalidate(4, listClassName = $$new_props.listClassName);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    children,
    listClassName,
    listClasses
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(0, className = $$new_props.className);
    if ("children" in $$props)
      $$invalidate(1, children = $$new_props.children);
    if ("listClassName" in $$props)
      $$invalidate(4, listClassName = $$new_props.listClassName);
    if ("listClasses" in $$props)
      $$invalidate(2, listClasses = $$new_props.listClasses);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      $:
        $$invalidate(2, listClasses = classnames("breadcrumb", listClassName));
    }
  };
  return [className, children, listClasses, $$restProps, listClassName, $$scope, slots];
}
var Breadcrumb = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { class: 0, children: 1, listClassName: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Breadcrumb",
      options,
      id: create_fragment7.name
    });
  }
  get class() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listClassName() {
    throw new Error("<Breadcrumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listClassName(value) {
    throw new Error("<Breadcrumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Breadcrumb_default = Breadcrumb;

// node_modules/sveltestrap/src/BreadcrumbItem.svelte
var file8 = "node_modules/sveltestrap/src/BreadcrumbItem.svelte";
function create_else_block4(ctx) {
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(19:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(17:2) {#if children}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let li;
  let current_block_type_index;
  let if_block;
  let li_aria_current_value;
  let current;
  const if_block_creators = [create_if_block5, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let li_levels = [
    ctx[3],
    { class: ctx[2] },
    {
      "aria-current": li_aria_current_value = ctx[0] ? "page" : void 0
    }
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if_block.c();
      set_attributes(li, li_data);
      add_location(li, file8, 15, 0, 277);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      if_blocks[current_block_type_index].m(li, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(li, null);
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        dirty & 8 && ctx2[3],
        (!current || dirty & 4) && { class: ctx2[2] },
        (!current || dirty & 1 && li_aria_current_value !== (li_aria_current_value = ctx2[0] ? "page" : void 0)) && { "aria-current": li_aria_current_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "active", "children"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BreadcrumbItem", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { children = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(0, active = $$new_props.active);
    if ("children" in $$new_props)
      $$invalidate(1, children = $$new_props.children);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    active,
    children,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(0, active = $$new_props.active);
    if ("children" in $$props)
      $$invalidate(1, children = $$new_props.children);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 17) {
      $:
        $$invalidate(2, classes = classnames(className, active ? "active" : false, "breadcrumb-item"));
    }
  };
  return [active, children, classes, $$restProps, className, $$scope, slots];
}
var BreadcrumbItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { class: 4, active: 0, children: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BreadcrumbItem",
      options,
      id: create_fragment8.name
    });
  }
  get class() {
    throw new Error("<BreadcrumbItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BreadcrumbItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<BreadcrumbItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<BreadcrumbItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<BreadcrumbItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<BreadcrumbItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BreadcrumbItem_default = BreadcrumbItem;

// node_modules/sveltestrap/src/Button.svelte
var file9 = "node_modules/sveltestrap/src/Button.svelte";
function create_else_block_12(ctx) {
  let button;
  let button_aria_label_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[19].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[18], null);
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  let button_levels = [
    ctx[9],
    { class: ctx[7] },
    { disabled: ctx[2] },
    { value: ctx[5] },
    {
      "aria-label": button_aria_label_value = ctx[8] || ctx[6]
    },
    { style: ctx[4] }
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block_1 = {
    c: function create() {
      button = element("button");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      set_attributes(button, button_data);
      add_location(button, file9, 54, 2, 1124);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      ctx[23](button);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[21], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[18],
            !current ? get_all_dirty_from_scope(ctx2[18]) : get_slot_changes(default_slot_template, ctx2[18], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 262146)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & 512 && ctx2[9],
        (!current || dirty & 128) && { class: ctx2[7] },
        (!current || dirty & 4) && { disabled: ctx2[2] },
        (!current || dirty & 32) && { value: ctx2[5] },
        (!current || dirty & 320 && button_aria_label_value !== (button_aria_label_value = ctx2[8] || ctx2[6])) && { "aria-label": button_aria_label_value },
        (!current || dirty & 16) && { style: ctx2[4] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[23](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_else_block_12.name,
    type: "else",
    source: "(54:0) {:else}",
    ctx
  });
  return block_1;
}
function create_if_block6(ctx) {
  let a;
  let current_block_type_index;
  let if_block;
  let a_aria_label_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_13, create_else_block5];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let a_levels = [
    ctx[9],
    { class: ctx[7] },
    { disabled: ctx[2] },
    { href: ctx[3] },
    {
      "aria-label": a_aria_label_value = ctx[8] || ctx[6]
    },
    { style: ctx[4] }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block_1 = {
    c: function create() {
      a = element("a");
      if_block.c();
      set_attributes(a, a_data);
      add_location(a, file9, 37, 2, 866);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if_blocks[current_block_type_index].m(a, null);
      ctx[22](a);
      current = true;
      if (!mounted) {
        dispose = listen_dev(a, "click", ctx[20], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(a, null);
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & 512 && ctx2[9],
        (!current || dirty & 128) && { class: ctx2[7] },
        (!current || dirty & 4) && { disabled: ctx2[2] },
        (!current || dirty & 8) && { href: ctx2[3] },
        (!current || dirty & 320 && a_aria_label_value !== (a_aria_label_value = ctx2[8] || ctx2[6])) && { "aria-label": a_aria_label_value },
        (!current || dirty & 16) && { style: ctx2[4] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if_blocks[current_block_type_index].d();
      ctx[22](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block6.name,
    type: "if",
    source: "(37:0) {#if href}",
    ctx
  });
  return block_1;
}
function create_else_block_22(ctx) {
  let current;
  const default_slot_template = ctx[19].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[18], null);
  const block_1 = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[18],
            !current ? get_all_dirty_from_scope(ctx2[18]) : get_slot_changes(default_slot_template, ctx2[18], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_else_block_22.name,
    type: "else",
    source: "(68:6) {:else}",
    ctx
  });
  return block_1;
}
function create_if_block_23(ctx) {
  let t;
  const block_1 = {
    c: function create() {
      t = text(ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_23.name,
    type: "if",
    source: "(66:6) {#if children}",
    ctx
  });
  return block_1;
}
function fallback_block(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_23, create_else_block_22];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block_1 = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: fallback_block.name,
    type: "fallback",
    source: "(65:10)        ",
    ctx
  });
  return block_1;
}
function create_else_block5(ctx) {
  let current;
  const default_slot_template = ctx[19].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[18], null);
  const block_1 = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[18],
            !current ? get_all_dirty_from_scope(ctx2[18]) : get_slot_changes(default_slot_template, ctx2[18], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_else_block5.name,
    type: "else",
    source: "(50:4) {:else}",
    ctx
  });
  return block_1;
}
function create_if_block_13(ctx) {
  let t;
  const block_1 = {
    c: function create() {
      t = text(ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_13.name,
    type: "if",
    source: "(48:4) {#if children}",
    ctx
  });
  return block_1;
}
function create_fragment9(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block6, create_else_block_12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block_1 = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block_1;
}
function instance9($$self, $$props, $$invalidate) {
  let ariaLabel;
  let classes;
  let defaultAriaLabel;
  const omit_props_names = [
    "class",
    "active",
    "block",
    "children",
    "close",
    "color",
    "disabled",
    "href",
    "inner",
    "outline",
    "size",
    "style",
    "value",
    "white"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Button", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { block = false } = $$props;
  let { children = void 0 } = $$props;
  let { close = false } = $$props;
  let { color = "secondary" } = $$props;
  let { disabled = false } = $$props;
  let { href = "" } = $$props;
  let { inner = void 0 } = $$props;
  let { outline = false } = $$props;
  let { size = null } = $$props;
  let { style = "" } = $$props;
  let { value = "" } = $$props;
  let { white = false } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(24, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(10, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(11, active = $$new_props.active);
    if ("block" in $$new_props)
      $$invalidate(12, block = $$new_props.block);
    if ("children" in $$new_props)
      $$invalidate(1, children = $$new_props.children);
    if ("close" in $$new_props)
      $$invalidate(13, close = $$new_props.close);
    if ("color" in $$new_props)
      $$invalidate(14, color = $$new_props.color);
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("href" in $$new_props)
      $$invalidate(3, href = $$new_props.href);
    if ("inner" in $$new_props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("outline" in $$new_props)
      $$invalidate(15, outline = $$new_props.outline);
    if ("size" in $$new_props)
      $$invalidate(16, size = $$new_props.size);
    if ("style" in $$new_props)
      $$invalidate(4, style = $$new_props.style);
    if ("value" in $$new_props)
      $$invalidate(5, value = $$new_props.value);
    if ("white" in $$new_props)
      $$invalidate(17, white = $$new_props.white);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    active,
    block,
    children,
    close,
    color,
    disabled,
    href,
    inner,
    outline,
    size,
    style,
    value,
    white,
    defaultAriaLabel,
    classes,
    ariaLabel
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(24, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(10, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(11, active = $$new_props.active);
    if ("block" in $$props)
      $$invalidate(12, block = $$new_props.block);
    if ("children" in $$props)
      $$invalidate(1, children = $$new_props.children);
    if ("close" in $$props)
      $$invalidate(13, close = $$new_props.close);
    if ("color" in $$props)
      $$invalidate(14, color = $$new_props.color);
    if ("disabled" in $$props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("href" in $$props)
      $$invalidate(3, href = $$new_props.href);
    if ("inner" in $$props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("outline" in $$props)
      $$invalidate(15, outline = $$new_props.outline);
    if ("size" in $$props)
      $$invalidate(16, size = $$new_props.size);
    if ("style" in $$props)
      $$invalidate(4, style = $$new_props.style);
    if ("value" in $$props)
      $$invalidate(5, value = $$new_props.value);
    if ("white" in $$props)
      $$invalidate(17, white = $$new_props.white);
    if ("defaultAriaLabel" in $$props)
      $$invalidate(6, defaultAriaLabel = $$new_props.defaultAriaLabel);
    if ("classes" in $$props)
      $$invalidate(7, classes = $$new_props.classes);
    if ("ariaLabel" in $$props)
      $$invalidate(8, ariaLabel = $$new_props.ariaLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(8, ariaLabel = $$props["aria-label"]);
    if ($$self.$$.dirty & 261120) {
      $:
        $$invalidate(7, classes = classnames(className, close ? "btn-close" : "btn", close || `btn${outline ? "-outline" : ""}-${color}`, size ? `btn-${size}` : false, block ? "d-block w-100" : false, {
          active,
          "btn-close-white": close && white
        }));
    }
    if ($$self.$$.dirty & 8192) {
      $:
        $$invalidate(6, defaultAriaLabel = close ? "Close" : null);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    inner,
    children,
    disabled,
    href,
    style,
    value,
    defaultAriaLabel,
    classes,
    ariaLabel,
    $$restProps,
    className,
    active,
    block,
    close,
    color,
    outline,
    size,
    white,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    a_binding,
    button_binding
  ];
}
var Button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      class: 10,
      active: 11,
      block: 12,
      children: 1,
      close: 13,
      color: 14,
      disabled: 2,
      href: 3,
      inner: 0,
      outline: 15,
      size: 16,
      style: 4,
      value: 5,
      white: 17
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button",
      options,
      id: create_fragment9.name
    });
  }
  get class() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get block() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set block(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get close() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set close(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inner() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inner(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get white() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set white(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Button_default = Button;

// node_modules/@popperjs/core/dist/esm/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/dist/esm/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/dist/esm/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/dist/esm/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/dist/esm/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element2, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element2.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element2)) {
    scaleX = element2.offsetWidth > 0 ? round(clientRect.width) / element2.offsetWidth || 1 : 1;
    scaleY = element2.offsetHeight > 0 ? round(clientRect.height) / element2.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element2) {
  return {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  };
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getNodeName.js
function getNodeName(element2) {
  return element2 ? (element2.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getDocumentElement.js
function getDocumentElement(element2) {
  return ((isElement(element2) ? element2.ownerDocument : element2.document) || window.document).documentElement;
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getComputedStyle.js
function getComputedStyle(element2) {
  return getWindow(element2).getComputedStyle(element2);
}

// node_modules/@popperjs/core/dist/esm/dom-utils/isScrollParent.js
function isScrollParent(element2) {
  var _getComputedStyle = getComputedStyle(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getCompositeRect.js
function isElementScaled(element2) {
  var rect = element2.getBoundingClientRect();
  var scaleX = round(rect.width) / element2.offsetWidth || 1;
  var scaleY = round(rect.height) / element2.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getLayoutRect.js
function getLayoutRect(element2) {
  var clientRect = getBoundingClientRect(element2);
  var width = element2.offsetWidth;
  var height = element2.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element2.offsetLeft,
    y: element2.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getParentNode.js
function getParentNode(element2) {
  if (getNodeName(element2) === "html") {
    return element2;
  }
  return element2.assignedSlot || element2.parentNode || (isShadowRoot(element2) ? element2.host : null) || getDocumentElement(element2);
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/dist/esm/dom-utils/listScrollParents.js
function listScrollParents(element2, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element2);
  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

// node_modules/@popperjs/core/dist/esm/dom-utils/isTableElement.js
function isTableElement(element2) {
  return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element2) {
  if (!isHTMLElement(element2) || getComputedStyle(element2).position === "fixed") {
    return null;
  }
  return element2.offsetParent;
}
function getContainingBlock(element2) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element2)) {
    var elementCss = getComputedStyle(element2);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element2);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element2) {
  var window2 = getWindow(element2);
  var offsetParent = getTrueOffsetParent(element2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}

// node_modules/@popperjs/core/dist/esm/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/dist/esm/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/dist/esm/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/dist/esm/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/dist/esm/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getViewportRect.js
function getViewportRect(element2, strategy) {
  var win = getWindow(element2);
  var html = getDocumentElement(element2);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element2),
    y
  };
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getDocumentRect.js
function getDocumentRect(element2) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element2);
  var winScroll = getWindowScroll(element2);
  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element2);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/dist/esm/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/dist/esm/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/dist/esm/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element2, strategy) {
  var rect = getBoundingClientRect(element2, false, strategy === "fixed");
  rect.top = rect.top + element2.clientTop;
  rect.left = rect.left + element2.clientLeft;
  rect.bottom = rect.top + element2.clientHeight;
  rect.right = rect.left + element2.clientWidth;
  rect.width = element2.clientWidth;
  rect.height = element2.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element2, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
}
function getClippingParents(element2) {
  var clippingParents2 = listScrollParents(getParentNode(element2));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element2).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element2, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element2, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element2, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/dist/esm/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/dist/esm/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/dist/esm/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element2.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element2.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/dist/esm/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/dist/esm/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/dist/esm/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/dist/esm/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element2 = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/dist/esm/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element2) {
    return !(element2 && typeof element2.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper4(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance91 = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        if (false) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance91.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (false) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (false) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance: instance91
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance91.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (false) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance91;
    }
    instance91.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance: instance91,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance91;
  };
}
var createPopper = popperGenerator();

// node_modules/@popperjs/core/dist/esm/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance91 = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance91.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance91.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance91.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance91.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};

// node_modules/@popperjs/core/dist/esm/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/dist/esm/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (false) {
    var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/dist/esm/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element2 = state.elements[name];
    if (!isHTMLElement(element2) || !getNodeName(element2)) {
      return;
    }
    Object.assign(element2.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element2.removeAttribute(name2);
      } else {
        element2.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element2 = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element2.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect2,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/dist/esm/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/dist/esm/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/dist/esm/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/dist/esm/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (false) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/dist/esm/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/dist/esm/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/dist/esm/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/dist/esm/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/dist/esm/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect3(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (false) {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (false) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect3,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/dist/esm/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/dist/esm/popper-lite.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper2 = popperGenerator({
  defaultModifiers
});

// node_modules/@popperjs/core/dist/esm/popper.js
var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper3 = popperGenerator({
  defaultModifiers: defaultModifiers2
});

// node_modules/sveltestrap/src/popper.js
function createPopperActions(initOptions) {
  let contentNode;
  let options = initOptions;
  let popperInstance = null;
  let referenceNode;
  const initPopper = () => {
    if (referenceNode && contentNode) {
      popperInstance = createPopper3(referenceNode, contentNode, options);
    }
  };
  const deinitPopper = () => {
    if (popperInstance) {
      popperInstance.destroy();
      popperInstance = null;
    }
  };
  const referenceAction = (node) => {
    referenceNode = node;
    initPopper();
    return {
      destroy() {
        deinitPopper();
      }
    };
  };
  const contentAction = (node, contentOptions) => {
    contentNode = node;
    options = Object.assign(Object.assign({}, initOptions), contentOptions);
    initPopper();
    return {
      update(newContentOptions) {
        options = Object.assign(
          Object.assign({}, initOptions),
          newContentOptions
        );
        if (popperInstance && options) {
          popperInstance.setOptions(options);
        }
      },
      destroy() {
        deinitPopper();
      }
    };
  };
  return [referenceAction, contentAction, () => popperInstance];
}

// node_modules/sveltestrap/src/DropdownContext.js
var createContext = () => writable({});

// node_modules/sveltestrap/src/Dropdown.svelte
var { Error: Error_1 } = globals;
var file10 = "node_modules/sveltestrap/src/Dropdown.svelte";
function create_else_block6(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[19].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[18], null);
  let div_levels = [ctx[3], { class: ctx[2] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file10, 127, 2, 3323);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[21](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[18],
            !current ? get_all_dirty_from_scope(ctx2[18]) : get_slot_changes(default_slot_template, ctx2[18], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 8 && ctx2[3],
        (!current || dirty & 4) && { class: ctx2[2] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[21](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block6.name,
    type: "else",
    source: "(127:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block7(ctx) {
  let li;
  let current;
  const default_slot_template = ctx[19].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[18], null);
  let li_levels = [ctx[3], { class: ctx[2] }];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      set_attributes(li, li_data);
      add_location(li, file10, 123, 2, 3232);
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      ctx[20](li);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[18],
            !current ? get_all_dirty_from_scope(ctx2[18]) : get_slot_changes(default_slot_template, ctx2[18], dirty, null),
            null
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        dirty & 8 && ctx2[3],
        (!current || dirty & 4) && { class: ctx2[2] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot)
        default_slot.d(detaching);
      ctx[20](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(123:0) {#if nav}",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block7, create_else_block6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let subItemIsActive;
  let classes;
  let handleToggle;
  const omit_props_names = [
    "class",
    "active",
    "autoClose",
    "direction",
    "dropup",
    "group",
    "inNavbar",
    "isOpen",
    "nav",
    "setActiveFromChild",
    "size",
    "toggle"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dropdown", slots, ["default"]);
  const noop2 = () => void 0;
  let context = createContext();
  setContext("dropdownContext", context);
  const navbarContext = getContext("navbar");
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { autoClose = true } = $$props;
  let { direction = "down" } = $$props;
  let { dropup = false } = $$props;
  let { group = false } = $$props;
  let { inNavbar = navbarContext ? navbarContext.inNavbar : false } = $$props;
  let { isOpen = false } = $$props;
  let { nav = false } = $$props;
  let { setActiveFromChild = false } = $$props;
  let { size = "" } = $$props;
  let { toggle = void 0 } = $$props;
  const [popperRef, popperContent] = createPopperActions();
  const validDirections = ["up", "down", "left", "right", "start", "end"];
  if (validDirections.indexOf(direction) === -1) {
    throw new Error(`Invalid direction sent: '${direction}' is not one of 'up', 'down', 'left', 'right', 'start', 'end'`);
  }
  let component;
  let dropdownDirection;
  function handleDocumentClick(e) {
    if (e && (e.which === 3 || e.type === "keyup" && e.which !== 9))
      return;
    if (component.contains(e.target) && component !== e.target && (e.type !== "keyup" || e.which === 9)) {
      return;
    }
    if (autoClose === true || autoClose === "inside") {
      handleToggle(e);
    }
  }
  onDestroy(() => {
    if (typeof document !== "undefined") {
      ["click", "touchstart", "keyup"].forEach((event) => document.removeEventListener(event, handleDocumentClick, true));
    }
  });
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      component = $$value;
      $$invalidate(1, component);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      component = $$value;
      $$invalidate(1, component);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(6, active = $$new_props.active);
    if ("autoClose" in $$new_props)
      $$invalidate(7, autoClose = $$new_props.autoClose);
    if ("direction" in $$new_props)
      $$invalidate(8, direction = $$new_props.direction);
    if ("dropup" in $$new_props)
      $$invalidate(9, dropup = $$new_props.dropup);
    if ("group" in $$new_props)
      $$invalidate(10, group = $$new_props.group);
    if ("inNavbar" in $$new_props)
      $$invalidate(11, inNavbar = $$new_props.inNavbar);
    if ("isOpen" in $$new_props)
      $$invalidate(4, isOpen = $$new_props.isOpen);
    if ("nav" in $$new_props)
      $$invalidate(0, nav = $$new_props.nav);
    if ("setActiveFromChild" in $$new_props)
      $$invalidate(12, setActiveFromChild = $$new_props.setActiveFromChild);
    if ("size" in $$new_props)
      $$invalidate(13, size = $$new_props.size);
    if ("toggle" in $$new_props)
      $$invalidate(14, toggle = $$new_props.toggle);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    setContext,
    onDestroy,
    createPopperActions,
    classnames,
    createContext,
    noop: noop2,
    context,
    navbarContext,
    className,
    active,
    autoClose,
    direction,
    dropup,
    group,
    inNavbar,
    isOpen,
    nav,
    setActiveFromChild,
    size,
    toggle,
    popperRef,
    popperContent,
    validDirections,
    component,
    dropdownDirection,
    handleDocumentClick,
    handleToggle,
    subItemIsActive,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("context" in $$props)
      $$invalidate(23, context = $$new_props.context);
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(6, active = $$new_props.active);
    if ("autoClose" in $$props)
      $$invalidate(7, autoClose = $$new_props.autoClose);
    if ("direction" in $$props)
      $$invalidate(8, direction = $$new_props.direction);
    if ("dropup" in $$props)
      $$invalidate(9, dropup = $$new_props.dropup);
    if ("group" in $$props)
      $$invalidate(10, group = $$new_props.group);
    if ("inNavbar" in $$props)
      $$invalidate(11, inNavbar = $$new_props.inNavbar);
    if ("isOpen" in $$props)
      $$invalidate(4, isOpen = $$new_props.isOpen);
    if ("nav" in $$props)
      $$invalidate(0, nav = $$new_props.nav);
    if ("setActiveFromChild" in $$props)
      $$invalidate(12, setActiveFromChild = $$new_props.setActiveFromChild);
    if ("size" in $$props)
      $$invalidate(13, size = $$new_props.size);
    if ("toggle" in $$props)
      $$invalidate(14, toggle = $$new_props.toggle);
    if ("component" in $$props)
      $$invalidate(1, component = $$new_props.component);
    if ("dropdownDirection" in $$props)
      $$invalidate(15, dropdownDirection = $$new_props.dropdownDirection);
    if ("handleToggle" in $$props)
      $$invalidate(16, handleToggle = $$new_props.handleToggle);
    if ("subItemIsActive" in $$props)
      $$invalidate(17, subItemIsActive = $$new_props.subItemIsActive);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4098) {
      $:
        $$invalidate(17, subItemIsActive = !!(setActiveFromChild && component && typeof component.querySelector === "function" && component.querySelector(".active")));
    }
    if ($$self.$$.dirty & 256) {
      $: {
        if (direction === "left")
          $$invalidate(15, dropdownDirection = "start");
        else if (direction === "right")
          $$invalidate(15, dropdownDirection = "end");
        else
          $$invalidate(15, dropdownDirection = direction);
      }
    }
    if ($$self.$$.dirty & 16400) {
      $:
        $$invalidate(16, handleToggle = toggle || (() => $$invalidate(4, isOpen = !isOpen)));
    }
    if ($$self.$$.dirty & 177521) {
      $:
        $$invalidate(2, classes = classnames(className, direction !== "down" && `drop${dropdownDirection}`, nav && active ? "active" : false, setActiveFromChild && subItemIsActive ? "active" : false, {
          "btn-group": group,
          [`btn-group-${size}`]: !!size,
          dropdown: !group,
          show: isOpen,
          "nav-item": nav
        }));
    }
    if ($$self.$$.dirty & 16) {
      $: {
        if (typeof document !== "undefined") {
          if (isOpen) {
            ["click", "touchstart", "keyup"].forEach((event) => document.addEventListener(event, handleDocumentClick, true));
          } else {
            ["click", "touchstart", "keyup"].forEach((event) => document.removeEventListener(event, handleDocumentClick, true));
          }
        }
      }
    }
    if ($$self.$$.dirty & 68497) {
      $: {
        context.update(() => {
          return {
            toggle: handleToggle,
            isOpen,
            autoClose,
            direction: direction === "down" && dropup ? "up" : direction,
            inNavbar: nav || inNavbar,
            popperRef: nav ? noop2 : popperRef,
            popperContent: nav ? noop2 : popperContent
          };
        });
      }
    }
  };
  return [
    nav,
    component,
    classes,
    $$restProps,
    isOpen,
    className,
    active,
    autoClose,
    direction,
    dropup,
    group,
    inNavbar,
    setActiveFromChild,
    size,
    toggle,
    dropdownDirection,
    handleToggle,
    subItemIsActive,
    $$scope,
    slots,
    li_binding,
    div_binding
  ];
}
var Dropdown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      class: 5,
      active: 6,
      autoClose: 7,
      direction: 8,
      dropup: 9,
      group: 10,
      inNavbar: 11,
      isOpen: 4,
      nav: 0,
      setActiveFromChild: 12,
      size: 13,
      toggle: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dropdown",
      options,
      id: create_fragment10.name
    });
  }
  get class() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoClose() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoClose(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dropup() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dropup(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inNavbar() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inNavbar(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nav() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nav(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setActiveFromChild() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set setActiveFromChild(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error_1("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error_1("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dropdown_default = Dropdown;

// node_modules/sveltestrap/src/ButtonDropdown.svelte
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(5:0) <Dropdown {...$$restProps} group on:click>",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let dropdown;
  let current;
  const dropdown_spread_levels = [ctx[0], { group: true }];
  let dropdown_props = {
    $$slots: { default: [create_default_slot2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < dropdown_spread_levels.length; i += 1) {
    dropdown_props = assign(dropdown_props, dropdown_spread_levels[i]);
  }
  dropdown = new Dropdown_default({ props: dropdown_props, $$inline: true });
  dropdown.$on("click", ctx[2]);
  const block = {
    c: function create() {
      create_component(dropdown.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(dropdown, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const dropdown_changes = dirty & 1 ? get_spread_update(dropdown_spread_levels, [get_spread_object(ctx2[0]), dropdown_spread_levels[1]]) : {};
      if (dirty & 8) {
        dropdown_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dropdown.$set(dropdown_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(dropdown.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(dropdown.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(dropdown, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ButtonDropdown", slots, ["default"]);
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ Dropdown: Dropdown_default });
  return [$$restProps, slots, click_handler, $$scope];
}
var ButtonDropdown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ButtonDropdown",
      options,
      id: create_fragment11.name
    });
  }
};
var ButtonDropdown_default = ButtonDropdown;

// node_modules/sveltestrap/src/ButtonGroup.svelte
var file11 = "node_modules/sveltestrap/src/ButtonGroup.svelte";
function create_fragment12(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let div_levels = [ctx[1], { class: ctx[0] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file11, 15, 0, 305);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "size", "vertical"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ButtonGroup", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { size = "" } = $$props;
  let { vertical = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("size" in $$new_props)
      $$invalidate(3, size = $$new_props.size);
    if ("vertical" in $$new_props)
      $$invalidate(4, vertical = $$new_props.vertical);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    size,
    vertical,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("size" in $$props)
      $$invalidate(3, size = $$new_props.size);
    if ("vertical" in $$props)
      $$invalidate(4, vertical = $$new_props.vertical);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 28) {
      $:
        $$invalidate(0, classes = classnames(className, size ? `btn-group-${size}` : false, vertical ? "btn-group-vertical" : "btn-group"));
    }
  };
  return [classes, $$restProps, className, size, vertical, $$scope, slots];
}
var ButtonGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { class: 2, size: 3, vertical: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ButtonGroup",
      options,
      id: create_fragment12.name
    });
  }
  get class() {
    throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertical() {
    throw new Error("<ButtonGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<ButtonGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ButtonGroup_default = ButtonGroup;

// node_modules/sveltestrap/src/ButtonToolbar.svelte
var file12 = "node_modules/sveltestrap/src/ButtonToolbar.svelte";
function create_fragment13(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let div_levels = [ctx[1], { role: "toolbar" }, { class: ctx[0] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file12, 9, 0, 166);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 2 && ctx2[1],
        { role: "toolbar" },
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ButtonToolbar", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(0, classes = classnames(className, "btn-toolbar"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var ButtonToolbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ButtonToolbar",
      options,
      id: create_fragment13.name
    });
  }
  get class() {
    throw new Error("<ButtonToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ButtonToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ButtonToolbar_default = ButtonToolbar;

// node_modules/sveltestrap/src/Card.svelte
var file13 = "node_modules/sveltestrap/src/Card.svelte";
function create_fragment14(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  let div_levels = [
    ctx[2],
    { class: ctx[1] },
    { style: ctx[0] }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file13, 20, 0, 437);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(div, "click", ctx[10], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 4 && ctx2[2],
        (!current || dirty & 2) && { class: ctx2[1] },
        (!current || dirty & 1) && { style: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "body", "color", "inverse", "outline", "style"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Card", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { body = false } = $$props;
  let { color = "" } = $$props;
  let { inverse = false } = $$props;
  let { outline = false } = $$props;
  let { style = "" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("body" in $$new_props)
      $$invalidate(4, body = $$new_props.body);
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("inverse" in $$new_props)
      $$invalidate(6, inverse = $$new_props.inverse);
    if ("outline" in $$new_props)
      $$invalidate(7, outline = $$new_props.outline);
    if ("style" in $$new_props)
      $$invalidate(0, style = $$new_props.style);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    body,
    color,
    inverse,
    outline,
    style,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("body" in $$props)
      $$invalidate(4, body = $$new_props.body);
    if ("color" in $$props)
      $$invalidate(5, color = $$new_props.color);
    if ("inverse" in $$props)
      $$invalidate(6, inverse = $$new_props.inverse);
    if ("outline" in $$props)
      $$invalidate(7, outline = $$new_props.outline);
    if ("style" in $$props)
      $$invalidate(0, style = $$new_props.style);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 248) {
      $:
        $$invalidate(1, classes = classnames(className, "card", inverse ? "text-white" : false, body ? "card-body" : false, color ? `${outline ? "border" : "bg"}-${color}` : false));
    }
  };
  return [
    style,
    classes,
    $$restProps,
    className,
    body,
    color,
    inverse,
    outline,
    $$scope,
    slots,
    click_handler
  ];
}
var Card = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {
      class: 3,
      body: 4,
      color: 5,
      inverse: 6,
      outline: 7,
      style: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Card",
      options,
      id: create_fragment14.name
    });
  }
  get class() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get body() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set body(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inverse() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inverse(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Card_default = Card;

// node_modules/sveltestrap/src/CardBody.svelte
var file14 = "node_modules/sveltestrap/src/CardBody.svelte";
function create_fragment15(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let div_levels = [ctx[1], { class: ctx[0] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file14, 9, 0, 164);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardBody", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-body"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardBody",
      options,
      id: create_fragment15.name
    });
  }
  get class() {
    throw new Error("<CardBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardBody_default = CardBody;

// node_modules/sveltestrap/src/CardColumns.svelte
var file15 = "node_modules/sveltestrap/src/CardColumns.svelte";
function create_fragment16(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let div_levels = [ctx[1], { class: ctx[0] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file15, 9, 0, 167);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardColumns", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-columns"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardColumns = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardColumns",
      options,
      id: create_fragment16.name
    });
  }
  get class() {
    throw new Error("<CardColumns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardColumns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardColumns_default = CardColumns;

// node_modules/sveltestrap/src/CardDeck.svelte
var file16 = "node_modules/sveltestrap/src/CardDeck.svelte";
function create_fragment17(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let div_levels = [ctx[1], { class: ctx[0] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file16, 9, 0, 164);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardDeck", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-deck"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardDeck = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardDeck",
      options,
      id: create_fragment17.name
    });
  }
  get class() {
    throw new Error("<CardDeck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardDeck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardDeck_default = CardDeck;

// node_modules/sveltestrap/src/CardFooter.svelte
var file17 = "node_modules/sveltestrap/src/CardFooter.svelte";
function create_fragment18(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let div_levels = [ctx[1], { class: ctx[0] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file17, 9, 0, 166);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardFooter", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-footer"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardFooter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardFooter",
      options,
      id: create_fragment18.name
    });
  }
  get class() {
    throw new Error("<CardFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardFooter_default = CardFooter;

// node_modules/sveltestrap/src/CardGroup.svelte
var file18 = "node_modules/sveltestrap/src/CardGroup.svelte";
function create_fragment19(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let div_levels = [ctx[1], { class: ctx[0] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file18, 9, 0, 165);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardGroup", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-group"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardGroup",
      options,
      id: create_fragment19.name
    });
  }
  get class() {
    throw new Error("<CardGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardGroup_default = CardGroup;

// node_modules/sveltestrap/src/CardHeader.svelte
var file19 = "node_modules/sveltestrap/src/CardHeader.svelte";
function create_else_block7(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  let div_levels = [ctx[2], { class: ctx[1] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file19, 15, 2, 291);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(div, "click", ctx[7], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 4 && ctx2[2],
        (!current || dirty & 2) && { class: ctx2[1] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block7.name,
    type: "else",
    source: "(15:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block8(ctx) {
  let h3;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  let h3_levels = [ctx[2], { class: ctx[1] }];
  let h3_data = {};
  for (let i = 0; i < h3_levels.length; i += 1) {
    h3_data = assign(h3_data, h3_levels[i]);
  }
  const block = {
    c: function create() {
      h3 = element("h3");
      if (default_slot)
        default_slot.c();
      set_attributes(h3, h3_data);
      add_location(h3, file19, 11, 2, 213);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h3, anchor);
      if (default_slot) {
        default_slot.m(h3, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(h3, "click", ctx[6], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
      set_attributes(h3, h3_data = get_spread_update(h3_levels, [
        dirty & 4 && ctx2[2],
        (!current || dirty & 2) && { class: ctx2[1] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h3);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(11:0) {#if tag === 'h3'}",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block8, create_else_block7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] === "h3")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "tag"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardHeader", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { tag = "div" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("tag" in $$new_props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, tag, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("tag" in $$props)
      $$invalidate(0, tag = $$new_props.tag);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8) {
      $:
        $$invalidate(1, classes = classnames(className, "card-header"));
    }
  };
  return [
    tag,
    classes,
    $$restProps,
    className,
    $$scope,
    slots,
    click_handler,
    click_handler_1
  ];
}
var CardHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, { class: 3, tag: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardHeader",
      options,
      id: create_fragment20.name
    });
  }
  get class() {
    throw new Error("<CardHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<CardHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<CardHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardHeader_default = CardHeader;

// node_modules/sveltestrap/src/CardImg.svelte
var file20 = "node_modules/sveltestrap/src/CardImg.svelte";
function create_fragment21(ctx) {
  let img;
  let img_src_value;
  let img_levels = [
    ctx[3],
    { class: ctx[2] },
    { src: img_src_value = ctx[0] },
    { alt: ctx[1] }
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      set_attributes(img, img_data);
      add_location(img, file20, 23, 0, 464);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(img, img_data = get_spread_update(img_levels, [
        dirty & 8 && ctx2[3],
        dirty & 4 && { class: ctx2[2] },
        dirty & 1 && !src_url_equal(img.src, img_src_value = ctx2[0]) && { src: img_src_value },
        dirty & 2 && { alt: ctx2[1] }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "top", "bottom", "src", "alt"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardImg", slots, []);
  let { class: className = "" } = $$props;
  let { top: top2 = false } = $$props;
  let { bottom: bottom2 = false } = $$props;
  let { src } = $$props;
  let { alt = "" } = $$props;
  let classes = "";
  $$self.$$.on_mount.push(function() {
    if (src === void 0 && !("src" in $$props || $$self.$$.bound[$$self.$$.props["src"]])) {
      console.warn("<CardImg> was created without expected prop 'src'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("top" in $$new_props)
      $$invalidate(5, top2 = $$new_props.top);
    if ("bottom" in $$new_props)
      $$invalidate(6, bottom2 = $$new_props.bottom);
    if ("src" in $$new_props)
      $$invalidate(0, src = $$new_props.src);
    if ("alt" in $$new_props)
      $$invalidate(1, alt = $$new_props.alt);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    top: top2,
    bottom: bottom2,
    src,
    alt,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("top" in $$props)
      $$invalidate(5, top2 = $$new_props.top);
    if ("bottom" in $$props)
      $$invalidate(6, bottom2 = $$new_props.bottom);
    if ("src" in $$props)
      $$invalidate(0, src = $$new_props.src);
    if ("alt" in $$props)
      $$invalidate(1, alt = $$new_props.alt);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 112) {
      $: {
        let cardImgClassName = "card-img";
        if (top2) {
          cardImgClassName = "card-img-top";
        }
        if (bottom2) {
          cardImgClassName = "card-img-bottom";
        }
        $$invalidate(2, classes = classnames(className, cardImgClassName));
      }
    }
  };
  return [src, alt, classes, $$restProps, className, top2, bottom2];
}
var CardImg = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, {
      class: 4,
      top: 5,
      bottom: 6,
      src: 0,
      alt: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardImg",
      options,
      id: create_fragment21.name
    });
  }
  get class() {
    throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get top() {
    throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set top(value) {
    throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bottom() {
    throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bottom(value) {
    throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get src() {
    throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardImg_default = CardImg;

// node_modules/sveltestrap/src/CardImgOverlay.svelte
var file21 = "node_modules/sveltestrap/src/CardImgOverlay.svelte";
function create_fragment22(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let div_levels = [ctx[1], { class: ctx[0] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file21, 9, 0, 171);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardImgOverlay", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-img-overlay"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardImgOverlay = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardImgOverlay",
      options,
      id: create_fragment22.name
    });
  }
  get class() {
    throw new Error("<CardImgOverlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardImgOverlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardImgOverlay_default = CardImgOverlay;

// node_modules/sveltestrap/src/CardLink.svelte
var file22 = "node_modules/sveltestrap/src/CardLink.svelte";
function create_fragment23(ctx) {
  let a;
  let current;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  let a_levels = [
    ctx[2],
    { class: ctx[1] },
    { href: ctx[0] }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
      add_location(a, file22, 10, 0, 188);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & 4 && ctx2[2],
        (!current || dirty & 2) && { class: ctx2[1] },
        (!current || dirty & 1) && { href: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardLink", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { href = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("href" in $$new_props)
      $$invalidate(0, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, href, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("href" in $$props)
      $$invalidate(0, href = $$new_props.href);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8) {
      $:
        $$invalidate(1, classes = classnames(className, "card-link"));
    }
  };
  return [href, classes, $$restProps, className, $$scope, slots];
}
var CardLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, { class: 3, href: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardLink",
      options,
      id: create_fragment23.name
    });
  }
  get class() {
    throw new Error("<CardLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<CardLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<CardLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardLink_default = CardLink;

// node_modules/sveltestrap/src/CardSubtitle.svelte
var file23 = "node_modules/sveltestrap/src/CardSubtitle.svelte";
function create_fragment24(ctx) {
  let h6;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let h6_levels = [ctx[1], { class: ctx[0] }];
  let h6_data = {};
  for (let i = 0; i < h6_levels.length; i += 1) {
    h6_data = assign(h6_data, h6_levels[i]);
  }
  const block = {
    c: function create() {
      h6 = element("h6");
      if (default_slot)
        default_slot.c();
      set_attributes(h6, h6_data);
      add_location(h6, file23, 9, 0, 168);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h6, anchor);
      if (default_slot) {
        default_slot.m(h6, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(h6, h6_data = get_spread_update(h6_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h6);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardSubtitle", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-subtitle"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardSubtitle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardSubtitle",
      options,
      id: create_fragment24.name
    });
  }
  get class() {
    throw new Error("<CardSubtitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardSubtitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardSubtitle_default = CardSubtitle;

// node_modules/sveltestrap/src/CardText.svelte
var file24 = "node_modules/sveltestrap/src/CardText.svelte";
function create_fragment25(ctx) {
  let p;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let p_levels = [ctx[1], { class: ctx[0] }];
  let p_data = {};
  for (let i = 0; i < p_levels.length; i += 1) {
    p_data = assign(p_data, p_levels[i]);
  }
  const block = {
    c: function create() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      set_attributes(p, p_data);
      add_location(p, file24, 9, 0, 164);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardText", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-text"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardText",
      options,
      id: create_fragment25.name
    });
  }
  get class() {
    throw new Error("<CardText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardText_default = CardText;

// node_modules/sveltestrap/src/CardTitle.svelte
var file25 = "node_modules/sveltestrap/src/CardTitle.svelte";
function create_fragment26(ctx) {
  let h5;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let h5_levels = [ctx[1], { class: ctx[0] }];
  let h5_data = {};
  for (let i = 0; i < h5_levels.length; i += 1) {
    h5_data = assign(h5_data, h5_levels[i]);
  }
  const block = {
    c: function create() {
      h5 = element("h5");
      if (default_slot)
        default_slot.c();
      set_attributes(h5, h5_data);
      add_location(h5, file25, 9, 0, 165);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, h5, anchor);
      if (default_slot) {
        default_slot.m(h5, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(h5, h5_data = get_spread_update(h5_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h5);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardTitle", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(0, classes = classnames(className, "card-title"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var CardTitle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardTitle",
      options,
      id: create_fragment26.name
    });
  }
  get class() {
    throw new Error("<CardTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardTitle_default = CardTitle;

// node_modules/sveltestrap/src/Carousel.svelte
var file26 = "node_modules/sveltestrap/src/Carousel.svelte";
function create_fragment27(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[15].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[14], null);
  let div_levels = [
    ctx[6],
    { class: ctx[2] },
    { style: ctx[0] }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file26, 88, 0, 1873);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window, "keydown", ctx[3], false, false, false),
          listen_dev(div, "mouseenter", ctx[16], false, false, false),
          listen_dev(div, "mouseleave", ctx[17], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(default_slot_template, ctx2[14], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 64 && ctx2[6],
        (!current || dirty & 4) && { class: ctx2[2] },
        (!current || dirty & 1) && { style: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "class",
    "style",
    "items",
    "activeIndex",
    "dark",
    "ride",
    "interval",
    "pause",
    "keyboard"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Carousel", slots, ["default"]);
  let classes = "";
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { items = [] } = $$props;
  let { activeIndex = 0 } = $$props;
  let { dark = false } = $$props;
  let { ride = true } = $$props;
  let { interval = 5e3 } = $$props;
  let { pause = true } = $$props;
  let { keyboard = true } = $$props;
  let _rideTimeoutId = false;
  let _removeVisibilityChangeListener = false;
  onMount(() => {
    setRideTimeout();
    _removeVisibilityChangeListener = browserEvent(document, "visibilitychange", () => {
      if (document.visibilityState === "hidden") {
        clearRideTimeout();
      } else {
        setRideTimeout();
      }
    });
  });
  onDestroy(() => {
    if (_rideTimeoutId) {
      clearTimeout(_rideTimeoutId);
    }
    if (_removeVisibilityChangeListener) {
      _removeVisibilityChangeListener();
    }
  });
  function handleKeydown(event) {
    if (!keyboard) {
      return;
    }
    let direction = "";
    if (event.key === "ArrowLeft") {
      direction = "prev";
    } else if (event.key === "ArrowRight") {
      direction = "next";
    } else {
      return;
    }
    $$invalidate(7, activeIndex = getNewCarouselActiveIndex(direction, items, activeIndex));
  }
  function setRideTimeout() {
    clearRideTimeout();
    if (ride) {
      _rideTimeoutId = setTimeout(autoNext, interval);
    }
  }
  function clearRideTimeout() {
    if (_rideTimeoutId) {
      clearTimeout(_rideTimeoutId);
    }
  }
  function autoNext() {
    $$invalidate(7, activeIndex = getNewCarouselActiveIndex("next", items, activeIndex));
  }
  const mouseenter_handler = () => pause ? clearRideTimeout() : void 0;
  const mouseleave_handler = () => pause ? setRideTimeout() : void 0;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(8, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(0, style = $$new_props.style);
    if ("items" in $$new_props)
      $$invalidate(9, items = $$new_props.items);
    if ("activeIndex" in $$new_props)
      $$invalidate(7, activeIndex = $$new_props.activeIndex);
    if ("dark" in $$new_props)
      $$invalidate(10, dark = $$new_props.dark);
    if ("ride" in $$new_props)
      $$invalidate(11, ride = $$new_props.ride);
    if ("interval" in $$new_props)
      $$invalidate(12, interval = $$new_props.interval);
    if ("pause" in $$new_props)
      $$invalidate(1, pause = $$new_props.pause);
    if ("keyboard" in $$new_props)
      $$invalidate(13, keyboard = $$new_props.keyboard);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    classnames,
    getNewCarouselActiveIndex,
    browserEvent,
    classes,
    className,
    style,
    items,
    activeIndex,
    dark,
    ride,
    interval,
    pause,
    keyboard,
    _rideTimeoutId,
    _removeVisibilityChangeListener,
    handleKeydown,
    setRideTimeout,
    clearRideTimeout,
    autoNext
  });
  $$self.$inject_state = ($$new_props) => {
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
    if ("className" in $$props)
      $$invalidate(8, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(0, style = $$new_props.style);
    if ("items" in $$props)
      $$invalidate(9, items = $$new_props.items);
    if ("activeIndex" in $$props)
      $$invalidate(7, activeIndex = $$new_props.activeIndex);
    if ("dark" in $$props)
      $$invalidate(10, dark = $$new_props.dark);
    if ("ride" in $$props)
      $$invalidate(11, ride = $$new_props.ride);
    if ("interval" in $$props)
      $$invalidate(12, interval = $$new_props.interval);
    if ("pause" in $$props)
      $$invalidate(1, pause = $$new_props.pause);
    if ("keyboard" in $$props)
      $$invalidate(13, keyboard = $$new_props.keyboard);
    if ("_rideTimeoutId" in $$props)
      _rideTimeoutId = $$new_props._rideTimeoutId;
    if ("_removeVisibilityChangeListener" in $$props)
      _removeVisibilityChangeListener = $$new_props._removeVisibilityChangeListener;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1280) {
      $:
        $$invalidate(2, classes = classnames(className, "carousel", "slide", { "carousel-dark": dark }));
    }
  };
  return [
    style,
    pause,
    classes,
    handleKeydown,
    setRideTimeout,
    clearRideTimeout,
    $$restProps,
    activeIndex,
    className,
    items,
    dark,
    ride,
    interval,
    keyboard,
    $$scope,
    slots,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var Carousel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, {
      class: 8,
      style: 0,
      items: 9,
      activeIndex: 7,
      dark: 10,
      ride: 11,
      interval: 12,
      pause: 1,
      keyboard: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Carousel",
      options,
      id: create_fragment27.name
    });
  }
  get class() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeIndex() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeIndex(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dark() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dark(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ride() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ride(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interval() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interval(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pause() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pause(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keyboard() {
    throw new Error("<Carousel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keyboard(value) {
    throw new Error("<Carousel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Carousel_default = Carousel;

// node_modules/sveltestrap/src/CarouselCaption.svelte
var file27 = "node_modules/sveltestrap/src/CarouselCaption.svelte";
function create_if_block_14(ctx) {
  let h5;
  let t;
  const block = {
    c: function create() {
      h5 = element("h5");
      t = text(ctx[0]);
      add_location(h5, file27, 18, 21, 359);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h5, anchor);
      append_dev(h5, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1)
        set_data_dev(t, ctx2[0]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h5);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(19:2) {#if captionHeader}",
    ctx
  });
  return block;
}
function create_if_block9(ctx) {
  let p;
  let t;
  const block = {
    c: function create() {
      p = element("p");
      t = text(ctx[1]);
      add_location(p, file27, 19, 19, 408);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      append_dev(p, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(20:2) {#if captionText}",
    ctx
  });
  return block;
}
function create_fragment28(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  let if_block0 = ctx[0] && create_if_block_14(ctx);
  let if_block1 = ctx[1] && create_if_block9(ctx);
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let div_levels = [ctx[3], { class: ctx[2] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file27, 17, 0, 299);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_14(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block9(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 8 && ctx2[3],
        (!current || dirty & 4) && { class: ctx2[2] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "captionHeader", "captionText"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CarouselCaption", slots, ["default"]);
  let classes = "";
  let { class: className = "" } = $$props;
  let { captionHeader = "" } = $$props;
  let { captionText = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("captionHeader" in $$new_props)
      $$invalidate(0, captionHeader = $$new_props.captionHeader);
    if ("captionText" in $$new_props)
      $$invalidate(1, captionText = $$new_props.captionText);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    classes,
    className,
    captionHeader,
    captionText
  });
  $$self.$inject_state = ($$new_props) => {
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("captionHeader" in $$props)
      $$invalidate(0, captionHeader = $$new_props.captionHeader);
    if ("captionText" in $$props)
      $$invalidate(1, captionText = $$new_props.captionText);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      $:
        $$invalidate(2, classes = classnames(className, "carousel-caption", "d-none", "d-md-block"));
    }
  };
  return [captionHeader, captionText, classes, $$restProps, className, $$scope, slots];
}
var CarouselCaption = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, {
      class: 4,
      captionHeader: 0,
      captionText: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CarouselCaption",
      options,
      id: create_fragment28.name
    });
  }
  get class() {
    throw new Error("<CarouselCaption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CarouselCaption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get captionHeader() {
    throw new Error("<CarouselCaption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set captionHeader(value) {
    throw new Error("<CarouselCaption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get captionText() {
    throw new Error("<CarouselCaption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set captionText(value) {
    throw new Error("<CarouselCaption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CarouselCaption_default = CarouselCaption;

// node_modules/sveltestrap/src/CarouselControl.svelte
var file28 = "node_modules/sveltestrap/src/CarouselControl.svelte";
function create_fragment29(ctx) {
  let a;
  let span0;
  let span0_class_value;
  let t0;
  let span1;
  let t1;
  let a_href_value;
  let mounted;
  let dispose;
  let a_levels = [
    ctx[4],
    { class: ctx[1] },
    { role: "button" },
    {
      href: a_href_value = "#" + ctx[0]
    }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(ctx[2]);
      attr_dev(span0, "class", span0_class_value = "carousel-control-" + ctx[0] + "-icon");
      attr_dev(span0, "aria-hidden", "true");
      add_location(span0, file28, 46, 2, 1099);
      attr_dev(span1, "class", "visually-hidden");
      add_location(span1, file28, 47, 2, 1171);
      set_attributes(a, a_data);
      add_location(a, file28, 39, 0, 976);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      append_dev(a, span0);
      append_dev(a, t0);
      append_dev(a, span1);
      append_dev(span1, t1);
      if (!mounted) {
        dispose = listen_dev(a, "click", prevent_default(ctx[3]), false, true, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 1 && span0_class_value !== (span0_class_value = "carousel-control-" + ctx2[0] + "-icon")) {
        attr_dev(span0, "class", span0_class_value);
      }
      if (dirty & 4)
        set_data_dev(t1, ctx2[2]);
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & 16 && ctx2[4],
        dirty & 2 && { class: ctx2[1] },
        { role: "button" },
        dirty & 1 && a_href_value !== (a_href_value = "#" + ctx2[0]) && { href: a_href_value }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance29($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "direction", "directionText", "activeIndex", "items", "wrap"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CarouselControl", slots, []);
  let classes = "";
  let { class: className = "" } = $$props;
  let srText = "";
  let { direction = "" } = $$props;
  let { directionText = "" } = $$props;
  let { activeIndex = 0 } = $$props;
  let { items = [] } = $$props;
  let { wrap = true } = $$props;
  const getSrText = (direction2) => {
    if (direction2 === "next") {
      return "Next";
    } else if (direction2 === "prev") {
      return "Previous";
    }
  };
  function clickHandler() {
    const endOrBeginning = direction === "next" && activeIndex + 1 > items.length - 1 || direction === "previous" && activeIndex - 1 < 0;
    if (!wrap && endOrBeginning) {
      return;
    }
    $$invalidate(5, activeIndex = getNewCarouselActiveIndex(direction, items, activeIndex));
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("direction" in $$new_props)
      $$invalidate(0, direction = $$new_props.direction);
    if ("directionText" in $$new_props)
      $$invalidate(7, directionText = $$new_props.directionText);
    if ("activeIndex" in $$new_props)
      $$invalidate(5, activeIndex = $$new_props.activeIndex);
    if ("items" in $$new_props)
      $$invalidate(8, items = $$new_props.items);
    if ("wrap" in $$new_props)
      $$invalidate(9, wrap = $$new_props.wrap);
  };
  $$self.$capture_state = () => ({
    classnames,
    getNewCarouselActiveIndex,
    classes,
    className,
    srText,
    direction,
    directionText,
    activeIndex,
    items,
    wrap,
    getSrText,
    clickHandler
  });
  $$self.$inject_state = ($$new_props) => {
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("srText" in $$props)
      $$invalidate(2, srText = $$new_props.srText);
    if ("direction" in $$props)
      $$invalidate(0, direction = $$new_props.direction);
    if ("directionText" in $$props)
      $$invalidate(7, directionText = $$new_props.directionText);
    if ("activeIndex" in $$props)
      $$invalidate(5, activeIndex = $$new_props.activeIndex);
    if ("items" in $$props)
      $$invalidate(8, items = $$new_props.items);
    if ("wrap" in $$props)
      $$invalidate(9, wrap = $$new_props.wrap);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 65) {
      $:
        $$invalidate(1, classes = classnames(`carousel-control-${direction}`, className));
    }
    if ($$self.$$.dirty & 129) {
      $:
        $$invalidate(2, srText = directionText ? directionText : getSrText(direction));
    }
  };
  return [
    direction,
    classes,
    srText,
    clickHandler,
    $$restProps,
    activeIndex,
    className,
    directionText,
    items,
    wrap
  ];
}
var CarouselControl = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, {
      class: 6,
      direction: 0,
      directionText: 7,
      activeIndex: 5,
      items: 8,
      wrap: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CarouselControl",
      options,
      id: create_fragment29.name
    });
  }
  get class() {
    throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get directionText() {
    throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set directionText(value) {
    throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeIndex() {
    throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeIndex(value) {
    throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrap() {
    throw new Error("<CarouselControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrap(value) {
    throw new Error("<CarouselControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CarouselControl_default = CarouselControl;

// node_modules/sveltestrap/src/CarouselIndicators.svelte
var file29 = "node_modules/sveltestrap/src/CarouselIndicators.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[8] = i;
  return child_ctx;
}
function create_each_block(ctx) {
  let button;
  let t0_value = (ctx[6].title ? ctx[6].title : "") + "";
  let t0;
  let t1;
  let button_aria_current_value;
  let button_aria_label_value;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[5](ctx[8]);
  }
  const block = {
    c: function create() {
      button = element("button");
      t0 = text(t0_value);
      t1 = space();
      attr_dev(button, "data-bs-target", "");
      attr_dev(button, "aria-current", button_aria_current_value = ctx[0] === ctx[8]);
      attr_dev(button, "aria-label", button_aria_label_value = ctx[6].title);
      toggle_class(button, "active", ctx[0] === ctx[8]);
      add_location(button, file29, 14, 4, 323);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      append_dev(button, t0);
      append_dev(button, t1);
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2 && t0_value !== (t0_value = (ctx[6].title ? ctx[6].title : "") + ""))
        set_data_dev(t0, t0_value);
      if (dirty & 1 && button_aria_current_value !== (button_aria_current_value = ctx[0] === ctx[8])) {
        attr_dev(button, "aria-current", button_aria_current_value);
      }
      if (dirty & 2 && button_aria_label_value !== (button_aria_label_value = ctx[6].title)) {
        attr_dev(button, "aria-label", button_aria_label_value);
      }
      if (dirty & 1) {
        toggle_class(button, "active", ctx[0] === ctx[8]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(14:2) {#each items as item, index}",
    ctx
  });
  return block;
}
function create_fragment30(ctx) {
  let div;
  let each_value = ctx[1];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  let div_levels = [ctx[3], { class: ctx[2] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      set_attributes(div, div_data);
      add_location(div, file29, 12, 0, 249);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 3) {
        each_value = ctx2[1];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 8 && ctx2[3],
        dirty & 4 && { class: ctx2[2] }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance30($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "items", "activeIndex"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CarouselIndicators", slots, []);
  let { class: className = "" } = $$props;
  let classes = "";
  let { items = [] } = $$props;
  let { activeIndex = 0 } = $$props;
  const click_handler = (index) => $$invalidate(0, activeIndex = index);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("items" in $$new_props)
      $$invalidate(1, items = $$new_props.items);
    if ("activeIndex" in $$new_props)
      $$invalidate(0, activeIndex = $$new_props.activeIndex);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    classes,
    items,
    activeIndex
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
    if ("items" in $$props)
      $$invalidate(1, items = $$new_props.items);
    if ("activeIndex" in $$props)
      $$invalidate(0, activeIndex = $$new_props.activeIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      $:
        $$invalidate(2, classes = classnames(className, "carousel-indicators"));
    }
  };
  return [activeIndex, items, classes, $$restProps, className, click_handler];
}
var CarouselIndicators = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, { class: 4, items: 1, activeIndex: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CarouselIndicators",
      options,
      id: create_fragment30.name
    });
  }
  get class() {
    throw new Error("<CarouselIndicators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CarouselIndicators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<CarouselIndicators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<CarouselIndicators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeIndex() {
    throw new Error("<CarouselIndicators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeIndex(value) {
    throw new Error("<CarouselIndicators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CarouselIndicators_default = CarouselIndicators;

// node_modules/sveltestrap/src/CarouselItem.svelte
var file30 = "node_modules/sveltestrap/src/CarouselItem.svelte";
function create_fragment31(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let div_levels = [
    ctx[3],
    {
      class: div_class_value = ctx[2] + " active"
    }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      toggle_class(div, "active", ctx[0] === ctx[1]);
      add_location(div, file30, 12, 0, 246);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 8 && ctx2[3],
        (!current || dirty & 4 && div_class_value !== (div_class_value = ctx2[2] + " active")) && { class: div_class_value }
      ]));
      toggle_class(div, "active", ctx2[0] === ctx2[1]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance31($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "itemIndex", "activeIndex"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CarouselItem", slots, ["default"]);
  let classes = "";
  let { class: className = "" } = $$props;
  let { itemIndex = 0 } = $$props;
  let { activeIndex = 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("itemIndex" in $$new_props)
      $$invalidate(0, itemIndex = $$new_props.itemIndex);
    if ("activeIndex" in $$new_props)
      $$invalidate(1, activeIndex = $$new_props.activeIndex);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    classes,
    className,
    itemIndex,
    activeIndex
  });
  $$self.$inject_state = ($$new_props) => {
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("itemIndex" in $$props)
      $$invalidate(0, itemIndex = $$new_props.itemIndex);
    if ("activeIndex" in $$props)
      $$invalidate(1, activeIndex = $$new_props.activeIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      $:
        $$invalidate(2, classes = classnames(className, "carousel-item"));
    }
  };
  return [itemIndex, activeIndex, classes, $$restProps, className, $$scope, slots];
}
var CarouselItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, { class: 4, itemIndex: 0, activeIndex: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CarouselItem",
      options,
      id: create_fragment31.name
    });
  }
  get class() {
    throw new Error("<CarouselItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CarouselItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemIndex() {
    throw new Error("<CarouselItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemIndex(value) {
    throw new Error("<CarouselItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeIndex() {
    throw new Error("<CarouselItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeIndex(value) {
    throw new Error("<CarouselItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CarouselItem_default = CarouselItem;

// node_modules/sveltestrap/src/Col.svelte
var file31 = "node_modules/sveltestrap/src/Col.svelte";
function create_fragment32(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  let div_levels = [
    ctx[1],
    {
      class: div_class_value = ctx[0].join(" ")
    }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file31, 63, 0, 1536);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 2 && ctx2[1],
        { class: div_class_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "xs", "sm", "md", "lg", "xl", "xxl"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Col", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { xs = void 0 } = $$props;
  let { sm = void 0 } = $$props;
  let { md = void 0 } = $$props;
  let { lg = void 0 } = $$props;
  let { xl = void 0 } = $$props;
  let { xxl = void 0 } = $$props;
  const colClasses = [];
  const lookup = { xs, sm, md, lg, xl, xxl };
  Object.keys(lookup).forEach((colWidth) => {
    const columnProp = lookup[colWidth];
    if (!columnProp && columnProp !== "") {
      return;
    }
    const isXs = colWidth === "xs";
    if (isObject(columnProp)) {
      const colSizeInterfix = isXs ? "-" : `-${colWidth}-`;
      const colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);
      if (columnProp.size || columnProp.size === "") {
        colClasses.push(colClass);
      }
      if (columnProp.push) {
        colClasses.push(`push${colSizeInterfix}${columnProp.push}`);
      }
      if (columnProp.pull) {
        colClasses.push(`pull${colSizeInterfix}${columnProp.pull}`);
      }
      if (columnProp.offset) {
        colClasses.push(`offset${colSizeInterfix}${columnProp.offset}`);
      }
      if (columnProp.order) {
        colClasses.push(`order${colSizeInterfix}${columnProp.order}`);
      }
    } else {
      colClasses.push(getColumnSizeClass(isXs, colWidth, columnProp));
    }
  });
  if (!colClasses.length) {
    colClasses.push("col");
  }
  if (className) {
    colClasses.push(className);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("xs" in $$new_props)
      $$invalidate(3, xs = $$new_props.xs);
    if ("sm" in $$new_props)
      $$invalidate(4, sm = $$new_props.sm);
    if ("md" in $$new_props)
      $$invalidate(5, md = $$new_props.md);
    if ("lg" in $$new_props)
      $$invalidate(6, lg = $$new_props.lg);
    if ("xl" in $$new_props)
      $$invalidate(7, xl = $$new_props.xl);
    if ("xxl" in $$new_props)
      $$invalidate(8, xxl = $$new_props.xxl);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getColumnSizeClass,
    isObject,
    className,
    xs,
    sm,
    md,
    lg,
    xl,
    xxl,
    colClasses,
    lookup
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("xs" in $$props)
      $$invalidate(3, xs = $$new_props.xs);
    if ("sm" in $$props)
      $$invalidate(4, sm = $$new_props.sm);
    if ("md" in $$props)
      $$invalidate(5, md = $$new_props.md);
    if ("lg" in $$props)
      $$invalidate(6, lg = $$new_props.lg);
    if ("xl" in $$props)
      $$invalidate(7, xl = $$new_props.xl);
    if ("xxl" in $$props)
      $$invalidate(8, xxl = $$new_props.xxl);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [colClasses, $$restProps, className, xs, sm, md, lg, xl, xxl, $$scope, slots];
}
var Col = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, {
      class: 2,
      xs: 3,
      sm: 4,
      md: 5,
      lg: 6,
      xl: 7,
      xxl: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Col",
      options,
      id: create_fragment32.name
    });
  }
  get class() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xs() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xs(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sm() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sm(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get md() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set md(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lg() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lg(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xl() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xl(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xxl() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xxl(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Col_default = Col;

// node_modules/sveltestrap/src/Column.svelte
var file32 = "node_modules/sveltestrap/src/Column.svelte";
var get_header_slot_changes2 = (dirty) => ({});
var get_header_slot_context2 = (ctx) => ({});
var get_footer_slot_changes = (dirty) => ({});
var get_footer_slot_context = (ctx) => ({});
function create_else_block8(ctx) {
  let td;
  let current;
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  let td_levels = [{ class: ctx[0] }, ctx[7]];
  let td_data = {};
  for (let i = 0; i < td_levels.length; i += 1) {
    td_data = assign(td_data, td_levels[i]);
  }
  const block = {
    c: function create() {
      td = element("td");
      if (default_slot)
        default_slot.c();
      set_attributes(td, td_data);
      add_location(td, file32, 27, 2, 600);
    },
    m: function mount(target, anchor) {
      insert_dev(target, td, anchor);
      if (default_slot) {
        default_slot.m(td, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, null),
            null
          );
        }
      }
      set_attributes(td, td_data = get_spread_update(td_levels, [
        (!current || dirty & 1) && { class: ctx2[0] },
        dirty & 128 && ctx2[7]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block8.name,
    type: "else",
    source: "(27:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let th;
  let t;
  let current;
  let if_block = ctx[2] && create_if_block_4(ctx);
  const header_slot_template = ctx[9].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[8], get_header_slot_context2);
  let th_levels = [ctx[7]];
  let th_data = {};
  for (let i = 0; i < th_levels.length; i += 1) {
    th_data = assign(th_data, th_levels[i]);
  }
  const block = {
    c: function create() {
      th = element("th");
      if (if_block)
        if_block.c();
      t = space();
      if (header_slot)
        header_slot.c();
      set_attributes(th, th_data);
      add_location(th, file32, 22, 2, 503);
    },
    m: function mount(target, anchor) {
      insert_dev(target, th, anchor);
      if (if_block)
        if_block.m(th, null);
      append_dev(th, t);
      if (header_slot) {
        header_slot.m(th, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4(ctx2);
          if_block.c();
          if_block.m(th, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(header_slot_template, ctx2[8], dirty, get_header_slot_changes2),
            get_header_slot_context2
          );
        }
      }
      set_attributes(th, th_data = get_spread_update(th_levels, [dirty & 128 && ctx2[7]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
      if (if_block)
        if_block.d();
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(22:15) ",
    ctx
  });
  return block;
}
function create_if_block_15(ctx) {
  let th;
  let t;
  let current;
  let if_block = ctx[1] && create_if_block_24(ctx);
  const footer_slot_template = ctx[9].footer;
  const footer_slot = create_slot(footer_slot_template, ctx, ctx[8], get_footer_slot_context);
  let th_levels = [ctx[7]];
  let th_data = {};
  for (let i = 0; i < th_levels.length; i += 1) {
    th_data = assign(th_data, th_levels[i]);
  }
  const block = {
    c: function create() {
      th = element("th");
      if (if_block)
        if_block.c();
      t = space();
      if (footer_slot)
        footer_slot.c();
      set_attributes(th, th_data);
      add_location(th, file32, 17, 2, 398);
    },
    m: function mount(target, anchor) {
      insert_dev(target, th, anchor);
      if (if_block)
        if_block.m(th, null);
      append_dev(th, t);
      if (footer_slot) {
        footer_slot.m(th, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_24(ctx2);
          if_block.c();
          if_block.m(th, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(footer_slot_template, ctx2[8], dirty, get_footer_slot_changes),
            get_footer_slot_context
          );
        }
      }
      set_attributes(th, th_data = get_spread_update(th_levels, [dirty & 128 && ctx2[7]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
      if (if_block)
        if_block.d();
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(17:15) ",
    ctx
  });
  return block;
}
function create_if_block10(ctx) {
  let col;
  const block = {
    c: function create() {
      col = element("col");
      set_style(col, "width", ctx[3]);
      add_location(col, file32, 15, 2, 348);
    },
    m: function mount(target, anchor) {
      insert_dev(target, col, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 8) {
        set_style(col, "width", ctx2[3]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(col);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(15:0) {#if colgroup}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[2]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4)
        set_data_dev(t, ctx2[2]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(24:4) {#if header}",
    ctx
  });
  return block;
}
function create_if_block_24(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_24.name,
    type: "if",
    source: "(19:4) {#if footer}",
    ctx
  });
  return block;
}
function create_fragment33(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block10, create_if_block_15, create_if_block_32, create_else_block8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[4])
      return 0;
    if (ctx2[6])
      return 1;
    if (ctx2[5])
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "footer", "header", "width"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Column", slots, ["footer", "header", "default"]);
  let { class: className = "" } = $$props;
  let { footer = void 0 } = $$props;
  let { header = void 0 } = $$props;
  let { width = void 0 } = $$props;
  const colgroup = getContext("colgroup");
  const head = getContext("header");
  const foot = getContext("footer");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(0, className = $$new_props.class);
    if ("footer" in $$new_props)
      $$invalidate(1, footer = $$new_props.footer);
    if ("header" in $$new_props)
      $$invalidate(2, header = $$new_props.header);
    if ("width" in $$new_props)
      $$invalidate(3, width = $$new_props.width);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    className,
    footer,
    header,
    width,
    colgroup,
    head,
    foot
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(0, className = $$new_props.className);
    if ("footer" in $$props)
      $$invalidate(1, footer = $$new_props.footer);
    if ("header" in $$props)
      $$invalidate(2, header = $$new_props.header);
    if ("width" in $$props)
      $$invalidate(3, width = $$new_props.width);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    className,
    footer,
    header,
    width,
    colgroup,
    head,
    foot,
    $$restProps,
    $$scope,
    slots
  ];
}
var Column = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, { class: 0, footer: 1, header: 2, width: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Column",
      options,
      id: create_fragment33.name
    });
  }
  get class() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get footer() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set footer(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Column_default = Column;

// node_modules/sveltestrap/src/Container.svelte
var file33 = "node_modules/sveltestrap/src/Container.svelte";
function create_fragment34(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  let div_levels = [ctx[1], { class: ctx[0] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file33, 23, 0, 542);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "sm", "md", "lg", "xl", "xxl", "fluid"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Container", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { sm = void 0 } = $$props;
  let { md = void 0 } = $$props;
  let { lg = void 0 } = $$props;
  let { xl = void 0 } = $$props;
  let { xxl = void 0 } = $$props;
  let { fluid = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("sm" in $$new_props)
      $$invalidate(3, sm = $$new_props.sm);
    if ("md" in $$new_props)
      $$invalidate(4, md = $$new_props.md);
    if ("lg" in $$new_props)
      $$invalidate(5, lg = $$new_props.lg);
    if ("xl" in $$new_props)
      $$invalidate(6, xl = $$new_props.xl);
    if ("xxl" in $$new_props)
      $$invalidate(7, xxl = $$new_props.xxl);
    if ("fluid" in $$new_props)
      $$invalidate(8, fluid = $$new_props.fluid);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    sm,
    md,
    lg,
    xl,
    xxl,
    fluid,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("sm" in $$props)
      $$invalidate(3, sm = $$new_props.sm);
    if ("md" in $$props)
      $$invalidate(4, md = $$new_props.md);
    if ("lg" in $$props)
      $$invalidate(5, lg = $$new_props.lg);
    if ("xl" in $$props)
      $$invalidate(6, xl = $$new_props.xl);
    if ("xxl" in $$props)
      $$invalidate(7, xxl = $$new_props.xxl);
    if ("fluid" in $$props)
      $$invalidate(8, fluid = $$new_props.fluid);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 508) {
      $:
        $$invalidate(0, classes = classnames(className, {
          "container-sm": sm,
          "container-md": md,
          "container-lg": lg,
          "container-xl": xl,
          "container-xxl": xxl,
          "container-fluid": fluid,
          container: !sm && !md && !lg && !xl && !xxl && !fluid
        }));
    }
  };
  return [classes, $$restProps, className, sm, md, lg, xl, xxl, fluid, $$scope, slots];
}
var Container = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, {
      class: 2,
      sm: 3,
      md: 4,
      lg: 5,
      xl: 6,
      xxl: 7,
      fluid: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Container",
      options,
      id: create_fragment34.name
    });
  }
  get class() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sm() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sm(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get md() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set md(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lg() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lg(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xl() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xl(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xxl() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xxl(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fluid() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fluid(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Container_default = Container;

// node_modules/sveltestrap/src/DropdownItem.svelte
var file34 = "node_modules/sveltestrap/src/DropdownItem.svelte";
function create_else_block9(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  let button_levels = [{ type: "button" }, ctx[6], { class: ctx[3] }];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      set_attributes(button, button_data);
      add_location(button, file34, 49, 2, 1155);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", ctx[15], false, false, false),
          listen_dev(button, "click", ctx[5], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        dirty & 64 && ctx2[6],
        (!current || dirty & 8) && { class: ctx2[3] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block9.name,
    type: "else",
    source: "(49:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_25(ctx) {
  let a;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  let a_levels = [
    ctx[6],
    { click: "" },
    { href: ctx[2] },
    { class: ctx[3] }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
      add_location(a, file34, 45, 2, 1048);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(a, "click", ctx[5], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & 64 && ctx2[6],
        { click: "" },
        (!current || dirty & 4) && { href: ctx2[2] },
        (!current || dirty & 8) && { class: ctx2[3] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_25.name,
    type: "if",
    source: "(45:15) ",
    ctx
  });
  return block;
}
function create_if_block_16(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  let div_levels = [ctx[6], { class: ctx[3] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file34, 41, 2, 933);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "click", ctx[14], false, false, false),
          listen_dev(div, "click", ctx[5], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 64 && ctx2[6],
        (!current || dirty & 8) && { class: ctx2[3] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(41:18) ",
    ctx
  });
  return block;
}
function create_if_block11(ctx) {
  let h6;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  let h6_levels = [ctx[6], { class: ctx[3] }];
  let h6_data = {};
  for (let i = 0; i < h6_levels.length; i += 1) {
    h6_data = assign(h6_data, h6_levels[i]);
  }
  const block = {
    c: function create() {
      h6 = element("h6");
      if (default_slot)
        default_slot.c();
      set_attributes(h6, h6_data);
      add_location(h6, file34, 37, 2, 817);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h6, anchor);
      if (default_slot) {
        default_slot.m(h6, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(h6, "click", ctx[13], false, false, false),
          listen_dev(h6, "click", ctx[5], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null),
            null
          );
        }
      }
      set_attributes(h6, h6_data = get_spread_update(h6_levels, [
        dirty & 64 && ctx2[6],
        (!current || dirty & 8) && { class: ctx2[3] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h6);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(37:0) {#if header}",
    ctx
  });
  return block;
}
function create_fragment35(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block11, create_if_block_16, create_if_block_25, create_else_block9];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    if (ctx2[0])
      return 1;
    if (ctx2[2])
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "active", "disabled", "divider", "header", "toggle", "href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $context;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownItem", slots, ["default"]);
  const context = getContext("dropdownContext");
  validate_store(context, "context");
  component_subscribe($$self, context, (value) => $$invalidate(16, $context = value));
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { disabled = false } = $$props;
  let { divider = false } = $$props;
  let { header = false } = $$props;
  let { toggle = true } = $$props;
  let { href = "" } = $$props;
  function handleItemClick(e) {
    if (disabled || header || divider) {
      e.preventDefault();
      return;
    }
    if (toggle && ($context.autoClose === true || $context.autoClose === "outside")) {
      $context.toggle(e);
    }
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(7, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(8, active = $$new_props.active);
    if ("disabled" in $$new_props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("divider" in $$new_props)
      $$invalidate(0, divider = $$new_props.divider);
    if ("header" in $$new_props)
      $$invalidate(1, header = $$new_props.header);
    if ("toggle" in $$new_props)
      $$invalidate(10, toggle = $$new_props.toggle);
    if ("href" in $$new_props)
      $$invalidate(2, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    classnames,
    context,
    className,
    active,
    disabled,
    divider,
    header,
    toggle,
    href,
    handleItemClick,
    classes,
    $context
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(7, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(8, active = $$new_props.active);
    if ("disabled" in $$props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("divider" in $$props)
      $$invalidate(0, divider = $$new_props.divider);
    if ("header" in $$props)
      $$invalidate(1, header = $$new_props.header);
    if ("toggle" in $$props)
      $$invalidate(10, toggle = $$new_props.toggle);
    if ("href" in $$props)
      $$invalidate(2, href = $$new_props.href);
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 899) {
      $:
        $$invalidate(3, classes = classnames(className, {
          disabled,
          "dropdown-item": !divider && !header,
          active,
          "dropdown-header": header,
          "dropdown-divider": divider
        }));
    }
  };
  return [
    divider,
    header,
    href,
    classes,
    context,
    handleItemClick,
    $$restProps,
    className,
    active,
    disabled,
    toggle,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
var DropdownItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, {
      class: 7,
      active: 8,
      disabled: 9,
      divider: 0,
      header: 1,
      toggle: 10,
      href: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownItem",
      options,
      id: create_fragment35.name
    });
  }
  get class() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get divider() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set divider(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<DropdownItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<DropdownItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownItem_default = DropdownItem;

// node_modules/sveltestrap/src/DropdownMenu.svelte
var file35 = "node_modules/sveltestrap/src/DropdownMenu.svelte";
function create_fragment36(ctx) {
  let div;
  let div_data_bs_popper_value;
  let $context_popperContent_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  let div_levels = [
    ctx[4],
    { class: ctx[1] },
    {
      "data-bs-popper": div_data_bs_popper_value = ctx[0].inNavbar ? "static" : void 0
    }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file35, 41, 0, 933);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer($context_popperContent_action = ctx[0].popperContent(div, ctx[2]));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 16 && ctx2[4],
        (!current || dirty & 2) && { class: ctx2[1] },
        (!current || dirty & 1 && div_data_bs_popper_value !== (div_data_bs_popper_value = ctx2[0].inNavbar ? "static" : void 0)) && {
          "data-bs-popper": div_data_bs_popper_value
        }
      ]));
      if ($context_popperContent_action && is_function($context_popperContent_action.update) && dirty & 4)
        $context_popperContent_action.update.call(null, ctx2[2]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  let popperOptions;
  let classes;
  const omit_props_names = ["class", "dark", "end", "right"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $context;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownMenu", slots, ["default"]);
  const context = getContext("dropdownContext");
  validate_store(context, "context");
  component_subscribe($$self, context, (value) => $$invalidate(0, $context = value));
  let { class: className = "" } = $$props;
  let { dark = false } = $$props;
  let { end: end2 = false } = $$props;
  let { right: right2 = false } = $$props;
  const popperPlacement = (direction, end3) => {
    let prefix = direction;
    if (direction === "up")
      prefix = "top";
    else if (direction === "down")
      prefix = "bottom";
    let suffix = end3 ? "end" : "start";
    return `${prefix}-${suffix}`;
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("dark" in $$new_props)
      $$invalidate(6, dark = $$new_props.dark);
    if ("end" in $$new_props)
      $$invalidate(7, end2 = $$new_props.end);
    if ("right" in $$new_props)
      $$invalidate(8, right2 = $$new_props.right);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    classnames,
    context,
    className,
    dark,
    end: end2,
    right: right2,
    popperPlacement,
    classes,
    popperOptions,
    $context
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("dark" in $$props)
      $$invalidate(6, dark = $$new_props.dark);
    if ("end" in $$props)
      $$invalidate(7, end2 = $$new_props.end);
    if ("right" in $$props)
      $$invalidate(8, right2 = $$new_props.right);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
    if ("popperOptions" in $$props)
      $$invalidate(2, popperOptions = $$new_props.popperOptions);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 385) {
      $:
        $$invalidate(2, popperOptions = {
          modifiers: [
            { name: "flip" },
            {
              name: "offset",
              options: { offset: [0, 2] }
            }
          ],
          placement: popperPlacement($context.direction, end2 || right2)
        });
    }
    if ($$self.$$.dirty & 481) {
      $:
        $$invalidate(1, classes = classnames(className, "dropdown-menu", {
          "dropdown-menu-dark": dark,
          "dropdown-menu-end": end2 || right2,
          show: $context.isOpen
        }));
    }
  };
  return [
    $context,
    classes,
    popperOptions,
    context,
    $$restProps,
    className,
    dark,
    end2,
    right2,
    $$scope,
    slots
  ];
}
var DropdownMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment36, safe_not_equal, { class: 5, dark: 6, end: 7, right: 8 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownMenu",
      options,
      id: create_fragment36.name
    });
  }
  get class() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dark() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dark(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get end() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set end(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get right() {
    throw new Error("<DropdownMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set right(value) {
    throw new Error("<DropdownMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownMenu_default = DropdownMenu;

// node_modules/sveltestrap/src/DropdownToggle.svelte
var file36 = "node_modules/sveltestrap/src/DropdownToggle.svelte";
function create_else_block10(ctx) {
  let button;
  let button_aria_expanded_value;
  let $context_popperRef_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[20].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[19], null);
  const default_slot_or_fallback = default_slot || fallback_block_3(ctx);
  let button_levels = [
    ctx[9],
    { type: "button" },
    {
      "aria-expanded": button_aria_expanded_value = ctx[6].isOpen
    },
    { class: ctx[5] }
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block_1 = {
    c: function create() {
      button = element("button");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      set_attributes(button, button_data);
      add_location(button, file36, 94, 2, 1948);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      ctx[28](button);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer($context_popperRef_action = ctx[6].popperRef(button)),
          listen_dev(button, "click", ctx[24], false, false, false),
          listen_dev(button, "click", ctx[8], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[19],
            !current ? get_all_dirty_from_scope(ctx2[19]) : get_slot_changes(default_slot_template, ctx2[19], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & 512 && ctx2[9],
        { type: "button" },
        (!current || dirty & 64 && button_aria_expanded_value !== (button_aria_expanded_value = ctx2[6].isOpen)) && {
          "aria-expanded": button_aria_expanded_value
        },
        (!current || dirty & 32) && { class: ctx2[5] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[28](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_else_block10.name,
    type: "else",
    source: "(94:0) {:else}",
    ctx
  });
  return block_1;
}
function create_if_block_26(ctx) {
  let span;
  let span_aria_expanded_value;
  let $context_popperRef_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[20].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[19], null);
  const default_slot_or_fallback = default_slot || fallback_block_2(ctx);
  let span_levels = [
    ctx[9],
    {
      "aria-expanded": span_aria_expanded_value = ctx[6].isOpen
    },
    { class: ctx[4] }
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block_1 = {
    c: function create() {
      span = element("span");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      set_attributes(span, span_data);
      add_location(span, file36, 80, 2, 1673);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(span, null);
      }
      ctx[27](span);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer($context_popperRef_action = ctx[6].popperRef(span)),
          listen_dev(span, "click", ctx[23], false, false, false),
          listen_dev(span, "click", ctx[8], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[19],
            !current ? get_all_dirty_from_scope(ctx2[19]) : get_slot_changes(default_slot_template, ctx2[19], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & 512 && ctx2[9],
        (!current || dirty & 64 && span_aria_expanded_value !== (span_aria_expanded_value = ctx2[6].isOpen)) && {
          "aria-expanded": span_aria_expanded_value
        },
        (!current || dirty & 16) && { class: ctx2[4] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[27](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_26.name,
    type: "if",
    source: "(80:25) ",
    ctx
  });
  return block_1;
}
function create_if_block_17(ctx) {
  let div;
  let div_aria_expanded_value;
  let $context_popperRef_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[20].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[19], null);
  const default_slot_or_fallback = default_slot || fallback_block_1(ctx);
  let div_levels = [
    ctx[9],
    {
      "aria-expanded": div_aria_expanded_value = ctx[6].isOpen
    },
    { class: ctx[4] }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block_1 = {
    c: function create() {
      div = element("div");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      set_attributes(div, div_data);
      add_location(div, file36, 66, 2, 1382);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div, null);
      }
      ctx[26](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer($context_popperRef_action = ctx[6].popperRef(div)),
          listen_dev(div, "click", ctx[22], false, false, false),
          listen_dev(div, "click", ctx[8], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[19],
            !current ? get_all_dirty_from_scope(ctx2[19]) : get_slot_changes(default_slot_template, ctx2[19], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 512 && ctx2[9],
        (!current || dirty & 64 && div_aria_expanded_value !== (div_aria_expanded_value = ctx2[6].isOpen)) && { "aria-expanded": div_aria_expanded_value },
        (!current || dirty & 16) && { class: ctx2[4] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[26](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_17.name,
    type: "if",
    source: "(66:24) ",
    ctx
  });
  return block_1;
}
function create_if_block12(ctx) {
  let a;
  let a_aria_expanded_value;
  let $context_popperRef_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[20].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[19], null);
  const default_slot_or_fallback = default_slot || fallback_block2(ctx);
  let a_levels = [
    ctx[9],
    { href: "#nav" },
    {
      "aria-expanded": a_aria_expanded_value = ctx[6].isOpen
    },
    { class: ctx[4] }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block_1 = {
    c: function create() {
      a = element("a");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      set_attributes(a, a_data);
      add_location(a, file36, 51, 2, 1080);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(a, null);
      }
      ctx[25](a);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer($context_popperRef_action = ctx[6].popperRef(a)),
          listen_dev(a, "click", ctx[21], false, false, false),
          listen_dev(a, "click", ctx[8], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[19],
            !current ? get_all_dirty_from_scope(ctx2[19]) : get_slot_changes(default_slot_template, ctx2[19], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 2)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & 512 && ctx2[9],
        { href: "#nav" },
        (!current || dirty & 64 && a_aria_expanded_value !== (a_aria_expanded_value = ctx2[6].isOpen)) && { "aria-expanded": a_aria_expanded_value },
        (!current || dirty & 16) && { class: ctx2[4] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx[25](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block12.name,
    type: "if",
    source: "(51:0) {#if nav}",
    ctx
  });
  return block_1;
}
function fallback_block_3(ctx) {
  let span;
  let t;
  const block_1 = {
    c: function create() {
      span = element("span");
      t = text(ctx[1]);
      attr_dev(span, "class", "visually-hidden");
      add_location(span, file36, 105, 6, 2165);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: fallback_block_3.name,
    type: "fallback",
    source: "(105:10)        ",
    ctx
  });
  return block_1;
}
function fallback_block_2(ctx) {
  let span;
  let t;
  const block_1 = {
    c: function create() {
      span = element("span");
      t = text(ctx[1]);
      attr_dev(span, "class", "visually-hidden");
      add_location(span, file36, 90, 6, 1867);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: fallback_block_2.name,
    type: "fallback",
    source: "(90:10)        ",
    ctx
  });
  return block_1;
}
function fallback_block_1(ctx) {
  let span;
  let t;
  const block_1 = {
    c: function create() {
      span = element("span");
      t = text(ctx[1]);
      attr_dev(span, "class", "visually-hidden");
      add_location(span, file36, 76, 6, 1575);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(76:10)        ",
    ctx
  });
  return block_1;
}
function fallback_block2(ctx) {
  let span;
  let t;
  const block_1 = {
    c: function create() {
      span = element("span");
      t = text(ctx[1]);
      attr_dev(span, "class", "visually-hidden");
      add_location(span, file36, 62, 6, 1287);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: fallback_block2.name,
    type: "fallback",
    source: "(62:10)        ",
    ctx
  });
  return block_1;
}
function create_fragment37(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block12, create_if_block_17, create_if_block_26, create_else_block10];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    if (ctx2[3] === "div")
      return 1;
    if (ctx2[3] === "span")
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block_1 = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block_1;
}
function instance37($$self, $$props, $$invalidate) {
  let classes;
  let btnClasses;
  const omit_props_names = [
    "class",
    "ariaLabel",
    "active",
    "block",
    "caret",
    "color",
    "disabled",
    "inner",
    "nav",
    "outline",
    "size",
    "split",
    "tag"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $context;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DropdownToggle", slots, ["default"]);
  const context = getContext("dropdownContext");
  validate_store(context, "context");
  component_subscribe($$self, context, (value) => $$invalidate(6, $context = value));
  let { class: className = "" } = $$props;
  let { ariaLabel = "Toggle Dropdown" } = $$props;
  let { active = false } = $$props;
  let { block = false } = $$props;
  let { caret = false } = $$props;
  let { color = "secondary" } = $$props;
  let { disabled = false } = $$props;
  let { inner = void 0 } = $$props;
  let { nav = false } = $$props;
  let { outline = false } = $$props;
  let { size = "" } = $$props;
  let { split = false } = $$props;
  let { tag = null } = $$props;
  function toggleButton(e) {
    if (disabled) {
      e.preventDefault();
      return;
    }
    if (nav) {
      e.preventDefault();
    }
    $context.toggle(e);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(10, className = $$new_props.class);
    if ("ariaLabel" in $$new_props)
      $$invalidate(1, ariaLabel = $$new_props.ariaLabel);
    if ("active" in $$new_props)
      $$invalidate(11, active = $$new_props.active);
    if ("block" in $$new_props)
      $$invalidate(12, block = $$new_props.block);
    if ("caret" in $$new_props)
      $$invalidate(13, caret = $$new_props.caret);
    if ("color" in $$new_props)
      $$invalidate(14, color = $$new_props.color);
    if ("disabled" in $$new_props)
      $$invalidate(15, disabled = $$new_props.disabled);
    if ("inner" in $$new_props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("nav" in $$new_props)
      $$invalidate(2, nav = $$new_props.nav);
    if ("outline" in $$new_props)
      $$invalidate(16, outline = $$new_props.outline);
    if ("size" in $$new_props)
      $$invalidate(17, size = $$new_props.size);
    if ("split" in $$new_props)
      $$invalidate(18, split = $$new_props.split);
    if ("tag" in $$new_props)
      $$invalidate(3, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    classnames,
    context,
    className,
    ariaLabel,
    active,
    block,
    caret,
    color,
    disabled,
    inner,
    nav,
    outline,
    size,
    split,
    tag,
    toggleButton,
    classes,
    btnClasses,
    $context
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(10, className = $$new_props.className);
    if ("ariaLabel" in $$props)
      $$invalidate(1, ariaLabel = $$new_props.ariaLabel);
    if ("active" in $$props)
      $$invalidate(11, active = $$new_props.active);
    if ("block" in $$props)
      $$invalidate(12, block = $$new_props.block);
    if ("caret" in $$props)
      $$invalidate(13, caret = $$new_props.caret);
    if ("color" in $$props)
      $$invalidate(14, color = $$new_props.color);
    if ("disabled" in $$props)
      $$invalidate(15, disabled = $$new_props.disabled);
    if ("inner" in $$props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("nav" in $$props)
      $$invalidate(2, nav = $$new_props.nav);
    if ("outline" in $$props)
      $$invalidate(16, outline = $$new_props.outline);
    if ("size" in $$props)
      $$invalidate(17, size = $$new_props.size);
    if ("split" in $$props)
      $$invalidate(18, split = $$new_props.split);
    if ("tag" in $$props)
      $$invalidate(3, tag = $$new_props.tag);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
    if ("btnClasses" in $$props)
      $$invalidate(5, btnClasses = $$new_props.btnClasses);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 271364) {
      $:
        $$invalidate(4, classes = classnames(className, {
          "dropdown-toggle": caret || split,
          "dropdown-toggle-split": split,
          "nav-link": nav
        }));
    }
    if ($$self.$$.dirty & 219152) {
      $:
        $$invalidate(5, btnClasses = classnames(classes, "btn", `btn${outline ? "-outline" : ""}-${color}`, size ? `btn-${size}` : false, block ? "d-block w-100" : false, { active }));
    }
  };
  return [
    inner,
    ariaLabel,
    nav,
    tag,
    classes,
    btnClasses,
    $context,
    context,
    toggleButton,
    $$restProps,
    className,
    active,
    block,
    caret,
    color,
    disabled,
    outline,
    size,
    split,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    a_binding,
    div_binding,
    span_binding,
    button_binding
  ];
}
var DropdownToggle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, {
      class: 10,
      ariaLabel: 1,
      active: 11,
      block: 12,
      caret: 13,
      color: 14,
      disabled: 15,
      inner: 0,
      nav: 2,
      outline: 16,
      size: 17,
      split: 18,
      tag: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DropdownToggle",
      options,
      id: create_fragment37.name
    });
  }
  get class() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get block() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set block(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caret() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caret(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inner() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inner(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nav() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nav(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outline() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outline(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get split() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set split(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<DropdownToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<DropdownToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DropdownToggle_default = DropdownToggle;

// node_modules/sveltestrap/src/Fade.svelte
var file37 = "node_modules/sveltestrap/src/Fade.svelte";
function create_if_block13(ctx) {
  let div;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  let div_levels = [ctx[6], { class: ctx[1] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file37, 23, 2, 628);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "introstart", ctx[10], false, false, false),
          listen_dev(div, "introend", ctx[11], false, false, false),
          listen_dev(div, "outrostart", ctx[12], false, false, false),
          listen_dev(div, "outroend", ctx[13], false, false, false),
          listen_dev(
            div,
            "introstart",
            function() {
              if (is_function(ctx[2]))
                ctx[2].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "introend",
            function() {
              if (is_function(ctx[3]))
                ctx[3].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outrostart",
            function() {
              if (is_function(ctx[4]))
                ctx[4].apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "outroend",
            function() {
              if (is_function(ctx[5]))
                ctx[5].apply(this, arguments);
            },
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[8],
            !current ? get_all_dirty_from_scope(ctx[8]) : get_slot_changes(default_slot_template, ctx[8], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 64 && ctx[6],
        (!current || dirty & 2) && { class: ctx[1] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, fade, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, fade, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(23:0) {#if isOpen}",
    ctx
  });
  return block;
}
function create_fragment38(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block13(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props, $$invalidate) {
  const omit_props_names = ["isOpen", "class", "onEntering", "onEntered", "onExiting", "onExited", "toggler"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fade", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { isOpen = false } = $$props;
  let { class: className = "" } = $$props;
  let { onEntering = () => dispatch("opening") } = $$props;
  let { onEntered = () => dispatch("open") } = $$props;
  let { onExiting = () => dispatch("closing") } = $$props;
  let { onExited = () => dispatch("close") } = $$props;
  let { toggler = null } = $$props;
  onMount(() => toggle_default(toggler, (e) => {
    $$invalidate(0, isOpen = !isOpen);
    e.preventDefault();
  }));
  function introstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function introend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outrostart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function outroend_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("onEntering" in $$new_props)
      $$invalidate(2, onEntering = $$new_props.onEntering);
    if ("onEntered" in $$new_props)
      $$invalidate(3, onEntered = $$new_props.onEntered);
    if ("onExiting" in $$new_props)
      $$invalidate(4, onExiting = $$new_props.onExiting);
    if ("onExited" in $$new_props)
      $$invalidate(5, onExited = $$new_props.onExited);
    if ("toggler" in $$new_props)
      $$invalidate(7, toggler = $$new_props.toggler);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    fade,
    toggle: toggle_default,
    dispatch,
    isOpen,
    className,
    onEntering,
    onEntered,
    onExiting,
    onExited,
    toggler
  });
  $$self.$inject_state = ($$new_props) => {
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("onEntering" in $$props)
      $$invalidate(2, onEntering = $$new_props.onEntering);
    if ("onEntered" in $$props)
      $$invalidate(3, onEntered = $$new_props.onEntered);
    if ("onExiting" in $$props)
      $$invalidate(4, onExiting = $$new_props.onExiting);
    if ("onExited" in $$props)
      $$invalidate(5, onExited = $$new_props.onExited);
    if ("toggler" in $$props)
      $$invalidate(7, toggler = $$new_props.toggler);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    isOpen,
    className,
    onEntering,
    onEntered,
    onExiting,
    onExited,
    $$restProps,
    toggler,
    $$scope,
    slots,
    introstart_handler,
    introend_handler,
    outrostart_handler,
    outroend_handler
  ];
}
var Fade = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, {
      isOpen: 0,
      class: 1,
      onEntering: 2,
      onEntered: 3,
      onExiting: 4,
      onExited: 5,
      toggler: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fade",
      options,
      id: create_fragment38.name
    });
  }
  get isOpen() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onEntering() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onEntering(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onEntered() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onEntered(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onExiting() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onExiting(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onExited() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onExited(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggler() {
    throw new Error("<Fade>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggler(value) {
    throw new Error("<Fade>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Fade_default = Fade;

// node_modules/sveltestrap/src/Figure.svelte
var file38 = "node_modules/sveltestrap/src/Figure.svelte";
var get_caption_slot_changes = (dirty) => ({});
var get_caption_slot_context = (ctx) => ({});
function create_if_block14(ctx) {
  let figcaption;
  let t;
  let current;
  const caption_slot_template = ctx[7].caption;
  const caption_slot = create_slot(caption_slot_template, ctx, ctx[6], get_caption_slot_context);
  const block = {
    c: function create() {
      figcaption = element("figcaption");
      t = text(ctx[1]);
      if (caption_slot)
        caption_slot.c();
      attr_dev(figcaption, "class", "figure-caption");
      add_location(figcaption, file38, 19, 4, 435);
    },
    m: function mount(target, anchor) {
      insert_dev(target, figcaption, anchor);
      append_dev(figcaption, t);
      if (caption_slot) {
        caption_slot.m(figcaption, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & 2)
        set_data_dev(t, ctx2[1]);
      if (caption_slot) {
        if (caption_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            caption_slot,
            caption_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(caption_slot_template, ctx2[6], dirty, get_caption_slot_changes),
            get_caption_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(caption_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(caption_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(figcaption);
      if (caption_slot)
        caption_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block14.name,
    type: "if",
    source: "(19:2) {#if caption || $$slots.caption}",
    ctx
  });
  return block;
}
function create_fragment39(ctx) {
  let img;
  let t0;
  let figure;
  let t1;
  let current;
  let img_levels = [{ alt: ctx[0] }, ctx[3], { class: ctx[2] }];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  let if_block = (ctx[1] || ctx[4].caption) && create_if_block14(ctx);
  let figure_levels = [{ class: ctx[2] }, ctx[3]];
  let figure_data = {};
  for (let i = 0; i < figure_levels.length; i += 1) {
    figure_data = assign(figure_data, figure_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      t0 = space();
      figure = element("figure");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block)
        if_block.c();
      set_attributes(img, img_data);
      add_location(img, file38, 14, 0, 295);
      set_attributes(figure, figure_data);
      add_location(figure, file38, 16, 0, 343);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, figure, anchor);
      if (default_slot) {
        default_slot.m(figure, null);
      }
      append_dev(figure, t1);
      if (if_block)
        if_block.m(figure, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(img, img_data = get_spread_update(img_levels, [
        (!current || dirty & 1) && { alt: ctx2[0] },
        dirty & 8 && ctx2[3],
        (!current || dirty & 4) && { class: ctx2[2] }
      ]));
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
      if (ctx2[1] || ctx2[4].caption) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 18) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block14(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(figure, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(figure, figure_data = get_spread_update(figure_levels, [
        (!current || dirty & 4) && { class: ctx2[2] },
        dirty & 8 && ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(figure);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "alt", "caption"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Figure", slots, ["default", "caption"]);
  const $$slots = compute_slots(slots);
  setContext("figure", true);
  let { class: className = "" } = $$props;
  let { alt = void 0 } = $$props;
  let { caption = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("alt" in $$new_props)
      $$invalidate(0, alt = $$new_props.alt);
    if ("caption" in $$new_props)
      $$invalidate(1, caption = $$new_props.caption);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    classnames,
    className,
    alt,
    caption,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("alt" in $$props)
      $$invalidate(0, alt = $$new_props.alt);
    if ("caption" in $$props)
      $$invalidate(1, caption = $$new_props.caption);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32) {
      $:
        $$invalidate(2, classes = classnames("figure", className));
    }
  };
  return [alt, caption, classes, $$restProps, $$slots, className, $$scope, slots];
}
var Figure = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, { class: 5, alt: 0, caption: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Figure",
      options,
      id: create_fragment39.name
    });
  }
  get class() {
    throw new Error("<Figure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Figure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<Figure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<Figure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caption() {
    throw new Error("<Figure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caption(value) {
    throw new Error("<Figure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Figure_default = Figure;

// node_modules/sveltestrap/src/Form.svelte
var file39 = "node_modules/sveltestrap/src/Form.svelte";
function create_fragment40(ctx) {
  let form;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let form_levels = [ctx[1], { class: ctx[0] }];
  let form_data = {};
  for (let i = 0; i < form_levels.length; i += 1) {
    form_data = assign(form_data, form_levels[i]);
  }
  const block = {
    c: function create() {
      form = element("form");
      if (default_slot)
        default_slot.c();
      set_attributes(form, form_data);
      add_location(form, file39, 14, 0, 277);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, form, anchor);
      if (default_slot) {
        default_slot.m(form, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(form, "submit", ctx[7], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
      set_attributes(form, form_data = get_spread_update(form_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(form);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "inline", "validated"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Form", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { inline = false } = $$props;
  let { validated = false } = $$props;
  function submit_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("inline" in $$new_props)
      $$invalidate(3, inline = $$new_props.inline);
    if ("validated" in $$new_props)
      $$invalidate(4, validated = $$new_props.validated);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    inline,
    validated,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("inline" in $$props)
      $$invalidate(3, inline = $$new_props.inline);
    if ("validated" in $$props)
      $$invalidate(4, validated = $$new_props.validated);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 28) {
      $:
        $$invalidate(0, classes = classnames(className, {
          "form-inline": inline,
          "was-validated": validated
        }));
    }
  };
  return [
    classes,
    $$restProps,
    className,
    inline,
    validated,
    $$scope,
    slots,
    submit_handler
  ];
}
var Form = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment40, safe_not_equal, { class: 2, inline: 3, validated: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Form",
      options,
      id: create_fragment40.name
    });
  }
  get class() {
    throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validated() {
    throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validated(value) {
    throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Form_default = Form;

// node_modules/sveltestrap/src/FormCheck.svelte
var file40 = "node_modules/sveltestrap/src/FormCheck.svelte";
var get_label_slot_changes = (dirty) => ({});
var get_label_slot_context = (ctx) => ({});
function create_else_block11(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[11],
    { class: ctx[9] },
    { id: ctx[8] },
    { type: "checkbox" },
    { disabled: ctx[3] },
    { name: ctx[5] },
    { __value: ctx[7] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file40, 68, 4, 1451);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      input.checked = ctx[0];
      ctx[39](input);
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[29], false, false, false),
          listen_dev(input, "change", ctx[30], false, false, false),
          listen_dev(input, "focus", ctx[31], false, false, false),
          listen_dev(input, "input", ctx[32], false, false, false),
          listen_dev(input, "change", ctx[38])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 2048 && ctx2[11],
        dirty[0] & 512 && { class: ctx2[9] },
        dirty[0] & 256 && { id: ctx2[8] },
        { type: "checkbox" },
        dirty[0] & 8 && { disabled: ctx2[3] },
        dirty[0] & 32 && { name: ctx2[5] },
        dirty[0] & 128 && { __value: ctx2[7] }
      ]));
      if (dirty[0] & 1) {
        input.checked = ctx2[0];
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[39](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block11.name,
    type: "else",
    source: "(68:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_27(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[11],
    { class: ctx[9] },
    { id: ctx[8] },
    { type: "checkbox" },
    { disabled: ctx[3] },
    { name: ctx[5] },
    { __value: ctx[7] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file40, 52, 4, 1187);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      input.checked = ctx[0];
      ctx[37](input);
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[25], false, false, false),
          listen_dev(input, "change", ctx[26], false, false, false),
          listen_dev(input, "focus", ctx[27], false, false, false),
          listen_dev(input, "input", ctx[28], false, false, false),
          listen_dev(input, "change", ctx[36])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 2048 && ctx2[11],
        dirty[0] & 512 && { class: ctx2[9] },
        dirty[0] & 256 && { id: ctx2[8] },
        { type: "checkbox" },
        dirty[0] & 8 && { disabled: ctx2[3] },
        dirty[0] & 32 && { name: ctx2[5] },
        dirty[0] & 128 && { __value: ctx2[7] }
      ]));
      if (dirty[0] & 1) {
        input.checked = ctx2[0];
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[37](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_27.name,
    type: "if",
    source: "(52:30) ",
    ctx
  });
  return block;
}
function create_if_block_18(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[11],
    { class: ctx[9] },
    { id: ctx[8] },
    { type: "radio" },
    { disabled: ctx[3] },
    { name: ctx[5] },
    { __value: ctx[7] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      ctx[34][0].push(input);
      add_location(input, file40, 36, 4, 907);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      input.checked = input.__value === ctx[1];
      ctx[35](input);
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[21], false, false, false),
          listen_dev(input, "change", ctx[22], false, false, false),
          listen_dev(input, "focus", ctx[23], false, false, false),
          listen_dev(input, "input", ctx[24], false, false, false),
          listen_dev(input, "change", ctx[33])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 2048 && ctx2[11],
        dirty[0] & 512 && { class: ctx2[9] },
        dirty[0] & 256 && { id: ctx2[8] },
        { type: "radio" },
        dirty[0] & 8 && { disabled: ctx2[3] },
        dirty[0] & 32 && { name: ctx2[5] },
        dirty[0] & 128 && { __value: ctx2[7] }
      ]));
      if (dirty[0] & 2) {
        input.checked = input.__value === ctx2[1];
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[34][0].splice(ctx[34][0].indexOf(input), 1);
      ctx[35](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_18.name,
    type: "if",
    source: "(36:2) {#if type === 'radio'}",
    ctx
  });
  return block;
}
function create_if_block15(ctx) {
  let label_1;
  let current;
  const label_slot_template = ctx[20].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[19], get_label_slot_context);
  const label_slot_or_fallback = label_slot || fallback_block3(ctx);
  const block = {
    c: function create() {
      label_1 = element("label");
      if (label_slot_or_fallback)
        label_slot_or_fallback.c();
      attr_dev(label_1, "class", "form-check-label");
      attr_dev(label_1, "for", ctx[8]);
      add_location(label_1, file40, 85, 4, 1727);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label_1, anchor);
      if (label_slot_or_fallback) {
        label_slot_or_fallback.m(label_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty[0] & 524288)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[19],
            !current ? get_all_dirty_from_scope(ctx2[19]) : get_slot_changes(label_slot_template, ctx2[19], dirty, get_label_slot_changes),
            get_label_slot_context
          );
        }
      } else {
        if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty[0] & 16)) {
          label_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 256) {
        attr_dev(label_1, "for", ctx2[8]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
      if (label_slot_or_fallback)
        label_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block15.name,
    type: "if",
    source: "(85:2) {#if label}",
    ctx
  });
  return block;
}
function fallback_block3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[4]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 16)
        set_data_dev(t, ctx2[4]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block3.name,
    type: "fallback",
    source: "(87:25) {label}",
    ctx
  });
  return block;
}
function create_fragment41(ctx) {
  let div;
  let t;
  let current;
  function select_block_type(ctx2, dirty) {
    if (ctx2[6] === "radio")
      return create_if_block_18;
    if (ctx2[6] === "switch")
      return create_if_block_27;
    return create_else_block11;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block0 = current_block_type(ctx);
  let if_block1 = ctx[4] && create_if_block15(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr_dev(div, "class", ctx[10]);
      add_location(div, file40, 34, 0, 856);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if_block0.m(div, null);
      append_dev(div, t);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div, t);
        }
      }
      if (ctx2[4]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block15(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & 1024) {
        attr_dev(div, "class", ctx2[10]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props, $$invalidate) {
  let classes;
  let inputClasses;
  let idFor;
  const omit_props_names = [
    "class",
    "checked",
    "disabled",
    "group",
    "id",
    "inline",
    "inner",
    "invalid",
    "label",
    "name",
    "reverse",
    "size",
    "type",
    "valid",
    "value"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormCheck", slots, ["label"]);
  let { class: className = "" } = $$props;
  let { checked = false } = $$props;
  let { disabled = false } = $$props;
  let { group = void 0 } = $$props;
  let { id = void 0 } = $$props;
  let { inline = false } = $$props;
  let { inner = void 0 } = $$props;
  let { invalid = false } = $$props;
  let { label = "" } = $$props;
  let { name = "" } = $$props;
  let { reverse = false } = $$props;
  let { size = "" } = $$props;
  let { type = "checkbox" } = $$props;
  let { valid = false } = $$props;
  let { value = void 0 } = $$props;
  const $$binding_groups = [[]];
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function input_change_handler() {
    group = this.__value;
    $$invalidate(1, group);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(2, inner);
    });
  }
  function input_change_handler_1() {
    checked = this.checked;
    $$invalidate(0, checked);
  }
  function input_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(2, inner);
    });
  }
  function input_change_handler_2() {
    checked = this.checked;
    $$invalidate(0, checked);
  }
  function input_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(2, inner);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(12, className = $$new_props.class);
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("group" in $$new_props)
      $$invalidate(1, group = $$new_props.group);
    if ("id" in $$new_props)
      $$invalidate(13, id = $$new_props.id);
    if ("inline" in $$new_props)
      $$invalidate(14, inline = $$new_props.inline);
    if ("inner" in $$new_props)
      $$invalidate(2, inner = $$new_props.inner);
    if ("invalid" in $$new_props)
      $$invalidate(15, invalid = $$new_props.invalid);
    if ("label" in $$new_props)
      $$invalidate(4, label = $$new_props.label);
    if ("name" in $$new_props)
      $$invalidate(5, name = $$new_props.name);
    if ("reverse" in $$new_props)
      $$invalidate(16, reverse = $$new_props.reverse);
    if ("size" in $$new_props)
      $$invalidate(17, size = $$new_props.size);
    if ("type" in $$new_props)
      $$invalidate(6, type = $$new_props.type);
    if ("valid" in $$new_props)
      $$invalidate(18, valid = $$new_props.valid);
    if ("value" in $$new_props)
      $$invalidate(7, value = $$new_props.value);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    checked,
    disabled,
    group,
    id,
    inline,
    inner,
    invalid,
    label,
    name,
    reverse,
    size,
    type,
    valid,
    value,
    idFor,
    inputClasses,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(12, className = $$new_props.className);
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("disabled" in $$props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("group" in $$props)
      $$invalidate(1, group = $$new_props.group);
    if ("id" in $$props)
      $$invalidate(13, id = $$new_props.id);
    if ("inline" in $$props)
      $$invalidate(14, inline = $$new_props.inline);
    if ("inner" in $$props)
      $$invalidate(2, inner = $$new_props.inner);
    if ("invalid" in $$props)
      $$invalidate(15, invalid = $$new_props.invalid);
    if ("label" in $$props)
      $$invalidate(4, label = $$new_props.label);
    if ("name" in $$props)
      $$invalidate(5, name = $$new_props.name);
    if ("reverse" in $$props)
      $$invalidate(16, reverse = $$new_props.reverse);
    if ("size" in $$props)
      $$invalidate(17, size = $$new_props.size);
    if ("type" in $$props)
      $$invalidate(6, type = $$new_props.type);
    if ("valid" in $$props)
      $$invalidate(18, valid = $$new_props.valid);
    if ("value" in $$props)
      $$invalidate(7, value = $$new_props.value);
    if ("idFor" in $$props)
      $$invalidate(8, idFor = $$new_props.idFor);
    if ("inputClasses" in $$props)
      $$invalidate(9, inputClasses = $$new_props.inputClasses);
    if ("classes" in $$props)
      $$invalidate(10, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 217152) {
      $:
        $$invalidate(10, classes = classnames(className, "form-check", {
          "form-check-reverse": reverse,
          "form-switch": type === "switch",
          "form-check-inline": inline,
          [`form-control-${size}`]: size
        }));
    }
    if ($$self.$$.dirty[0] & 294912) {
      $:
        $$invalidate(9, inputClasses = classnames("form-check-input", { "is-invalid": invalid, "is-valid": valid }));
    }
    if ($$self.$$.dirty[0] & 8208) {
      $:
        $$invalidate(8, idFor = id || label);
    }
  };
  return [
    checked,
    group,
    inner,
    disabled,
    label,
    name,
    type,
    value,
    idFor,
    inputClasses,
    classes,
    $$restProps,
    className,
    id,
    inline,
    invalid,
    reverse,
    size,
    valid,
    $$scope,
    slots,
    blur_handler,
    change_handler,
    focus_handler,
    input_handler,
    blur_handler_1,
    change_handler_1,
    focus_handler_1,
    input_handler_1,
    blur_handler_2,
    change_handler_2,
    focus_handler_2,
    input_handler_2,
    input_change_handler,
    $$binding_groups,
    input_binding,
    input_change_handler_1,
    input_binding_1,
    input_change_handler_2,
    input_binding_2
  ];
}
var FormCheck = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance41,
      create_fragment41,
      safe_not_equal,
      {
        class: 12,
        checked: 0,
        disabled: 3,
        group: 1,
        id: 13,
        inline: 14,
        inner: 2,
        invalid: 15,
        label: 4,
        name: 5,
        reverse: 16,
        size: 17,
        type: 6,
        valid: 18,
        value: 7
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormCheck",
      options,
      id: create_fragment41.name
    });
  }
  get class() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inner() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inner(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reverse() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reverse(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valid() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valid(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<FormCheck>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<FormCheck>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FormCheck_default = FormCheck;

// node_modules/sveltestrap/src/FormFeedback.svelte
var file41 = "node_modules/sveltestrap/src/FormFeedback.svelte";
function create_fragment42(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let div_levels = [ctx[1], { class: ctx[0] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file41, 19, 0, 368);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props, $$invalidate) {
  const omit_props_names = ["class", "valid", "tooltip"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormFeedback", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { valid = void 0 } = $$props;
  let { tooltip = false } = $$props;
  let classes;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("valid" in $$new_props)
      $$invalidate(3, valid = $$new_props.valid);
    if ("tooltip" in $$new_props)
      $$invalidate(4, tooltip = $$new_props.tooltip);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    valid,
    tooltip,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("valid" in $$props)
      $$invalidate(3, valid = $$new_props.valid);
    if ("tooltip" in $$props)
      $$invalidate(4, tooltip = $$new_props.tooltip);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 28) {
      $: {
        const validMode = tooltip ? "tooltip" : "feedback";
        $$invalidate(0, classes = classnames(className, valid ? `valid-${validMode}` : `invalid-${validMode}`));
      }
    }
  };
  return [classes, $$restProps, className, valid, tooltip, $$scope, slots];
}
var FormFeedback = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, { class: 2, valid: 3, tooltip: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormFeedback",
      options,
      id: create_fragment42.name
    });
  }
  get class() {
    throw new Error("<FormFeedback>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FormFeedback>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valid() {
    throw new Error("<FormFeedback>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valid(value) {
    throw new Error("<FormFeedback>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltip() {
    throw new Error("<FormFeedback>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltip(value) {
    throw new Error("<FormFeedback>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FormFeedback_default = FormFeedback;

// node_modules/sveltestrap/src/FormGroup.svelte
var file42 = "node_modules/sveltestrap/src/FormGroup.svelte";
var get_label_slot_changes_1 = (dirty) => ({});
var get_label_slot_context_1 = (ctx) => ({});
var get_label_slot_changes2 = (dirty) => ({});
var get_label_slot_context2 = (ctx) => ({});
function create_else_block12(ctx) {
  let div;
  let t;
  let current;
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  let if_block = (ctx[0] || ctx[4].label) && create_if_block_28(ctx);
  let div_levels = [ctx[3], { class: ctx[2] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      set_attributes(div, div_data);
      add_location(div, file42, 34, 2, 796);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_dev(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null),
            null
          );
        }
      }
      if (ctx2[0] || ctx2[4].label) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 17) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_28(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 8 && ctx2[3],
        (!current || dirty & 4) && { class: ctx2[2] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block12.name,
    type: "else",
    source: "(34:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block16(ctx) {
  let fieldset;
  let t;
  let current;
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  let if_block = (ctx[0] || ctx[4].label) && create_if_block_19(ctx);
  let fieldset_levels = [ctx[3], { class: ctx[2] }];
  let fieldset_data = {};
  for (let i = 0; i < fieldset_levels.length; i += 1) {
    fieldset_data = assign(fieldset_data, fieldset_levels[i]);
  }
  const block = {
    c: function create() {
      fieldset = element("fieldset");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      set_attributes(fieldset, fieldset_data);
      add_location(fieldset, file42, 23, 2, 534);
    },
    m: function mount(target, anchor) {
      insert_dev(target, fieldset, anchor);
      if (default_slot) {
        default_slot.m(fieldset, null);
      }
      append_dev(fieldset, t);
      if (if_block)
        if_block.m(fieldset, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null),
            null
          );
        }
      }
      if (ctx2[0] || ctx2[4].label) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 17) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_19(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(fieldset, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(fieldset, fieldset_data = get_spread_update(fieldset_levels, [
        dirty & 8 && ctx2[3],
        (!current || dirty & 4) && { class: ctx2[2] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(fieldset);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block16.name,
    type: "if",
    source: "(23:0) {#if tag === 'fieldset'}",
    ctx
  });
  return block;
}
function create_if_block_28(ctx) {
  let label_1;
  let t0;
  let t1;
  let current;
  const label_slot_template = ctx[12].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[11], get_label_slot_context_1);
  const block = {
    c: function create() {
      label_1 = element("label");
      t0 = text(ctx[0]);
      t1 = space();
      if (label_slot)
        label_slot.c();
      add_location(label_1, file42, 38, 6, 950);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label_1, anchor);
      append_dev(label_1, t0);
      append_dev(label_1, t1);
      if (label_slot) {
        label_slot.m(label_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & 1)
        set_data_dev(t0, ctx2[0]);
      if (label_slot) {
        if (label_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(label_slot_template, ctx2[11], dirty, get_label_slot_changes_1),
            get_label_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
      if (label_slot)
        label_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_28.name,
    type: "if",
    source: "(37:4) {#if label || $$slots.label}",
    ctx
  });
  return block;
}
function create_if_block_19(ctx) {
  let label_1;
  let t0;
  let t1;
  let current;
  const label_slot_template = ctx[12].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[11], get_label_slot_context2);
  const block = {
    c: function create() {
      label_1 = element("label");
      t0 = text(ctx[0]);
      t1 = space();
      if (label_slot)
        label_slot.c();
      add_location(label_1, file42, 27, 6, 693);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label_1, anchor);
      append_dev(label_1, t0);
      append_dev(label_1, t1);
      if (label_slot) {
        label_slot.m(label_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & 1)
        set_data_dev(t0, ctx2[0]);
      if (label_slot) {
        if (label_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(label_slot_template, ctx2[11], dirty, get_label_slot_changes2),
            get_label_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
      if (label_slot)
        label_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_19.name,
    type: "if",
    source: "(26:4) {#if label || $$slots.label}",
    ctx
  });
  return block;
}
function create_fragment43(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block16, create_else_block12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1] === "fieldset")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance43($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "check", "disabled", "floating", "inline", "label", "row", "tag"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormGroup", slots, ["default", "label"]);
  const $$slots = compute_slots(slots);
  let { class: className = "" } = $$props;
  let { check = false } = $$props;
  let { disabled = false } = $$props;
  let { floating = false } = $$props;
  let { inline = false } = $$props;
  let { label = "" } = $$props;
  let { row = false } = $$props;
  let { tag = null } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("check" in $$new_props)
      $$invalidate(6, check = $$new_props.check);
    if ("disabled" in $$new_props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("floating" in $$new_props)
      $$invalidate(8, floating = $$new_props.floating);
    if ("inline" in $$new_props)
      $$invalidate(9, inline = $$new_props.inline);
    if ("label" in $$new_props)
      $$invalidate(0, label = $$new_props.label);
    if ("row" in $$new_props)
      $$invalidate(10, row = $$new_props.row);
    if ("tag" in $$new_props)
      $$invalidate(1, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    check,
    disabled,
    floating,
    inline,
    label,
    row,
    tag,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("check" in $$props)
      $$invalidate(6, check = $$new_props.check);
    if ("disabled" in $$props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("floating" in $$props)
      $$invalidate(8, floating = $$new_props.floating);
    if ("inline" in $$props)
      $$invalidate(9, inline = $$new_props.inline);
    if ("label" in $$props)
      $$invalidate(0, label = $$new_props.label);
    if ("row" in $$props)
      $$invalidate(10, row = $$new_props.row);
    if ("tag" in $$props)
      $$invalidate(1, tag = $$new_props.tag);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2016) {
      $:
        $$invalidate(2, classes = classnames(className, "mb-3", {
          row,
          "form-check": check,
          "form-check-inline": check && inline,
          "form-floating": floating,
          disabled: check && disabled
        }));
    }
  };
  return [
    label,
    tag,
    classes,
    $$restProps,
    $$slots,
    className,
    check,
    disabled,
    floating,
    inline,
    row,
    $$scope,
    slots
  ];
}
var FormGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance43, create_fragment43, safe_not_equal, {
      class: 5,
      check: 6,
      disabled: 7,
      floating: 8,
      inline: 9,
      label: 0,
      row: 10,
      tag: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormGroup",
      options,
      id: create_fragment43.name
    });
  }
  get class() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get check() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set check(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get floating() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set floating(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get row() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set row(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FormGroup_default = FormGroup;

// node_modules/sveltestrap/src/FormText.svelte
var file43 = "node_modules/sveltestrap/src/FormText.svelte";
function create_fragment44(ctx) {
  let small;
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let small_levels = [ctx[1], { class: ctx[0] }];
  let small_data = {};
  for (let i = 0; i < small_levels.length; i += 1) {
    small_data = assign(small_data, small_levels[i]);
  }
  const block = {
    c: function create() {
      small = element("small");
      if (default_slot)
        default_slot.c();
      set_attributes(small, small_data);
      add_location(small, file43, 15, 0, 290);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, small, anchor);
      if (default_slot) {
        default_slot.m(small, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
      set_attributes(small, small_data = get_spread_update(small_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(small);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance44($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "inline", "color"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormText", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { inline = false } = $$props;
  let { color = "muted" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("inline" in $$new_props)
      $$invalidate(3, inline = $$new_props.inline);
    if ("color" in $$new_props)
      $$invalidate(4, color = $$new_props.color);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    inline,
    color,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("inline" in $$props)
      $$invalidate(3, inline = $$new_props.inline);
    if ("color" in $$props)
      $$invalidate(4, color = $$new_props.color);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 28) {
      $:
        $$invalidate(0, classes = classnames(className, !inline ? "form-text" : false, color ? `text-${color}` : false));
    }
  };
  return [classes, $$restProps, className, inline, color, $$scope, slots];
}
var FormText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance44, create_fragment44, safe_not_equal, { class: 2, inline: 3, color: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormText",
      options,
      id: create_fragment44.name
    });
  }
  get class() {
    throw new Error("<FormText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FormText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<FormText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<FormText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<FormText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<FormText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FormText_default = FormText;

// node_modules/sveltestrap/src/Icon.svelte
var file44 = "node_modules/sveltestrap/src/Icon.svelte";
function create_fragment45(ctx) {
  let i;
  let i_levels = [ctx[1], { class: ctx[0] }];
  let i_data = {};
  for (let i2 = 0; i2 < i_levels.length; i2 += 1) {
    i_data = assign(i_data, i_levels[i2]);
  }
  const block = {
    c: function create() {
      i = element("i");
      set_attributes(i, i_data);
      add_location(i, file44, 10, 0, 189);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, i, anchor);
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(i, i_data = get_spread_update(i_levels, [
        dirty & 2 && ctx2[1],
        dirty & 1 && { class: ctx2[0] }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(i);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance45($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "name"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Icon", slots, []);
  let { class: className = "" } = $$props;
  let { name = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("name" in $$new_props)
      $$invalidate(3, name = $$new_props.name);
  };
  $$self.$capture_state = () => ({ classnames, className, name, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("name" in $$props)
      $$invalidate(3, name = $$new_props.name);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12) {
      $:
        $$invalidate(0, classes = classnames(className, `bi-${name}`));
    }
  };
  return [classes, $$restProps, className, name];
}
var Icon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance45, create_fragment45, safe_not_equal, { class: 2, name: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Icon",
      options,
      id: create_fragment45.name
    });
  }
  get class() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Icon_default = Icon;

// node_modules/sveltestrap/src/Image.svelte
var file45 = "node_modules/sveltestrap/src/Image.svelte";
function create_fragment46(ctx) {
  let img;
  let img_levels = [{ alt: ctx[0] }, ctx[2], { class: ctx[1] }];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      set_attributes(img, img_data);
      add_location(img, file45, 18, 0, 412);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(img, img_data = get_spread_update(img_levels, [
        dirty & 1 && { alt: ctx2[0] },
        dirty & 4 && ctx2[2],
        dirty & 2 && { class: ctx2[1] }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance46($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "alt", "figure", "fluid", "thumbnail"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Image", slots, []);
  let { class: className = "" } = $$props;
  let { alt = void 0 } = $$props;
  let { figure = getContext("figure") } = $$props;
  let { fluid = false } = $$props;
  let { thumbnail = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("alt" in $$new_props)
      $$invalidate(0, alt = $$new_props.alt);
    if ("figure" in $$new_props)
      $$invalidate(4, figure = $$new_props.figure);
    if ("fluid" in $$new_props)
      $$invalidate(5, fluid = $$new_props.fluid);
    if ("thumbnail" in $$new_props)
      $$invalidate(6, thumbnail = $$new_props.thumbnail);
  };
  $$self.$capture_state = () => ({
    getContext,
    classnames,
    className,
    alt,
    figure,
    fluid,
    thumbnail,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("alt" in $$props)
      $$invalidate(0, alt = $$new_props.alt);
    if ("figure" in $$props)
      $$invalidate(4, figure = $$new_props.figure);
    if ("fluid" in $$props)
      $$invalidate(5, fluid = $$new_props.fluid);
    if ("thumbnail" in $$props)
      $$invalidate(6, thumbnail = $$new_props.thumbnail);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 120) {
      $:
        $$invalidate(1, classes = classnames(className, {
          "figure-img": figure,
          "img-fluid": fluid,
          "img-thumbnail": thumbnail
        }));
    }
  };
  return [alt, classes, $$restProps, className, figure, fluid, thumbnail];
}
var Image = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance46, create_fragment46, safe_not_equal, {
      class: 3,
      alt: 0,
      figure: 4,
      fluid: 5,
      thumbnail: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Image",
      options,
      id: create_fragment46.name
    });
  }
  get class() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get figure() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set figure(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fluid() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fluid(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get thumbnail() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set thumbnail(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Image_default = Image;

// node_modules/sveltestrap/src/InlineContainer.svelte
var file46 = "node_modules/sveltestrap/src/InlineContainer.svelte";
function create_fragment47(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      add_location(div, file46, 3, 0, 67);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[0],
            !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment47.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance47($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InlineContainer", slots, ["default"]);
  let x = "wtf svelte?";
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<InlineContainer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ x });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2)
      x = $$props2.x;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [$$scope, slots];
}
var InlineContainer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance47, create_fragment47, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InlineContainer",
      options,
      id: create_fragment47.name
    });
  }
};
var InlineContainer_default = InlineContainer;

// node_modules/sveltestrap/src/Input.svelte
var file47 = "node_modules/sveltestrap/src/Input.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[211] = list[i];
  return child_ctx;
}
function create_if_block_222(ctx) {
  let select;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[25].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[210], null);
  let select_levels = [
    ctx[22],
    { class: ctx[19] },
    { name: ctx[13] },
    { disabled: ctx[8] },
    { readonly: ctx[15] }
  ];
  let select_data = {};
  for (let i = 0; i < select_levels.length; i += 1) {
    select_data = assign(select_data, select_levels[i]);
  }
  const block = {
    c: function create() {
      select = element("select");
      if (default_slot)
        default_slot.c();
      set_attributes(select, select_data);
      if (ctx[6] === void 0)
        add_render_callback(() => ctx[208].call(select));
      add_location(select, file47, 492, 2, 9236);
    },
    m: function mount(target, anchor) {
      insert_dev(target, select, anchor);
      if (default_slot) {
        default_slot.m(select, null);
      }
      (select_data.multiple ? select_options : select_option)(select, select_data.value);
      if (select.autofocus)
        select.focus();
      select_option(select, ctx[6]);
      ctx[209](select);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(select, "blur", ctx[157], false, false, false),
          listen_dev(select, "change", ctx[158], false, false, false),
          listen_dev(select, "focus", ctx[159], false, false, false),
          listen_dev(select, "input", ctx[160], false, false, false),
          listen_dev(select, "change", ctx[208])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[6] & 16777216)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[210],
            !current ? get_all_dirty_from_scope(ctx2[210]) : get_slot_changes(default_slot_template, ctx2[210], dirty, null),
            null
          );
        }
      }
      set_attributes(select, select_data = get_spread_update(select_levels, [
        dirty[0] & 4194304 && ctx2[22],
        (!current || dirty[0] & 524288) && { class: ctx2[19] },
        (!current || dirty[0] & 8192) && { name: ctx2[13] },
        (!current || dirty[0] & 256) && { disabled: ctx2[8] },
        (!current || dirty[0] & 32768) && { readonly: ctx2[15] }
      ]));
      if (dirty[0] & 4759808 && "value" in select_data)
        (select_data.multiple ? select_options : select_option)(select, select_data.value);
      if (dirty[0] & 64) {
        select_option(select, ctx2[6]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(select);
      if (default_slot)
        default_slot.d(detaching);
      ctx[209](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_222.name,
    type: "if",
    source: "(492:40) ",
    ctx
  });
  return block;
}
function create_if_block_21(ctx) {
  let textarea;
  let mounted;
  let dispose;
  let textarea_levels = [
    ctx[22],
    { class: ctx[19] },
    { disabled: ctx[8] },
    { name: ctx[13] },
    { placeholder: ctx[14] },
    { readOnly: ctx[15] }
  ];
  let textarea_data = {};
  for (let i = 0; i < textarea_levels.length; i += 1) {
    textarea_data = assign(textarea_data, textarea_levels[i]);
  }
  const block = {
    c: function create() {
      textarea = element("textarea");
      set_attributes(textarea, textarea_data);
      add_location(textarea, file47, 474, 2, 8945);
    },
    m: function mount(target, anchor) {
      insert_dev(target, textarea, anchor);
      if (textarea.autofocus)
        textarea.focus();
      set_input_value(textarea, ctx[6]);
      ctx[207](textarea);
      if (!mounted) {
        dispose = [
          listen_dev(textarea, "blur", ctx[150], false, false, false),
          listen_dev(textarea, "change", ctx[151], false, false, false),
          listen_dev(textarea, "focus", ctx[152], false, false, false),
          listen_dev(textarea, "input", ctx[153], false, false, false),
          listen_dev(textarea, "keydown", ctx[154], false, false, false),
          listen_dev(textarea, "keypress", ctx[155], false, false, false),
          listen_dev(textarea, "keyup", ctx[156], false, false, false),
          listen_dev(textarea, "input", ctx[206])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
        dirty[0] & 4194304 && ctx2[22],
        dirty[0] & 524288 && { class: ctx2[19] },
        dirty[0] & 256 && { disabled: ctx2[8] },
        dirty[0] & 8192 && { name: ctx2[13] },
        dirty[0] & 16384 && { placeholder: ctx2[14] },
        dirty[0] & 32768 && { readOnly: ctx2[15] }
      ]));
      if (dirty[0] & 64) {
        set_input_value(textarea, ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(textarea);
      ctx[207](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_21.name,
    type: "if",
    source: "(474:29) ",
    ctx
  });
  return block;
}
function create_if_block_29(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block_33,
    create_if_block_42,
    create_if_block_5,
    create_if_block_6,
    create_if_block_7,
    create_if_block_8,
    create_if_block_9,
    create_if_block_10,
    create_if_block_11,
    create_if_block_122,
    create_if_block_132,
    create_if_block_142,
    create_if_block_152,
    create_if_block_162,
    create_if_block_172,
    create_if_block_182,
    create_if_block_192,
    create_if_block_20,
    create_else_block_13
  ];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[17] === "text")
      return 0;
    if (ctx2[17] === "password")
      return 1;
    if (ctx2[17] === "color")
      return 2;
    if (ctx2[17] === "email")
      return 3;
    if (ctx2[17] === "file")
      return 4;
    if (ctx2[17] === "checkbox" || ctx2[17] === "radio" || ctx2[17] === "switch")
      return 5;
    if (ctx2[17] === "url")
      return 6;
    if (ctx2[17] === "number")
      return 7;
    if (ctx2[17] === "date")
      return 8;
    if (ctx2[17] === "time")
      return 9;
    if (ctx2[17] === "datetime")
      return 10;
    if (ctx2[17] === "datetime-local")
      return 11;
    if (ctx2[17] === "month")
      return 12;
    if (ctx2[17] === "color")
      return 13;
    if (ctx2[17] === "range")
      return 14;
    if (ctx2[17] === "search")
      return 15;
    if (ctx2[17] === "tel")
      return 16;
    if (ctx2[17] === "week")
      return 17;
    return 18;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1, -1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_29.name,
    type: "if",
    source: "(94:0) {#if tag === 'input'}",
    ctx
  });
  return block;
}
function create_else_block_13(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[22],
    { type: ctx[17] },
    { readOnly: ctx[15] },
    { class: ctx[19] },
    { name: ctx[13] },
    { disabled: ctx[8] },
    { placeholder: ctx[14] },
    { value: ctx[6] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 455, 4, 8614);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      input.value = input_data.value;
      if (input.autofocus)
        input.focus();
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[145], false, false, false),
          listen_dev(input, "change", ctx[21], false, false, false),
          listen_dev(input, "focus", ctx[146], false, false, false),
          listen_dev(input, "input", ctx[21], false, false, false),
          listen_dev(input, "keydown", ctx[147], false, false, false),
          listen_dev(input, "keypress", ctx[148], false, false, false),
          listen_dev(input, "keyup", ctx[149], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 4194304 && ctx2[22],
        dirty[0] & 131072 && { type: ctx2[17] },
        dirty[0] & 32768 && { readOnly: ctx2[15] },
        dirty[0] & 524288 && { class: ctx2[19] },
        dirty[0] & 8192 && { name: ctx2[13] },
        dirty[0] & 256 && { disabled: ctx2[8] },
        dirty[0] & 16384 && { placeholder: ctx2[14] },
        dirty[0] & 64 && input.value !== ctx2[6] && { value: ctx2[6] }
      ]));
      if ("value" in input_data) {
        input.value = input_data.value;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_13.name,
    type: "else",
    source: "(455:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_20(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[22],
    { class: ctx[19] },
    { type: "week" },
    { disabled: ctx[8] },
    { name: ctx[13] },
    { placeholder: ctx[14] },
    { readOnly: ctx[15] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 436, 4, 8305);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(input, ctx[6]);
      ctx[205](input);
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[138], false, false, false),
          listen_dev(input, "change", ctx[139], false, false, false),
          listen_dev(input, "focus", ctx[140], false, false, false),
          listen_dev(input, "input", ctx[141], false, false, false),
          listen_dev(input, "keydown", ctx[142], false, false, false),
          listen_dev(input, "keypress", ctx[143], false, false, false),
          listen_dev(input, "keyup", ctx[144], false, false, false),
          listen_dev(input, "input", ctx[204])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 4194304 && ctx2[22],
        dirty[0] & 524288 && { class: ctx2[19] },
        { type: "week" },
        dirty[0] & 256 && { disabled: ctx2[8] },
        dirty[0] & 8192 && { name: ctx2[13] },
        dirty[0] & 16384 && { placeholder: ctx2[14] },
        dirty[0] & 32768 && { readOnly: ctx2[15] }
      ]));
      if (dirty[0] & 64) {
        set_input_value(input, ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[205](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_20.name,
    type: "if",
    source: "(436:28) ",
    ctx
  });
  return block;
}
function create_if_block_192(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[22],
    { class: ctx[19] },
    { type: "tel" },
    { disabled: ctx[8] },
    { name: ctx[13] },
    { placeholder: ctx[14] },
    { readOnly: ctx[15] },
    { size: ctx[1] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 416, 4, 7965);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(input, ctx[6]);
      ctx[203](input);
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[131], false, false, false),
          listen_dev(input, "change", ctx[132], false, false, false),
          listen_dev(input, "focus", ctx[133], false, false, false),
          listen_dev(input, "input", ctx[134], false, false, false),
          listen_dev(input, "keydown", ctx[135], false, false, false),
          listen_dev(input, "keypress", ctx[136], false, false, false),
          listen_dev(input, "keyup", ctx[137], false, false, false),
          listen_dev(input, "input", ctx[202])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 4194304 && ctx2[22],
        dirty[0] & 524288 && { class: ctx2[19] },
        { type: "tel" },
        dirty[0] & 256 && { disabled: ctx2[8] },
        dirty[0] & 8192 && { name: ctx2[13] },
        dirty[0] & 16384 && { placeholder: ctx2[14] },
        dirty[0] & 32768 && { readOnly: ctx2[15] },
        dirty[0] & 2 && { size: ctx2[1] }
      ]));
      if (dirty[0] & 64) {
        set_input_value(input, ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[203](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_192.name,
    type: "if",
    source: "(416:27) ",
    ctx
  });
  return block;
}
function create_if_block_182(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[22],
    { class: ctx[19] },
    { type: "search" },
    { disabled: ctx[8] },
    { name: ctx[13] },
    { placeholder: ctx[14] },
    { readOnly: ctx[15] },
    { size: ctx[1] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 396, 4, 7623);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(input, ctx[6]);
      ctx[201](input);
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[124], false, false, false),
          listen_dev(input, "change", ctx[125], false, false, false),
          listen_dev(input, "focus", ctx[126], false, false, false),
          listen_dev(input, "input", ctx[127], false, false, false),
          listen_dev(input, "keydown", ctx[128], false, false, false),
          listen_dev(input, "keypress", ctx[129], false, false, false),
          listen_dev(input, "keyup", ctx[130], false, false, false),
          listen_dev(input, "input", ctx[200])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 4194304 && ctx2[22],
        dirty[0] & 524288 && { class: ctx2[19] },
        { type: "search" },
        dirty[0] & 256 && { disabled: ctx2[8] },
        dirty[0] & 8192 && { name: ctx2[13] },
        dirty[0] & 16384 && { placeholder: ctx2[14] },
        dirty[0] & 32768 && { readOnly: ctx2[15] },
        dirty[0] & 2 && { size: ctx2[1] }
      ]));
      if (dirty[0] & 64) {
        set_input_value(input, ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[201](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_182.name,
    type: "if",
    source: "(396:30) ",
    ctx
  });
  return block;
}
function create_if_block_172(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[22],
    { type: "range" },
    { readOnly: ctx[15] },
    { class: ctx[19] },
    { name: ctx[13] },
    { disabled: ctx[8] },
    { placeholder: ctx[14] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 377, 4, 7292);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(input, ctx[6]);
      ctx[199](input);
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[117], false, false, false),
          listen_dev(input, "change", ctx[118], false, false, false),
          listen_dev(input, "focus", ctx[119], false, false, false),
          listen_dev(input, "input", ctx[120], false, false, false),
          listen_dev(input, "keydown", ctx[121], false, false, false),
          listen_dev(input, "keypress", ctx[122], false, false, false),
          listen_dev(input, "keyup", ctx[123], false, false, false),
          listen_dev(input, "change", ctx[198]),
          listen_dev(input, "input", ctx[198])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 4194304 && ctx2[22],
        { type: "range" },
        dirty[0] & 32768 && { readOnly: ctx2[15] },
        dirty[0] & 524288 && { class: ctx2[19] },
        dirty[0] & 8192 && { name: ctx2[13] },
        dirty[0] & 256 && { disabled: ctx2[8] },
        dirty[0] & 16384 && { placeholder: ctx2[14] }
      ]));
      if (dirty[0] & 64) {
        set_input_value(input, ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[199](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_172.name,
    type: "if",
    source: "(377:29) ",
    ctx
  });
  return block;
}
function create_if_block_162(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[22],
    { type: "color" },
    { readOnly: ctx[15] },
    { class: ctx[19] },
    { name: ctx[13] },
    { disabled: ctx[8] },
    { placeholder: ctx[14] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 358, 4, 6962);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(input, ctx[6]);
      ctx[197](input);
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[110], false, false, false),
          listen_dev(input, "change", ctx[111], false, false, false),
          listen_dev(input, "focus", ctx[112], false, false, false),
          listen_dev(input, "input", ctx[113], false, false, false),
          listen_dev(input, "keydown", ctx[114], false, false, false),
          listen_dev(input, "keypress", ctx[115], false, false, false),
          listen_dev(input, "keyup", ctx[116], false, false, false),
          listen_dev(input, "input", ctx[196])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 4194304 && ctx2[22],
        { type: "color" },
        dirty[0] & 32768 && { readOnly: ctx2[15] },
        dirty[0] & 524288 && { class: ctx2[19] },
        dirty[0] & 8192 && { name: ctx2[13] },
        dirty[0] & 256 && { disabled: ctx2[8] },
        dirty[0] & 16384 && { placeholder: ctx2[14] }
      ]));
      if (dirty[0] & 64) {
        set_input_value(input, ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[197](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_162.name,
    type: "if",
    source: "(358:29) ",
    ctx
  });
  return block;
}
function create_if_block_152(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[22],
    { class: ctx[19] },
    { type: "month" },
    { disabled: ctx[8] },
    { name: ctx[13] },
    { placeholder: ctx[14] },
    { readOnly: ctx[15] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 339, 4, 6632);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(input, ctx[6]);
      ctx[195](input);
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[103], false, false, false),
          listen_dev(input, "change", ctx[104], false, false, false),
          listen_dev(input, "focus", ctx[105], false, false, false),
          listen_dev(input, "input", ctx[106], false, false, false),
          listen_dev(input, "keydown", ctx[107], false, false, false),
          listen_dev(input, "keypress", ctx[108], false, false, false),
          listen_dev(input, "keyup", ctx[109], false, false, false),
          listen_dev(input, "input", ctx[194])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 4194304 && ctx2[22],
        dirty[0] & 524288 && { class: ctx2[19] },
        { type: "month" },
        dirty[0] & 256 && { disabled: ctx2[8] },
        dirty[0] & 8192 && { name: ctx2[13] },
        dirty[0] & 16384 && { placeholder: ctx2[14] },
        dirty[0] & 32768 && { readOnly: ctx2[15] }
      ]));
      if (dirty[0] & 64) {
        set_input_value(input, ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[195](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_152.name,
    type: "if",
    source: "(339:29) ",
    ctx
  });
  return block;
}
function create_if_block_142(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[22],
    { class: ctx[19] },
    { type: "datetime-local" },
    { disabled: ctx[8] },
    { name: ctx[13] },
    { placeholder: ctx[14] },
    { readOnly: ctx[15] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 320, 4, 6293);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(input, ctx[6]);
      ctx[193](input);
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[96], false, false, false),
          listen_dev(input, "change", ctx[97], false, false, false),
          listen_dev(input, "focus", ctx[98], false, false, false),
          listen_dev(input, "input", ctx[99], false, false, false),
          listen_dev(input, "keydown", ctx[100], false, false, false),
          listen_dev(input, "keypress", ctx[101], false, false, false),
          listen_dev(input, "keyup", ctx[102], false, false, false),
          listen_dev(input, "input", ctx[192])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 4194304 && ctx2[22],
        dirty[0] & 524288 && { class: ctx2[19] },
        { type: "datetime-local" },
        dirty[0] & 256 && { disabled: ctx2[8] },
        dirty[0] & 8192 && { name: ctx2[13] },
        dirty[0] & 16384 && { placeholder: ctx2[14] },
        dirty[0] & 32768 && { readOnly: ctx2[15] }
      ]));
      if (dirty[0] & 64) {
        set_input_value(input, ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[193](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_142.name,
    type: "if",
    source: "(320:38) ",
    ctx
  });
  return block;
}
function create_if_block_132(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[22],
    { type: "datetime" },
    { readOnly: ctx[15] },
    { class: ctx[19] },
    { name: ctx[13] },
    { disabled: ctx[8] },
    { placeholder: ctx[14] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 301, 4, 5951);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(input, ctx[6]);
      ctx[191](input);
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[89], false, false, false),
          listen_dev(input, "change", ctx[90], false, false, false),
          listen_dev(input, "focus", ctx[91], false, false, false),
          listen_dev(input, "input", ctx[92], false, false, false),
          listen_dev(input, "keydown", ctx[93], false, false, false),
          listen_dev(input, "keypress", ctx[94], false, false, false),
          listen_dev(input, "keyup", ctx[95], false, false, false),
          listen_dev(input, "input", ctx[190])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 4194304 && ctx2[22],
        { type: "datetime" },
        dirty[0] & 32768 && { readOnly: ctx2[15] },
        dirty[0] & 524288 && { class: ctx2[19] },
        dirty[0] & 8192 && { name: ctx2[13] },
        dirty[0] & 256 && { disabled: ctx2[8] },
        dirty[0] & 16384 && { placeholder: ctx2[14] }
      ]));
      if (dirty[0] & 64) {
        set_input_value(input, ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[191](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_132.name,
    type: "if",
    source: "(301:32) ",
    ctx
  });
  return block;
}
function create_if_block_122(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[22],
    { class: ctx[19] },
    { type: "time" },
    { disabled: ctx[8] },
    { name: ctx[13] },
    { placeholder: ctx[14] },
    { readOnly: ctx[15] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 282, 4, 5619);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(input, ctx[6]);
      ctx[189](input);
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[82], false, false, false),
          listen_dev(input, "change", ctx[83], false, false, false),
          listen_dev(input, "focus", ctx[84], false, false, false),
          listen_dev(input, "input", ctx[85], false, false, false),
          listen_dev(input, "keydown", ctx[86], false, false, false),
          listen_dev(input, "keypress", ctx[87], false, false, false),
          listen_dev(input, "keyup", ctx[88], false, false, false),
          listen_dev(input, "input", ctx[188])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 4194304 && ctx2[22],
        dirty[0] & 524288 && { class: ctx2[19] },
        { type: "time" },
        dirty[0] & 256 && { disabled: ctx2[8] },
        dirty[0] & 8192 && { name: ctx2[13] },
        dirty[0] & 16384 && { placeholder: ctx2[14] },
        dirty[0] & 32768 && { readOnly: ctx2[15] }
      ]));
      if (dirty[0] & 64) {
        set_input_value(input, ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[189](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_122.name,
    type: "if",
    source: "(282:28) ",
    ctx
  });
  return block;
}
function create_if_block_11(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[22],
    { class: ctx[19] },
    { type: "date" },
    { disabled: ctx[8] },
    { name: ctx[13] },
    { placeholder: ctx[14] },
    { readOnly: ctx[15] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 263, 4, 5291);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(input, ctx[6]);
      ctx[187](input);
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[75], false, false, false),
          listen_dev(input, "change", ctx[76], false, false, false),
          listen_dev(input, "focus", ctx[77], false, false, false),
          listen_dev(input, "input", ctx[78], false, false, false),
          listen_dev(input, "keydown", ctx[79], false, false, false),
          listen_dev(input, "keypress", ctx[80], false, false, false),
          listen_dev(input, "keyup", ctx[81], false, false, false),
          listen_dev(input, "input", ctx[186])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 4194304 && ctx2[22],
        dirty[0] & 524288 && { class: ctx2[19] },
        { type: "date" },
        dirty[0] & 256 && { disabled: ctx2[8] },
        dirty[0] & 8192 && { name: ctx2[13] },
        dirty[0] & 16384 && { placeholder: ctx2[14] },
        dirty[0] & 32768 && { readOnly: ctx2[15] }
      ]));
      if (dirty[0] & 64) {
        set_input_value(input, ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[187](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: "(263:28) ",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[22],
    { class: ctx[19] },
    { type: "number" },
    { readOnly: ctx[15] },
    { name: ctx[13] },
    { disabled: ctx[8] },
    { placeholder: ctx[14] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 244, 4, 4961);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(input, ctx[6]);
      ctx[185](input);
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[68], false, false, false),
          listen_dev(input, "change", ctx[69], false, false, false),
          listen_dev(input, "focus", ctx[70], false, false, false),
          listen_dev(input, "input", ctx[71], false, false, false),
          listen_dev(input, "keydown", ctx[72], false, false, false),
          listen_dev(input, "keypress", ctx[73], false, false, false),
          listen_dev(input, "keyup", ctx[74], false, false, false),
          listen_dev(input, "input", ctx[184])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 4194304 && ctx2[22],
        dirty[0] & 524288 && { class: ctx2[19] },
        { type: "number" },
        dirty[0] & 32768 && { readOnly: ctx2[15] },
        dirty[0] & 8192 && { name: ctx2[13] },
        dirty[0] & 256 && { disabled: ctx2[8] },
        dirty[0] & 16384 && { placeholder: ctx2[14] }
      ]));
      if (dirty[0] & 64 && to_number(input.value) !== ctx2[6]) {
        set_input_value(input, ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[185](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(244:30) ",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[22],
    { class: ctx[19] },
    { type: "url" },
    { disabled: ctx[8] },
    { name: ctx[13] },
    { placeholder: ctx[14] },
    { readOnly: ctx[15] },
    { size: ctx[1] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 224, 4, 4619);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(input, ctx[6]);
      ctx[183](input);
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[61], false, false, false),
          listen_dev(input, "change", ctx[62], false, false, false),
          listen_dev(input, "focus", ctx[63], false, false, false),
          listen_dev(input, "input", ctx[64], false, false, false),
          listen_dev(input, "keydown", ctx[65], false, false, false),
          listen_dev(input, "keypress", ctx[66], false, false, false),
          listen_dev(input, "keyup", ctx[67], false, false, false),
          listen_dev(input, "input", ctx[182])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 4194304 && ctx2[22],
        dirty[0] & 524288 && { class: ctx2[19] },
        { type: "url" },
        dirty[0] & 256 && { disabled: ctx2[8] },
        dirty[0] & 8192 && { name: ctx2[13] },
        dirty[0] & 16384 && { placeholder: ctx2[14] },
        dirty[0] & 32768 && { readOnly: ctx2[15] },
        dirty[0] & 2 && { size: ctx2[1] }
      ]));
      if (dirty[0] & 64) {
        set_input_value(input, ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[183](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(224:27) ",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let formcheck;
  let updating_checked;
  let updating_inner;
  let updating_group;
  let updating_value;
  let current;
  const formcheck_spread_levels = [
    ctx[22],
    { class: ctx[7] },
    { size: ctx[0] },
    { type: ctx[17] },
    { disabled: ctx[8] },
    { invalid: ctx[10] },
    { label: ctx[11] },
    { name: ctx[13] },
    { placeholder: ctx[14] },
    { reverse: ctx[16] },
    { readonly: ctx[15] },
    { valid: ctx[18] }
  ];
  function formcheck_checked_binding(value) {
    ctx[171](value);
  }
  function formcheck_inner_binding(value) {
    ctx[172](value);
  }
  function formcheck_group_binding(value) {
    ctx[173](value);
  }
  function formcheck_value_binding(value) {
    ctx[174](value);
  }
  let formcheck_props = {};
  for (let i = 0; i < formcheck_spread_levels.length; i += 1) {
    formcheck_props = assign(formcheck_props, formcheck_spread_levels[i]);
  }
  if (ctx[2] !== void 0) {
    formcheck_props.checked = ctx[2];
  }
  if (ctx[5] !== void 0) {
    formcheck_props.inner = ctx[5];
  }
  if (ctx[4] !== void 0) {
    formcheck_props.group = ctx[4];
  }
  if (ctx[6] !== void 0) {
    formcheck_props.value = ctx[6];
  }
  formcheck = new FormCheck_default({ props: formcheck_props, $$inline: true });
  binding_callbacks.push(() => bind(formcheck, "checked", formcheck_checked_binding, ctx[2]));
  binding_callbacks.push(() => bind(formcheck, "inner", formcheck_inner_binding, ctx[5]));
  binding_callbacks.push(() => bind(formcheck, "group", formcheck_group_binding, ctx[4]));
  binding_callbacks.push(() => bind(formcheck, "value", formcheck_value_binding, ctx[6]));
  formcheck.$on("blur", ctx[175]);
  formcheck.$on("change", ctx[176]);
  formcheck.$on("focus", ctx[177]);
  formcheck.$on("input", ctx[178]);
  formcheck.$on("keydown", ctx[179]);
  formcheck.$on("keypress", ctx[180]);
  formcheck.$on("keyup", ctx[181]);
  const block = {
    c: function create() {
      create_component(formcheck.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(formcheck, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const formcheck_changes = dirty[0] & 4713857 ? get_spread_update(formcheck_spread_levels, [
        dirty[0] & 4194304 && get_spread_object(ctx2[22]),
        dirty[0] & 128 && { class: ctx2[7] },
        dirty[0] & 1 && { size: ctx2[0] },
        dirty[0] & 131072 && { type: ctx2[17] },
        dirty[0] & 256 && { disabled: ctx2[8] },
        dirty[0] & 1024 && { invalid: ctx2[10] },
        dirty[0] & 2048 && { label: ctx2[11] },
        dirty[0] & 8192 && { name: ctx2[13] },
        dirty[0] & 16384 && { placeholder: ctx2[14] },
        dirty[0] & 65536 && { reverse: ctx2[16] },
        dirty[0] & 32768 && { readonly: ctx2[15] },
        dirty[0] & 262144 && { valid: ctx2[18] }
      ]) : {};
      if (!updating_checked && dirty[0] & 4) {
        updating_checked = true;
        formcheck_changes.checked = ctx2[2];
        add_flush_callback(() => updating_checked = false);
      }
      if (!updating_inner && dirty[0] & 32) {
        updating_inner = true;
        formcheck_changes.inner = ctx2[5];
        add_flush_callback(() => updating_inner = false);
      }
      if (!updating_group && dirty[0] & 16) {
        updating_group = true;
        formcheck_changes.group = ctx2[4];
        add_flush_callback(() => updating_group = false);
      }
      if (!updating_value && dirty[0] & 64) {
        updating_value = true;
        formcheck_changes.value = ctx2[6];
        add_flush_callback(() => updating_value = false);
      }
      formcheck.$set(formcheck_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(formcheck.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(formcheck.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(formcheck, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(198:73) ",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[22],
    { class: ctx[19] },
    { type: "file" },
    { disabled: ctx[8] },
    { invalid: ctx[10] },
    { multiple: ctx[12] },
    { name: ctx[13] },
    { placeholder: ctx[14] },
    { readOnly: ctx[15] },
    { valid: ctx[18] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 175, 4, 3745);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      ctx[170](input);
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[54], false, false, false),
          listen_dev(input, "change", ctx[55], false, false, false),
          listen_dev(input, "focus", ctx[56], false, false, false),
          listen_dev(input, "input", ctx[57], false, false, false),
          listen_dev(input, "keydown", ctx[58], false, false, false),
          listen_dev(input, "keypress", ctx[59], false, false, false),
          listen_dev(input, "keyup", ctx[60], false, false, false),
          listen_dev(input, "change", ctx[169])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 4194304 && ctx2[22],
        dirty[0] & 524288 && { class: ctx2[19] },
        { type: "file" },
        dirty[0] & 256 && { disabled: ctx2[8] },
        dirty[0] & 1024 && { invalid: ctx2[10] },
        dirty[0] & 4096 && { multiple: ctx2[12] },
        dirty[0] & 8192 && { name: ctx2[13] },
        dirty[0] & 16384 && { placeholder: ctx2[14] },
        dirty[0] & 32768 && { readOnly: ctx2[15] },
        dirty[0] & 262144 && { valid: ctx2[18] }
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[170](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(175:28) ",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[22],
    { class: ctx[19] },
    { type: "email" },
    { disabled: ctx[8] },
    { multiple: ctx[12] },
    { name: ctx[13] },
    { placeholder: ctx[14] },
    { readOnly: ctx[15] },
    { size: ctx[1] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 154, 4, 3386);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(input, ctx[6]);
      ctx[168](input);
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[47], false, false, false),
          listen_dev(input, "change", ctx[48], false, false, false),
          listen_dev(input, "focus", ctx[49], false, false, false),
          listen_dev(input, "input", ctx[50], false, false, false),
          listen_dev(input, "keydown", ctx[51], false, false, false),
          listen_dev(input, "keypress", ctx[52], false, false, false),
          listen_dev(input, "keyup", ctx[53], false, false, false),
          listen_dev(input, "input", ctx[167])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 4194304 && ctx2[22],
        dirty[0] & 524288 && { class: ctx2[19] },
        { type: "email" },
        dirty[0] & 256 && { disabled: ctx2[8] },
        dirty[0] & 4096 && { multiple: ctx2[12] },
        dirty[0] & 8192 && { name: ctx2[13] },
        dirty[0] & 16384 && { placeholder: ctx2[14] },
        dirty[0] & 32768 && { readOnly: ctx2[15] },
        dirty[0] & 2 && { size: ctx2[1] }
      ]));
      if (dirty[0] & 64 && input.value !== ctx2[6]) {
        set_input_value(input, ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[168](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(154:29) ",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[22],
    { class: ctx[19] },
    { type: "color" },
    { disabled: ctx[8] },
    { name: ctx[13] },
    { placeholder: ctx[14] },
    { readOnly: ctx[15] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 135, 4, 3056);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(input, ctx[6]);
      ctx[166](input);
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[40], false, false, false),
          listen_dev(input, "change", ctx[41], false, false, false),
          listen_dev(input, "focus", ctx[42], false, false, false),
          listen_dev(input, "input", ctx[43], false, false, false),
          listen_dev(input, "keydown", ctx[44], false, false, false),
          listen_dev(input, "keypress", ctx[45], false, false, false),
          listen_dev(input, "keyup", ctx[46], false, false, false),
          listen_dev(input, "input", ctx[165])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 4194304 && ctx2[22],
        dirty[0] & 524288 && { class: ctx2[19] },
        { type: "color" },
        dirty[0] & 256 && { disabled: ctx2[8] },
        dirty[0] & 8192 && { name: ctx2[13] },
        dirty[0] & 16384 && { placeholder: ctx2[14] },
        dirty[0] & 32768 && { readOnly: ctx2[15] }
      ]));
      if (dirty[0] & 64) {
        set_input_value(input, ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[166](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(135:29) ",
    ctx
  });
  return block;
}
function create_if_block_42(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[22],
    { class: ctx[19] },
    { type: "password" },
    { disabled: ctx[8] },
    { name: ctx[13] },
    { placeholder: ctx[14] },
    { readOnly: ctx[15] },
    { size: ctx[1] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 115, 4, 2710);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(input, ctx[6]);
      ctx[164](input);
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[33], false, false, false),
          listen_dev(input, "change", ctx[34], false, false, false),
          listen_dev(input, "focus", ctx[35], false, false, false),
          listen_dev(input, "input", ctx[36], false, false, false),
          listen_dev(input, "keydown", ctx[37], false, false, false),
          listen_dev(input, "keypress", ctx[38], false, false, false),
          listen_dev(input, "keyup", ctx[39], false, false, false),
          listen_dev(input, "input", ctx[163])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 4194304 && ctx2[22],
        dirty[0] & 524288 && { class: ctx2[19] },
        { type: "password" },
        dirty[0] & 256 && { disabled: ctx2[8] },
        dirty[0] & 8192 && { name: ctx2[13] },
        dirty[0] & 16384 && { placeholder: ctx2[14] },
        dirty[0] & 32768 && { readOnly: ctx2[15] },
        dirty[0] & 2 && { size: ctx2[1] }
      ]));
      if (dirty[0] & 64 && input.value !== ctx2[6]) {
        set_input_value(input, ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[164](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(115:32) ",
    ctx
  });
  return block;
}
function create_if_block_33(ctx) {
  let input;
  let mounted;
  let dispose;
  let input_levels = [
    ctx[22],
    { class: ctx[19] },
    { type: "text" },
    { disabled: ctx[8] },
    { name: ctx[13] },
    { placeholder: ctx[14] },
    { readOnly: ctx[15] },
    { size: ctx[1] }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      set_attributes(input, input_data);
      add_location(input, file47, 95, 4, 2365);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(input, ctx[6]);
      ctx[162](input);
      if (!mounted) {
        dispose = [
          listen_dev(input, "blur", ctx[26], false, false, false),
          listen_dev(input, "change", ctx[27], false, false, false),
          listen_dev(input, "focus", ctx[28], false, false, false),
          listen_dev(input, "input", ctx[29], false, false, false),
          listen_dev(input, "keydown", ctx[30], false, false, false),
          listen_dev(input, "keypress", ctx[31], false, false, false),
          listen_dev(input, "keyup", ctx[32], false, false, false),
          listen_dev(input, "input", ctx[161])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & 4194304 && ctx2[22],
        dirty[0] & 524288 && { class: ctx2[19] },
        { type: "text" },
        dirty[0] & 256 && { disabled: ctx2[8] },
        dirty[0] & 8192 && { name: ctx2[13] },
        dirty[0] & 16384 && { placeholder: ctx2[14] },
        dirty[0] & 32768 && { readOnly: ctx2[15] },
        dirty[0] & 2 && { size: ctx2[1] }
      ]));
      if (dirty[0] & 64 && input.value !== ctx2[6]) {
        set_input_value(input, ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[162](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_33.name,
    type: "if",
    source: "(95:2) {#if type === 'text'}",
    ctx
  });
  return block;
}
function create_if_block17(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_110, create_else_block13];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (dirty[0] & 512)
      show_if = null;
    if (show_if == null)
      show_if = !!Array.isArray(ctx2[9]);
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1, -1, -1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block17.name,
    type: "if",
    source: "(525:0) {#if feedback}",
    ctx
  });
  return block;
}
function create_else_block13(ctx) {
  let formfeedback;
  let current;
  formfeedback = new FormFeedback_default({
    props: {
      valid: ctx[18],
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(formfeedback.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(formfeedback, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const formfeedback_changes = {};
      if (dirty[0] & 262144)
        formfeedback_changes.valid = ctx2[18];
      if (dirty[0] & 512 | dirty[6] & 16777216) {
        formfeedback_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formfeedback.$set(formfeedback_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(formfeedback.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(formfeedback.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(formfeedback, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block13.name,
    type: "else",
    source: "(530:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_110(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[9];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 262656) {
        each_value = ctx2[9];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_110.name,
    type: "if",
    source: "(526:2) {#if Array.isArray(feedback)}",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[9]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 512)
        set_data_dev(t, ctx2[9]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: "(531:4) <FormFeedback {valid}>",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let t_value = ctx[211] + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 512 && t_value !== (t_value = ctx2[211] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(528:6) <FormFeedback {valid}>",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let formfeedback;
  let current;
  formfeedback = new FormFeedback_default({
    props: {
      valid: ctx[18],
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(formfeedback.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(formfeedback, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const formfeedback_changes = {};
      if (dirty[0] & 262144)
        formfeedback_changes.valid = ctx2[18];
      if (dirty[0] & 512 | dirty[6] & 16777216) {
        formfeedback_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formfeedback.$set(formfeedback_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(formfeedback.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(formfeedback.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(formfeedback, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(527:4) {#each feedback as msg}",
    ctx
  });
  return block;
}
function create_fragment48(ctx) {
  let current_block_type_index;
  let if_block0;
  let t;
  let if_block1_anchor;
  let current;
  const if_block_creators = [create_if_block_29, create_if_block_21, create_if_block_222];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[20] === "input")
      return 0;
    if (ctx2[20] === "textarea")
      return 1;
    if (ctx2[20] === "select" && !ctx2[12])
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, [-1, -1, -1, -1, -1, -1, -1]))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = ctx[9] && create_if_block17(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        } else {
          if_block0 = null;
        }
      }
      if (ctx2[9]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 512) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block17(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment48.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance48($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "class",
    "bsSize",
    "checked",
    "color",
    "disabled",
    "feedback",
    "files",
    "group",
    "inner",
    "invalid",
    "label",
    "multiple",
    "name",
    "placeholder",
    "plaintext",
    "readonly",
    "reverse",
    "size",
    "type",
    "valid",
    "value"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Input", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { bsSize = void 0 } = $$props;
  let { checked = false } = $$props;
  let { color = void 0 } = $$props;
  let { disabled = void 0 } = $$props;
  let { feedback = void 0 } = $$props;
  let { files = void 0 } = $$props;
  let { group = void 0 } = $$props;
  let { inner = void 0 } = $$props;
  let { invalid = false } = $$props;
  let { label = void 0 } = $$props;
  let { multiple = void 0 } = $$props;
  let { name = "" } = $$props;
  let { placeholder = "" } = $$props;
  let { plaintext = false } = $$props;
  let { readonly = void 0 } = $$props;
  let { reverse = false } = $$props;
  let { size = void 0 } = $$props;
  let { type = "text" } = $$props;
  let { valid = false } = $$props;
  let { value = "" } = $$props;
  let classes;
  let tag;
  const handleInput = (event) => {
    $$invalidate(6, value = event.target.value);
  };
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_3(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_4(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_6(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_7(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_8(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_8(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_8(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_8(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_8(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_8(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_8(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_9(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_9(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_9(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_9(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_9(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_9(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_9(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_10(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_10(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_10(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_10(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_10(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_10(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_10(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_11(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_11(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_11(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_11(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_11(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_11(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_11(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_12(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_12(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_12(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_12(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_12(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_12(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_12(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_13(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_13(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_13(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_13(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_13(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_13(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_13(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_14(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_14(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_14(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_14(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_14(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_14(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_14(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_15(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_15(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_15(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_15(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_15(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_15(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_15(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_16(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_16(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_16(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_16(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_16(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_16(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_16(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_17(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_17(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_17(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_17(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_17(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_17(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_17(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_18(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_18(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_18(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_18(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_18(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_19(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_18(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_19(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_18(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_19(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_19(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_19(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_20(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_19(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_20(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_19(event) {
    bubble.call(this, $$self, event);
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_1() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_2() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_3() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_3($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_change_handler() {
    files = this.files;
    value = this.value;
    $$invalidate(3, files);
    $$invalidate(6, value);
  }
  function input_binding_4($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function formcheck_checked_binding(value2) {
    checked = value2;
    $$invalidate(2, checked);
  }
  function formcheck_inner_binding(value2) {
    inner = value2;
    $$invalidate(5, inner);
  }
  function formcheck_group_binding(value2) {
    group = value2;
    $$invalidate(4, group);
  }
  function formcheck_value_binding(value$1) {
    value = value$1;
    $$invalidate(6, value);
  }
  function blur_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler_5(event) {
    bubble.call(this, $$self, event);
  }
  function input_input_handler_4() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_5($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_5() {
    value = to_number(this.value);
    $$invalidate(6, value);
  }
  function input_binding_6($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_6() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_7($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_7() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_8($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_8() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_9($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_9() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_10($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_10() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_11($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_11() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_12($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_change_input_handler() {
    value = to_number(this.value);
    $$invalidate(6, value);
  }
  function input_binding_13($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_12() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_14($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_13() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_15($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function input_input_handler_14() {
    value = this.value;
    $$invalidate(6, value);
  }
  function input_binding_16($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function textarea_input_handler() {
    value = this.value;
    $$invalidate(6, value);
  }
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  function select_change_handler() {
    value = select_value(this);
    $$invalidate(6, value);
  }
  function select_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(5, inner);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(22, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(7, className = $$new_props.class);
    if ("bsSize" in $$new_props)
      $$invalidate(0, bsSize = $$new_props.bsSize);
    if ("checked" in $$new_props)
      $$invalidate(2, checked = $$new_props.checked);
    if ("color" in $$new_props)
      $$invalidate(23, color = $$new_props.color);
    if ("disabled" in $$new_props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("feedback" in $$new_props)
      $$invalidate(9, feedback = $$new_props.feedback);
    if ("files" in $$new_props)
      $$invalidate(3, files = $$new_props.files);
    if ("group" in $$new_props)
      $$invalidate(4, group = $$new_props.group);
    if ("inner" in $$new_props)
      $$invalidate(5, inner = $$new_props.inner);
    if ("invalid" in $$new_props)
      $$invalidate(10, invalid = $$new_props.invalid);
    if ("label" in $$new_props)
      $$invalidate(11, label = $$new_props.label);
    if ("multiple" in $$new_props)
      $$invalidate(12, multiple = $$new_props.multiple);
    if ("name" in $$new_props)
      $$invalidate(13, name = $$new_props.name);
    if ("placeholder" in $$new_props)
      $$invalidate(14, placeholder = $$new_props.placeholder);
    if ("plaintext" in $$new_props)
      $$invalidate(24, plaintext = $$new_props.plaintext);
    if ("readonly" in $$new_props)
      $$invalidate(15, readonly = $$new_props.readonly);
    if ("reverse" in $$new_props)
      $$invalidate(16, reverse = $$new_props.reverse);
    if ("size" in $$new_props)
      $$invalidate(1, size = $$new_props.size);
    if ("type" in $$new_props)
      $$invalidate(17, type = $$new_props.type);
    if ("valid" in $$new_props)
      $$invalidate(18, valid = $$new_props.valid);
    if ("value" in $$new_props)
      $$invalidate(6, value = $$new_props.value);
    if ("$$scope" in $$new_props)
      $$invalidate(210, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    FormCheck: FormCheck_default,
    FormFeedback: FormFeedback_default,
    classnames,
    className,
    bsSize,
    checked,
    color,
    disabled,
    feedback,
    files,
    group,
    inner,
    invalid,
    label,
    multiple,
    name,
    placeholder,
    plaintext,
    readonly,
    reverse,
    size,
    type,
    valid,
    value,
    classes,
    tag,
    handleInput
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(7, className = $$new_props.className);
    if ("bsSize" in $$props)
      $$invalidate(0, bsSize = $$new_props.bsSize);
    if ("checked" in $$props)
      $$invalidate(2, checked = $$new_props.checked);
    if ("color" in $$props)
      $$invalidate(23, color = $$new_props.color);
    if ("disabled" in $$props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("feedback" in $$props)
      $$invalidate(9, feedback = $$new_props.feedback);
    if ("files" in $$props)
      $$invalidate(3, files = $$new_props.files);
    if ("group" in $$props)
      $$invalidate(4, group = $$new_props.group);
    if ("inner" in $$props)
      $$invalidate(5, inner = $$new_props.inner);
    if ("invalid" in $$props)
      $$invalidate(10, invalid = $$new_props.invalid);
    if ("label" in $$props)
      $$invalidate(11, label = $$new_props.label);
    if ("multiple" in $$props)
      $$invalidate(12, multiple = $$new_props.multiple);
    if ("name" in $$props)
      $$invalidate(13, name = $$new_props.name);
    if ("placeholder" in $$props)
      $$invalidate(14, placeholder = $$new_props.placeholder);
    if ("plaintext" in $$props)
      $$invalidate(24, plaintext = $$new_props.plaintext);
    if ("readonly" in $$props)
      $$invalidate(15, readonly = $$new_props.readonly);
    if ("reverse" in $$props)
      $$invalidate(16, reverse = $$new_props.reverse);
    if ("size" in $$props)
      $$invalidate(1, size = $$new_props.size);
    if ("type" in $$props)
      $$invalidate(17, type = $$new_props.type);
    if ("valid" in $$props)
      $$invalidate(18, valid = $$new_props.valid);
    if ("value" in $$props)
      $$invalidate(6, value = $$new_props.value);
    if ("classes" in $$props)
      $$invalidate(19, classes = $$new_props.classes);
    if ("tag" in $$props)
      $$invalidate(20, tag = $$new_props.tag);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 25560195) {
      $: {
        const isNotaNumber = new RegExp("\\D", "g");
        let isBtn = false;
        let formControlClass = "form-control";
        $$invalidate(20, tag = "input");
        switch (type) {
          case "color":
            formControlClass = `form-control form-control-color`;
            break;
          case "range":
            formControlClass = "form-range";
            break;
          case "select":
            formControlClass = `form-select`;
            $$invalidate(20, tag = "select");
            break;
          case "textarea":
            $$invalidate(20, tag = "textarea");
            break;
          case "button":
          case "reset":
          case "submit":
            formControlClass = `btn btn-${color || "secondary"}`;
            isBtn = true;
            break;
          case "hidden":
          case "image":
            formControlClass = void 0;
            break;
          default:
            formControlClass = "form-control";
            $$invalidate(20, tag = "input");
        }
        if (plaintext) {
          formControlClass = `${formControlClass}-plaintext`;
          $$invalidate(20, tag = "input");
        }
        if (size && isNotaNumber.test(size)) {
          console.warn(`Please use the prop "bsSize" instead of the "size" to bootstrap's input sizing.`);
          $$invalidate(0, bsSize = size);
          $$invalidate(1, size = void 0);
        }
        $$invalidate(19, classes = classnames(className, formControlClass, {
          "is-invalid": invalid,
          "is-valid": valid,
          [`form-control-${bsSize}`]: bsSize && !isBtn,
          [`btn-${bsSize}`]: bsSize && isBtn
        }));
      }
    }
  };
  return [
    bsSize,
    size,
    checked,
    files,
    group,
    inner,
    value,
    className,
    disabled,
    feedback,
    invalid,
    label,
    multiple,
    name,
    placeholder,
    readonly,
    reverse,
    type,
    valid,
    classes,
    tag,
    handleInput,
    $$restProps,
    color,
    plaintext,
    slots,
    blur_handler,
    change_handler,
    focus_handler,
    input_handler,
    keydown_handler,
    keypress_handler,
    keyup_handler,
    blur_handler_1,
    change_handler_1,
    focus_handler_1,
    input_handler_1,
    keydown_handler_1,
    keypress_handler_1,
    keyup_handler_1,
    blur_handler_2,
    change_handler_2,
    focus_handler_2,
    input_handler_2,
    keydown_handler_2,
    keypress_handler_2,
    keyup_handler_2,
    blur_handler_3,
    change_handler_3,
    focus_handler_3,
    input_handler_3,
    keydown_handler_3,
    keypress_handler_3,
    keyup_handler_3,
    blur_handler_4,
    change_handler_4,
    focus_handler_4,
    input_handler_4,
    keydown_handler_4,
    keypress_handler_4,
    keyup_handler_4,
    blur_handler_6,
    change_handler_6,
    focus_handler_6,
    input_handler_6,
    keydown_handler_6,
    keypress_handler_6,
    keyup_handler_6,
    blur_handler_7,
    change_handler_7,
    focus_handler_7,
    input_handler_7,
    keydown_handler_7,
    keypress_handler_7,
    keyup_handler_7,
    blur_handler_8,
    change_handler_8,
    focus_handler_8,
    input_handler_8,
    keydown_handler_8,
    keypress_handler_8,
    keyup_handler_8,
    blur_handler_9,
    change_handler_9,
    focus_handler_9,
    input_handler_9,
    keydown_handler_9,
    keypress_handler_9,
    keyup_handler_9,
    blur_handler_10,
    change_handler_10,
    focus_handler_10,
    input_handler_10,
    keydown_handler_10,
    keypress_handler_10,
    keyup_handler_10,
    blur_handler_11,
    change_handler_11,
    focus_handler_11,
    input_handler_11,
    keydown_handler_11,
    keypress_handler_11,
    keyup_handler_11,
    blur_handler_12,
    change_handler_12,
    focus_handler_12,
    input_handler_12,
    keydown_handler_12,
    keypress_handler_12,
    keyup_handler_12,
    blur_handler_13,
    change_handler_13,
    focus_handler_13,
    input_handler_13,
    keydown_handler_13,
    keypress_handler_13,
    keyup_handler_13,
    blur_handler_14,
    change_handler_14,
    focus_handler_14,
    input_handler_14,
    keydown_handler_14,
    keypress_handler_14,
    keyup_handler_14,
    blur_handler_15,
    change_handler_15,
    focus_handler_15,
    input_handler_15,
    keydown_handler_15,
    keypress_handler_15,
    keyup_handler_15,
    blur_handler_16,
    change_handler_16,
    focus_handler_16,
    input_handler_16,
    keydown_handler_16,
    keypress_handler_16,
    keyup_handler_16,
    blur_handler_17,
    change_handler_17,
    focus_handler_17,
    input_handler_17,
    keydown_handler_17,
    keypress_handler_17,
    keyup_handler_17,
    blur_handler_18,
    focus_handler_18,
    keydown_handler_18,
    keypress_handler_18,
    keyup_handler_18,
    blur_handler_19,
    change_handler_18,
    focus_handler_19,
    input_handler_18,
    keydown_handler_19,
    keypress_handler_19,
    keyup_handler_19,
    blur_handler_20,
    change_handler_19,
    focus_handler_20,
    input_handler_19,
    input_input_handler,
    input_binding,
    input_input_handler_1,
    input_binding_1,
    input_input_handler_2,
    input_binding_2,
    input_input_handler_3,
    input_binding_3,
    input_change_handler,
    input_binding_4,
    formcheck_checked_binding,
    formcheck_inner_binding,
    formcheck_group_binding,
    formcheck_value_binding,
    blur_handler_5,
    change_handler_5,
    focus_handler_5,
    input_handler_5,
    keydown_handler_5,
    keypress_handler_5,
    keyup_handler_5,
    input_input_handler_4,
    input_binding_5,
    input_input_handler_5,
    input_binding_6,
    input_input_handler_6,
    input_binding_7,
    input_input_handler_7,
    input_binding_8,
    input_input_handler_8,
    input_binding_9,
    input_input_handler_9,
    input_binding_10,
    input_input_handler_10,
    input_binding_11,
    input_input_handler_11,
    input_binding_12,
    input_change_input_handler,
    input_binding_13,
    input_input_handler_12,
    input_binding_14,
    input_input_handler_13,
    input_binding_15,
    input_input_handler_14,
    input_binding_16,
    textarea_input_handler,
    textarea_binding,
    select_change_handler,
    select_binding,
    $$scope
  ];
}
var Input = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance48,
      create_fragment48,
      safe_not_equal,
      {
        class: 7,
        bsSize: 0,
        checked: 2,
        color: 23,
        disabled: 8,
        feedback: 9,
        files: 3,
        group: 4,
        inner: 5,
        invalid: 10,
        label: 11,
        multiple: 12,
        name: 13,
        placeholder: 14,
        plaintext: 24,
        readonly: 15,
        reverse: 16,
        size: 1,
        type: 17,
        valid: 18,
        value: 6
      },
      null,
      [-1, -1, -1, -1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Input",
      options,
      id: create_fragment48.name
    });
  }
  get class() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bsSize() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bsSize(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get feedback() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set feedback(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get files() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inner() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inner(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get plaintext() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set plaintext(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readonly() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readonly(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reverse() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reverse(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valid() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valid(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Input_default = Input;

// node_modules/sveltestrap/src/InputGroup.svelte
var file48 = "node_modules/sveltestrap/src/InputGroup.svelte";
function create_fragment49(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  let div_levels = [ctx[1], { class: ctx[0] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file48, 14, 0, 243);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment49.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance49($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InputGroup", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { size = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("size" in $$new_props)
      $$invalidate(3, size = $$new_props.size);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, size, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("size" in $$props)
      $$invalidate(3, size = $$new_props.size);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12) {
      $:
        $$invalidate(0, classes = classnames(className, "input-group", size ? `input-group-${size}` : null));
    }
  };
  return [classes, $$restProps, className, size, $$scope, slots];
}
var InputGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance49, create_fragment49, safe_not_equal, { class: 2, size: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputGroup",
      options,
      id: create_fragment49.name
    });
  }
  get class() {
    throw new Error("<InputGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<InputGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<InputGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<InputGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputGroup_default = InputGroup;

// node_modules/sveltestrap/src/InputGroupText.svelte
var file49 = "node_modules/sveltestrap/src/InputGroupText.svelte";
function create_fragment50(ctx) {
  let span;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let span_levels = [ctx[1], { class: ctx[0] }];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      set_attributes(span, span_data);
      add_location(span, file49, 9, 0, 171);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment50.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance50($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InputGroupText", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(0, classes = classnames(className, "input-group-text"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var InputGroupText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance50, create_fragment50, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputGroupText",
      options,
      id: create_fragment50.name
    });
  }
  get class() {
    throw new Error("<InputGroupText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<InputGroupText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputGroupText_default = InputGroupText;

// node_modules/sveltestrap/src/Jumbotron.svelte
var file50 = "node_modules/sveltestrap/src/Jumbotron.svelte";
function create_fragment51(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", ctx[0]);
      add_location(div, file50, 9, 0, 182);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1) {
        attr_dev(div, "class", ctx2[0]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment51.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance51($$self, $$props, $$invalidate) {
  let classes;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Jumbotron", slots, ["default"]);
  let { class: className = "" } = $$props;
  const writable_props = ["class"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Jumbotron> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(1, className = $$props2.class);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$props2) => {
    if ("className" in $$props2)
      $$invalidate(1, className = $$props2.className);
    if ("classes" in $$props2)
      $$invalidate(0, classes = $$props2.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $:
        $$invalidate(0, classes = classnames(className, "p-5 mb-4 bg-light rounded-3"));
    }
  };
  return [classes, className, $$scope, slots];
}
var Jumbotron = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance51, create_fragment51, safe_not_equal, { class: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Jumbotron",
      options,
      id: create_fragment51.name
    });
  }
  get class() {
    throw new Error("<Jumbotron>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Jumbotron>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Jumbotron_default = Jumbotron;

// node_modules/sveltestrap/src/Label.svelte
var file51 = "node_modules/sveltestrap/src/Label.svelte";
function create_fragment52(ctx) {
  let label;
  let current;
  const default_slot_template = ctx[15].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[14], null);
  let label_levels = [
    ctx[2],
    { class: ctx[1] },
    { for: ctx[0] }
  ];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  const block = {
    c: function create() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      set_attributes(label, label_data);
      add_location(label, file51, 71, 0, 1672);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(default_slot_template, ctx2[14], dirty, null),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        dirty & 4 && ctx2[2],
        (!current || dirty & 2) && { class: ctx2[1] },
        (!current || dirty & 1) && { for: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment52.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance52($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "hidden", "check", "size", "for", "xs", "sm", "md", "lg", "xl", "xxl", "widths"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Label", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { hidden = false } = $$props;
  let { check = false } = $$props;
  let { size = "" } = $$props;
  let { for: fore = null } = $$props;
  let { xs = "" } = $$props;
  let { sm = "" } = $$props;
  let { md = "" } = $$props;
  let { lg = "" } = $$props;
  let { xl = "" } = $$props;
  let { xxl = "" } = $$props;
  const colWidths = { xs, sm, md, lg, xl, xxl };
  let { widths = Object.keys(colWidths) } = $$props;
  const colClasses = [];
  widths.forEach((colWidth) => {
    let columnProp = $$props[colWidth];
    if (!columnProp && columnProp !== "") {
      return;
    }
    const isXs = colWidth === "xs";
    let colClass;
    if (isObject(columnProp)) {
      const colSizeInterfix = isXs ? "-" : `-${colWidth}-`;
      colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);
      colClasses.push(classnames({
        [colClass]: columnProp.size || columnProp.size === "",
        [`order${colSizeInterfix}${columnProp.order}`]: columnProp.order || columnProp.order === 0,
        [`offset${colSizeInterfix}${columnProp.offset}`]: columnProp.offset || columnProp.offset === 0
      }));
    } else {
      colClass = getColumnSizeClass(isXs, colWidth, columnProp);
      colClasses.push(colClass);
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("hidden" in $$new_props)
      $$invalidate(4, hidden = $$new_props.hidden);
    if ("check" in $$new_props)
      $$invalidate(5, check = $$new_props.check);
    if ("size" in $$new_props)
      $$invalidate(6, size = $$new_props.size);
    if ("for" in $$new_props)
      $$invalidate(0, fore = $$new_props.for);
    if ("xs" in $$new_props)
      $$invalidate(7, xs = $$new_props.xs);
    if ("sm" in $$new_props)
      $$invalidate(8, sm = $$new_props.sm);
    if ("md" in $$new_props)
      $$invalidate(9, md = $$new_props.md);
    if ("lg" in $$new_props)
      $$invalidate(10, lg = $$new_props.lg);
    if ("xl" in $$new_props)
      $$invalidate(11, xl = $$new_props.xl);
    if ("xxl" in $$new_props)
      $$invalidate(12, xxl = $$new_props.xxl);
    if ("widths" in $$new_props)
      $$invalidate(13, widths = $$new_props.widths);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    getColumnSizeClass,
    isObject,
    className,
    hidden,
    check,
    size,
    fore,
    xs,
    sm,
    md,
    lg,
    xl,
    xxl,
    colWidths,
    widths,
    colClasses,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("hidden" in $$props)
      $$invalidate(4, hidden = $$new_props.hidden);
    if ("check" in $$props)
      $$invalidate(5, check = $$new_props.check);
    if ("size" in $$props)
      $$invalidate(6, size = $$new_props.size);
    if ("fore" in $$props)
      $$invalidate(0, fore = $$new_props.fore);
    if ("xs" in $$props)
      $$invalidate(7, xs = $$new_props.xs);
    if ("sm" in $$props)
      $$invalidate(8, sm = $$new_props.sm);
    if ("md" in $$props)
      $$invalidate(9, md = $$new_props.md);
    if ("lg" in $$props)
      $$invalidate(10, lg = $$new_props.lg);
    if ("xl" in $$props)
      $$invalidate(11, xl = $$new_props.xl);
    if ("xxl" in $$props)
      $$invalidate(12, xxl = $$new_props.xxl);
    if ("widths" in $$props)
      $$invalidate(13, widths = $$new_props.widths);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 120) {
      $:
        $$invalidate(1, classes = classnames(className, hidden ? "visually-hidden" : false, check ? "form-check-label" : false, size ? `col-form-label-${size}` : false, colClasses, colClasses.length ? "col-form-label" : "form-label"));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    fore,
    classes,
    $$restProps,
    className,
    hidden,
    check,
    size,
    xs,
    sm,
    md,
    lg,
    xl,
    xxl,
    widths,
    $$scope,
    slots
  ];
}
var Label = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance52, create_fragment52, safe_not_equal, {
      class: 3,
      hidden: 4,
      check: 5,
      size: 6,
      for: 0,
      xs: 7,
      sm: 8,
      md: 9,
      lg: 10,
      xl: 11,
      xxl: 12,
      widths: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Label",
      options,
      id: create_fragment52.name
    });
  }
  get class() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hidden() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidden(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get check() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set check(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get for() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set for(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xs() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xs(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sm() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sm(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get md() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set md(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lg() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lg(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xl() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xl(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xxl() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xxl(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get widths() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set widths(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Label_default = Label;

// node_modules/sveltestrap/src/ListGroup.svelte
var file52 = "node_modules/sveltestrap/src/ListGroup.svelte";
function create_else_block14(ctx) {
  let ul;
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let ul_levels = [ctx[2], { class: ctx[1] }];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      set_attributes(ul, ul_data);
      add_location(ul, file52, 19, 2, 384);
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [
        dirty & 4 && ctx2[2],
        (!current || dirty & 2) && { class: ctx2[1] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block14.name,
    type: "else",
    source: "(19:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block18(ctx) {
  let ol;
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let ol_levels = [ctx[2], { class: ctx[1] }];
  let ol_data = {};
  for (let i = 0; i < ol_levels.length; i += 1) {
    ol_data = assign(ol_data, ol_levels[i]);
  }
  const block = {
    c: function create() {
      ol = element("ol");
      if (default_slot)
        default_slot.c();
      set_attributes(ol, ol_data);
      add_location(ol, file52, 15, 2, 315);
    },
    m: function mount(target, anchor) {
      insert_dev(target, ol, anchor);
      if (default_slot) {
        default_slot.m(ol, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
      set_attributes(ol, ol_data = get_spread_update(ol_levels, [
        dirty & 4 && ctx2[2],
        (!current || dirty & 2) && { class: ctx2[1] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ol);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block18.name,
    type: "if",
    source: "(15:0) {#if numbered}",
    ctx
  });
  return block;
}
function create_fragment53(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block18, create_else_block14];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment53.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance53($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "flush", "numbered"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListGroup", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { flush = false } = $$props;
  let { numbered = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("flush" in $$new_props)
      $$invalidate(4, flush = $$new_props.flush);
    if ("numbered" in $$new_props)
      $$invalidate(0, numbered = $$new_props.numbered);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    flush,
    numbered,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("flush" in $$props)
      $$invalidate(4, flush = $$new_props.flush);
    if ("numbered" in $$props)
      $$invalidate(0, numbered = $$new_props.numbered);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 25) {
      $:
        $$invalidate(1, classes = classnames(className, "list-group", {
          "list-group-flush": flush,
          "list-group-numbered": numbered
        }));
    }
  };
  return [numbered, classes, $$restProps, className, flush, $$scope, slots];
}
var ListGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance53, create_fragment53, safe_not_equal, { class: 3, flush: 4, numbered: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListGroup",
      options,
      id: create_fragment53.name
    });
  }
  get class() {
    throw new Error("<ListGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ListGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flush() {
    throw new Error("<ListGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flush(value) {
    throw new Error("<ListGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get numbered() {
    throw new Error("<ListGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set numbered(value) {
    throw new Error("<ListGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListGroup_default = ListGroup;

// node_modules/sveltestrap/src/ListGroupItem.svelte
var file53 = "node_modules/sveltestrap/src/ListGroupItem.svelte";
function create_else_block15(ctx) {
  let li;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  let li_levels = [
    ctx[5],
    { class: ctx[4] },
    { disabled: ctx[1] },
    { active: ctx[0] }
  ];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      set_attributes(li, li_data);
      add_location(li, file53, 36, 2, 749);
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(li, "click", ctx[13], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null),
            null
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        dirty & 32 && ctx2[5],
        (!current || dirty & 16) && { class: ctx2[4] },
        (!current || dirty & 2) && { disabled: ctx2[1] },
        (!current || dirty & 1) && { active: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block15.name,
    type: "else",
    source: "(36:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_111(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  let button_levels = [
    ctx[5],
    { class: ctx[4] },
    { type: "button" },
    { disabled: ctx[1] },
    { active: ctx[0] }
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      set_attributes(button, button_data);
      add_location(button, file53, 25, 2, 602);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", ctx[12], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null),
            null
          );
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty & 32 && ctx2[5],
        (!current || dirty & 16) && { class: ctx2[4] },
        { type: "button" },
        (!current || dirty & 2) && { disabled: ctx2[1] },
        (!current || dirty & 1) && { active: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_111.name,
    type: "if",
    source: "(25:27) ",
    ctx
  });
  return block;
}
function create_if_block19(ctx) {
  let a;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[9], null);
  let a_levels = [
    ctx[5],
    { class: ctx[4] },
    { href: ctx[2] },
    { disabled: ctx[1] },
    { active: ctx[0] }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
      add_location(a, file53, 21, 2, 479);
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(a, "click", ctx[11], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[9],
            !current ? get_all_dirty_from_scope(ctx2[9]) : get_slot_changes(default_slot_template, ctx2[9], dirty, null),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & 32 && ctx2[5],
        (!current || dirty & 16) && { class: ctx2[4] },
        (!current || dirty & 4) && { href: ctx2[2] },
        (!current || dirty & 2) && { disabled: ctx2[1] },
        (!current || dirty & 1) && { active: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block19.name,
    type: "if",
    source: "(21:0) {#if href}",
    ctx
  });
  return block;
}
function create_fragment54(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block19, create_if_block_111, create_else_block15];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    if (ctx2[3] === "button")
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment54.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance54($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "active", "disabled", "color", "action", "href", "tag"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListGroupItem", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { disabled = false } = $$props;
  let { color = "" } = $$props;
  let { action = false } = $$props;
  let { href = null } = $$props;
  let { tag = null } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(0, active = $$new_props.active);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("color" in $$new_props)
      $$invalidate(7, color = $$new_props.color);
    if ("action" in $$new_props)
      $$invalidate(8, action = $$new_props.action);
    if ("href" in $$new_props)
      $$invalidate(2, href = $$new_props.href);
    if ("tag" in $$new_props)
      $$invalidate(3, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    active,
    disabled,
    color,
    action,
    href,
    tag,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(0, active = $$new_props.active);
    if ("disabled" in $$props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("color" in $$props)
      $$invalidate(7, color = $$new_props.color);
    if ("action" in $$props)
      $$invalidate(8, action = $$new_props.action);
    if ("href" in $$props)
      $$invalidate(2, href = $$new_props.href);
    if ("tag" in $$props)
      $$invalidate(3, tag = $$new_props.tag);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 459) {
      $:
        $$invalidate(4, classes = classnames(className, "list-group-item", {
          active,
          disabled,
          "list-group-item-action": action || tag === "button",
          [`list-group-item-${color}`]: color
        }));
    }
  };
  return [
    active,
    disabled,
    href,
    tag,
    classes,
    $$restProps,
    className,
    color,
    action,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
var ListGroupItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance54, create_fragment54, safe_not_equal, {
      class: 6,
      active: 0,
      disabled: 1,
      color: 7,
      action: 8,
      href: 2,
      tag: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListGroupItem",
      options,
      id: create_fragment54.name
    });
  }
  get class() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get action() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set action(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<ListGroupItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<ListGroupItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListGroupItem_default = ListGroupItem;

// node_modules/sveltestrap/src/ModalBackdrop.svelte
var file54 = "node_modules/sveltestrap/src/ModalBackdrop.svelte";
function create_if_block20(ctx) {
  let div;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  let div_levels = [ctx[4], { class: ctx[3] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      set_attributes(div, div_data);
      toggle_class(div, "fade", ctx[1]);
      add_location(div, file54, 20, 2, 464);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(div, "click", ctx[6], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 16 && ctx2[4],
        (!current || dirty & 8) && { class: ctx2[3] }
      ]));
      toggle_class(div, "fade", ctx2[1]);
    },
    i: function intro(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (div_outro)
          div_outro.end(1);
        div_intro = create_in_transition(div, backdropIn, {});
        div_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      if (div_intro)
        div_intro.invalidate();
      div_outro = create_out_transition(div, backdropOut, {});
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (detaching && div_outro)
        div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block20.name,
    type: "if",
    source: "(20:0) {#if isOpen && loaded}",
    ctx
  });
  return block;
}
function create_fragment55(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && ctx[2] && create_if_block20(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0] && ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block20(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment55.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance55($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "isOpen", "fade"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ModalBackdrop", slots, []);
  let { class: className = "" } = $$props;
  let { isOpen = false } = $$props;
  let { fade: fade2 = true } = $$props;
  let loaded = false;
  onMount(() => {
    $$invalidate(2, loaded = true);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("fade" in $$new_props)
      $$invalidate(1, fade2 = $$new_props.fade);
  };
  $$self.$capture_state = () => ({
    onMount,
    classnames,
    backdropIn,
    backdropOut,
    className,
    isOpen,
    fade: fade2,
    loaded,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("fade" in $$props)
      $$invalidate(1, fade2 = $$new_props.fade);
    if ("loaded" in $$props)
      $$invalidate(2, loaded = $$new_props.loaded);
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32) {
      $:
        $$invalidate(3, classes = classnames(className, "modal-backdrop"));
    }
  };
  return [isOpen, fade2, loaded, classes, $$restProps, className, click_handler];
}
var ModalBackdrop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance55, create_fragment55, safe_not_equal, { class: 5, isOpen: 0, fade: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ModalBackdrop",
      options,
      id: create_fragment55.name
    });
  }
  get class() {
    throw new Error("<ModalBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ModalBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<ModalBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<ModalBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fade() {
    throw new Error("<ModalBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fade(value) {
    throw new Error("<ModalBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ModalBackdrop_default = ModalBackdrop;

// node_modules/sveltestrap/src/ModalBody.svelte
var file55 = "node_modules/sveltestrap/src/ModalBody.svelte";
function create_fragment56(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let div_levels = [ctx[1], { class: ctx[0] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file55, 9, 0, 165);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment56.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance56($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ModalBody", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(0, classes = classnames(className, "modal-body"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var ModalBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance56, create_fragment56, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ModalBody",
      options,
      id: create_fragment56.name
    });
  }
  get class() {
    throw new Error("<ModalBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ModalBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ModalBody_default = ModalBody;

// node_modules/sveltestrap/src/ModalHeader.svelte
var file56 = "node_modules/sveltestrap/src/ModalHeader.svelte";
var get_close_slot_changes = (dirty) => ({});
var get_close_slot_context = (ctx) => ({});
function create_else_block16(ctx) {
  let current;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block16.name,
    type: "else",
    source: "(18:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_112(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[2]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4)
        set_data_dev(t, ctx2[2]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_112.name,
    type: "if",
    source: "(16:4) {#if children}",
    ctx
  });
  return block;
}
function create_if_block21(ctx) {
  let button;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "btn-close");
      attr_dev(button, "aria-label", ctx[1]);
      add_location(button, file56, 23, 6, 525);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(ctx[0]))
              ctx[0].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2) {
        attr_dev(button, "aria-label", ctx[1]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block21.name,
    type: "if",
    source: "(23:4) {#if typeof toggle === 'function'}",
    ctx
  });
  return block;
}
function fallback_block4(ctx) {
  let if_block_anchor;
  let if_block = typeof ctx[0] === "function" && create_if_block21(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (typeof ctx2[0] === "function") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block21(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block4.name,
    type: "fallback",
    source: "(22:21)      ",
    ctx
  });
  return block;
}
function create_fragment57(ctx) {
  let div;
  let h5;
  let current_block_type_index;
  let if_block;
  let t;
  let current;
  const if_block_creators = [create_if_block_112, create_else_block16];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const close_slot_template = ctx[8].close;
  const close_slot = create_slot(close_slot_template, ctx, ctx[7], get_close_slot_context);
  const close_slot_or_fallback = close_slot || fallback_block4(ctx);
  let div_levels = [ctx[5], { class: ctx[4] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      h5 = element("h5");
      if_block.c();
      t = space();
      if (close_slot_or_fallback)
        close_slot_or_fallback.c();
      attr_dev(h5, "class", "modal-title");
      attr_dev(h5, "id", ctx[3]);
      add_location(h5, file56, 14, 2, 344);
      set_attributes(div, div_data);
      add_location(div, file56, 13, 0, 303);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, h5);
      if_blocks[current_block_type_index].m(h5, null);
      append_dev(div, t);
      if (close_slot_or_fallback) {
        close_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(h5, null);
      }
      if (!current || dirty & 8) {
        attr_dev(h5, "id", ctx2[3]);
      }
      if (close_slot) {
        if (close_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            close_slot,
            close_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(close_slot_template, ctx2[7], dirty, get_close_slot_changes),
            get_close_slot_context
          );
        }
      } else {
        if (close_slot_or_fallback && close_slot_or_fallback.p && (!current || dirty & 3)) {
          close_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 32 && ctx2[5],
        (!current || dirty & 16) && { class: ctx2[4] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(close_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(close_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      if (close_slot_or_fallback)
        close_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment57.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance57($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "toggle", "closeAriaLabel", "children", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ModalHeader", slots, ["default", "close"]);
  let { class: className = "" } = $$props;
  let { toggle = void 0 } = $$props;
  let { closeAriaLabel = "Close" } = $$props;
  let { children = void 0 } = $$props;
  let { id = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("toggle" in $$new_props)
      $$invalidate(0, toggle = $$new_props.toggle);
    if ("closeAriaLabel" in $$new_props)
      $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("children" in $$new_props)
      $$invalidate(2, children = $$new_props.children);
    if ("id" in $$new_props)
      $$invalidate(3, id = $$new_props.id);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    toggle,
    closeAriaLabel,
    children,
    id,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("toggle" in $$props)
      $$invalidate(0, toggle = $$new_props.toggle);
    if ("closeAriaLabel" in $$props)
      $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("children" in $$props)
      $$invalidate(2, children = $$new_props.children);
    if ("id" in $$props)
      $$invalidate(3, id = $$new_props.id);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 64) {
      $:
        $$invalidate(4, classes = classnames(className, "modal-header"));
    }
  };
  return [
    toggle,
    closeAriaLabel,
    children,
    id,
    classes,
    $$restProps,
    className,
    $$scope,
    slots
  ];
}
var ModalHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance57, create_fragment57, safe_not_equal, {
      class: 6,
      toggle: 0,
      closeAriaLabel: 1,
      children: 2,
      id: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ModalHeader",
      options,
      id: create_fragment57.name
    });
  }
  get class() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeAriaLabel() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeAriaLabel(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<ModalHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<ModalHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ModalHeader_default = ModalHeader;

// node_modules/sveltestrap/src/Portal.svelte
var file57 = "node_modules/sveltestrap/src/Portal.svelte";
function create_fragment58(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  let div_levels = [ctx[1]];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file57, 18, 0, 346);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[4](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & 2 && ctx2[1]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[4](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment58.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance58($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Portal", slots, ["default"]);
  let ref;
  let portal;
  onMount(() => {
    portal = document.createElement("div");
    document.body.appendChild(portal);
    portal.appendChild(ref);
  });
  onDestroy(() => {
    if (typeof document !== "undefined") {
      document.body.removeChild(portal);
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ onMount, onDestroy, ref, portal });
  $$self.$inject_state = ($$new_props) => {
    if ("ref" in $$props)
      $$invalidate(0, ref = $$new_props.ref);
    if ("portal" in $$props)
      portal = $$new_props.portal;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ref, $$restProps, $$scope, slots, div_binding];
}
var Portal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance58, create_fragment58, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Portal",
      options,
      id: create_fragment58.name
    });
  }
};
var Portal_default = Portal;

// node_modules/sveltestrap/src/Modal.svelte
var file58 = "node_modules/sveltestrap/src/Modal.svelte";
function add_css(target) {
  append_styles(target, "svelte-d87gpn", ".modal-open{overflow:hidden;padding-right:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTW9kYWwuc3ZlbHRlIiwic291cmNlcyI6WyJNb2RhbC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCI+XG4gIC8vIFRPRE8gZmFkZSBvcHRpb25cbiAgbGV0IG9wZW5Db3VudCA9IDA7XG48L3NjcmlwdD5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnLi91dGlscyc7XG4gIGltcG9ydCB7IGJyb3dzZXJFdmVudCB9IGZyb20gJy4vdXRpbHMnO1xuICBpbXBvcnQge1xuICAgIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcixcbiAgICBvbkRlc3Ryb3ksXG4gICAgb25Nb3VudCxcbiAgICBhZnRlclVwZGF0ZVxuICB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCB7IG1vZGFsSW4sIG1vZGFsT3V0IH0gZnJvbSAnLi90cmFuc2l0aW9ucyc7XG4gIGltcG9ydCBJbmxpbmVDb250YWluZXIgZnJvbSAnLi9JbmxpbmVDb250YWluZXIuc3ZlbHRlJztcbiAgaW1wb3J0IE1vZGFsQmFja2Ryb3AgZnJvbSAnLi9Nb2RhbEJhY2tkcm9wLnN2ZWx0ZSc7XG4gIGltcG9ydCBNb2RhbEJvZHkgZnJvbSAnLi9Nb2RhbEJvZHkuc3ZlbHRlJztcbiAgaW1wb3J0IE1vZGFsSGVhZGVyIGZyb20gJy4vTW9kYWxIZWFkZXIuc3ZlbHRlJztcbiAgaW1wb3J0IFBvcnRhbCBmcm9tICcuL1BvcnRhbC5zdmVsdGUnO1xuICBpbXBvcnQge1xuICAgIGNvbmRpdGlvbmFsbHlVcGRhdGVTY3JvbGxiYXIsXG4gICAgZ2V0T3JpZ2luYWxCb2R5UGFkZGluZyxcbiAgICBzZXRTY3JvbGxiYXJXaWR0aCxcbiAgICB1dWlkXG4gIH0gZnJvbSAnLi91dGlscyc7XG5cbiAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuICBsZXQgY2xhc3NOYW1lID0gJyc7XG4gIGxldCBzdGF0aWNNb2RhbCA9IGZhbHNlO1xuICBleHBvcnQgeyBjbGFzc05hbWUgYXMgY2xhc3MgfTtcbiAgZXhwb3J0IHsgc3RhdGljTW9kYWwgYXMgc3RhdGljIH07XG4gIGV4cG9ydCBsZXQgaXNPcGVuID0gZmFsc2U7XG4gIGV4cG9ydCBsZXQgYXV0b0ZvY3VzID0gdHJ1ZTtcbiAgZXhwb3J0IGxldCBib2R5ID0gZmFsc2U7XG4gIGV4cG9ydCBsZXQgY2VudGVyZWQgPSBmYWxzZTtcbiAgZXhwb3J0IGxldCBjb250YWluZXIgPSB1bmRlZmluZWQ7XG4gIGV4cG9ydCBsZXQgZnVsbHNjcmVlbiA9IGZhbHNlO1xuICBleHBvcnQgbGV0IGhlYWRlciA9IHVuZGVmaW5lZDtcbiAgZXhwb3J0IGxldCBzY3JvbGxhYmxlID0gZmFsc2U7XG4gIGV4cG9ydCBsZXQgc2l6ZSA9ICcnO1xuICBleHBvcnQgbGV0IHRvZ2dsZSA9IHVuZGVmaW5lZDtcbiAgZXhwb3J0IGxldCBsYWJlbGxlZEJ5ID0gaGVhZGVyID8gYG1vZGFsLSR7dXVpZCgpfWAgOiB1bmRlZmluZWQ7XG4gIGV4cG9ydCBsZXQgYmFja2Ryb3AgPSB0cnVlO1xuICBleHBvcnQgbGV0IHdyYXBDbGFzc05hbWUgPSAnJztcbiAgZXhwb3J0IGxldCBtb2RhbENsYXNzTmFtZSA9ICcnO1xuICBleHBvcnQgbGV0IGNvbnRlbnRDbGFzc05hbWUgPSAnJztcbiAgZXhwb3J0IGxldCBmYWRlID0gdHJ1ZTtcbiAgZXhwb3J0IGxldCB1bm1vdW50T25DbG9zZSA9IHRydWU7XG4gIGV4cG9ydCBsZXQgcmV0dXJuRm9jdXNBZnRlckNsb3NlID0gdHJ1ZTtcblxuICBsZXQgaGFzT3BlbmVkID0gZmFsc2U7XG4gIGxldCBfaXNNb3VudGVkID0gZmFsc2U7XG4gIGxldCBfdHJpZ2dlcmluZ0VsZW1lbnQ7XG4gIGxldCBfb3JpZ2luYWxCb2R5UGFkZGluZztcbiAgbGV0IF9sYXN0SXNPcGVuID0gaXNPcGVuO1xuICBsZXQgX2xhc3RIYXNPcGVuZWQgPSBoYXNPcGVuZWQ7XG4gIGxldCBfZGlhbG9nO1xuICBsZXQgX21vdXNlRG93bkVsZW1lbnQ7XG4gIGxldCBfcmVtb3ZlRXNjTGlzdGVuZXI7XG5cbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgaWYgKGlzT3Blbikge1xuICAgICAgaW5pdCgpO1xuICAgICAgaGFzT3BlbmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaGFzT3BlbmVkICYmIGF1dG9Gb2N1cykge1xuICAgICAgc2V0Rm9jdXMoKTtcbiAgICB9XG4gIH0pO1xuXG4gIG9uRGVzdHJveSgoKSA9PiB7XG4gICAgZGVzdHJveSgpO1xuICAgIGlmIChoYXNPcGVuZWQpIHtcbiAgICAgIGNsb3NlKCk7XG4gICAgfVxuICB9KTtcblxuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgaWYgKGlzT3BlbiAmJiAhX2xhc3RJc09wZW4pIHtcbiAgICAgIGluaXQoKTtcbiAgICAgIGhhc09wZW5lZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGF1dG9Gb2N1cyAmJiBoYXNPcGVuZWQgJiYgIV9sYXN0SGFzT3BlbmVkKSB7XG4gICAgICBzZXRGb2N1cygpO1xuICAgIH1cblxuICAgIF9sYXN0SXNPcGVuID0gaXNPcGVuO1xuICAgIF9sYXN0SGFzT3BlbmVkID0gaGFzT3BlbmVkO1xuICB9KTtcblxuICBmdW5jdGlvbiBzZXRGb2N1cygpIHtcbiAgICBpZiAoXG4gICAgICBfZGlhbG9nICYmXG4gICAgICBfZGlhbG9nLnBhcmVudE5vZGUgJiZcbiAgICAgIHR5cGVvZiBfZGlhbG9nLnBhcmVudE5vZGUuZm9jdXMgPT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIF9kaWFsb2cucGFyZW50Tm9kZS5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIF90cmlnZ2VyaW5nRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfdHJpZ2dlcmluZ0VsZW1lbnQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICghc3RhdGljTW9kYWwpIHtcbiAgICAgIF9vcmlnaW5hbEJvZHlQYWRkaW5nID0gZ2V0T3JpZ2luYWxCb2R5UGFkZGluZygpO1xuICAgICAgY29uZGl0aW9uYWxseVVwZGF0ZVNjcm9sbGJhcigpO1xuICAgICAgaWYgKG9wZW5Db3VudCA9PT0gMCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTmFtZSA9IGNsYXNzbmFtZXMoXG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc05hbWUsXG4gICAgICAgICAgJ21vZGFsLW9wZW4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgICsrb3BlbkNvdW50O1xuICAgIH1cbiAgICBfaXNNb3VudGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hbmFnZUZvY3VzQWZ0ZXJDbG9zZSgpIHtcbiAgICBpZiAoX3RyaWdnZXJpbmdFbGVtZW50KSB7XG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBfdHJpZ2dlcmluZ0VsZW1lbnQuZm9jdXMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgcmV0dXJuRm9jdXNBZnRlckNsb3NlXG4gICAgICApIHtcbiAgICAgICAgX3RyaWdnZXJpbmdFbGVtZW50LmZvY3VzKCk7XG4gICAgICB9XG5cbiAgICAgIF90cmlnZ2VyaW5nRWxlbWVudCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBtYW5hZ2VGb2N1c0FmdGVyQ2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmIChvcGVuQ291bnQgPD0gMSkge1xuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdtb2RhbC1vcGVuJyk7XG4gICAgfVxuXG4gICAgbWFuYWdlRm9jdXNBZnRlckNsb3NlKCk7XG4gICAgb3BlbkNvdW50ID0gTWF0aC5tYXgoMCwgb3BlbkNvdW50IC0gMSk7XG5cbiAgICBzZXRTY3JvbGxiYXJXaWR0aChfb3JpZ2luYWxCb2R5UGFkZGluZyk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVCYWNrZHJvcENsaWNrKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IF9tb3VzZURvd25FbGVtZW50KSB7XG4gICAgICBpZiAoIWlzT3BlbiB8fCAhYmFja2Ryb3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBiYWNrZHJvcEVsZW0gPSBfZGlhbG9nID8gX2RpYWxvZy5wYXJlbnROb2RlIDogbnVsbDtcbiAgICAgIGlmIChcbiAgICAgICAgYmFja2Ryb3AgPT09IHRydWUgJiZcbiAgICAgICAgYmFja2Ryb3BFbGVtICYmXG4gICAgICAgIGUudGFyZ2V0ID09PSBiYWNrZHJvcEVsZW0gJiZcbiAgICAgICAgdG9nZ2xlXG4gICAgICApIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdG9nZ2xlKGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTW9kYWxPcGVuZWQoKSB7XG4gICAgZGlzcGF0Y2goJ29wZW4nKTtcbiAgICBfcmVtb3ZlRXNjTGlzdGVuZXIgPSBicm93c2VyRXZlbnQoZG9jdW1lbnQsICdrZXlkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQua2V5ICYmIGV2ZW50LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgaWYgKHRvZ2dsZSAmJiBiYWNrZHJvcCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmIChfcmVtb3ZlRXNjTGlzdGVuZXIpIF9yZW1vdmVFc2NMaXN0ZW5lcigpO1xuICAgICAgICAgIHRvZ2dsZShldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTW9kYWxDbG9zaW5nKCkge1xuICAgIGRpc3BhdGNoKCdjbG9zaW5nJyk7XG4gICAgaWYgKF9yZW1vdmVFc2NMaXN0ZW5lcikge1xuICAgICAgX3JlbW92ZUVzY0xpc3RlbmVyKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Nb2RhbENsb3NlZCgpIHtcbiAgICBkaXNwYXRjaCgnY2xvc2UnKTtcbiAgICBpZiAodW5tb3VudE9uQ2xvc2UpIHtcbiAgICAgIGRlc3Ryb3koKTtcbiAgICB9XG4gICAgY2xvc2UoKTtcbiAgICBpZiAoX2lzTW91bnRlZCkge1xuICAgICAgaGFzT3BlbmVkID0gZmFsc2U7XG4gICAgfVxuICAgIF9pc01vdW50ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUJhY2tkcm9wTW91c2VEb3duKGUpIHtcbiAgICBfbW91c2VEb3duRWxlbWVudCA9IGUudGFyZ2V0O1xuICB9XG5cbiAgY29uc3QgZGlhbG9nQmFzZUNsYXNzID0gJ21vZGFsLWRpYWxvZyc7XG5cbiAgJDogY2xhc3NlcyA9IGNsYXNzbmFtZXMoZGlhbG9nQmFzZUNsYXNzLCBjbGFzc05hbWUsIHtcbiAgICBbYG1vZGFsLSR7c2l6ZX1gXTogc2l6ZSxcbiAgICAnbW9kYWwtZnVsbHNjcmVlbic6IGZ1bGxzY3JlZW4gPT09IHRydWUsXG4gICAgW2Btb2RhbC1mdWxsc2NyZWVuLSR7ZnVsbHNjcmVlbn0tZG93bmBdOlxuICAgICAgZnVsbHNjcmVlbiAmJiB0eXBlb2YgZnVsbHNjcmVlbiA9PT0gJ3N0cmluZycsXG4gICAgW2Ake2RpYWxvZ0Jhc2VDbGFzc30tY2VudGVyZWRgXTogY2VudGVyZWQsXG4gICAgW2Ake2RpYWxvZ0Jhc2VDbGFzc30tc2Nyb2xsYWJsZWBdOiBzY3JvbGxhYmxlXG4gIH0pO1xuXG4gICQ6IG91dGVyID0gY29udGFpbmVyID09PSAnaW5saW5lJyB8fCBzdGF0aWNNb2RhbCA/IElubGluZUNvbnRhaW5lciA6IFBvcnRhbDtcbjwvc2NyaXB0PlxuXG57I2lmIF9pc01vdW50ZWR9XG4gIDxzdmVsdGU6Y29tcG9uZW50IHRoaXM9e291dGVyfT5cbiAgICA8ZGl2IGNsYXNzPXt3cmFwQ2xhc3NOYW1lfSB0YWJpbmRleD1cIi0xXCIgey4uLiQkcmVzdFByb3BzfT5cbiAgICAgIHsjaWYgaXNPcGVufVxuICAgICAgICA8ZGl2XG4gICAgICAgICAgaW46bW9kYWxJblxuICAgICAgICAgIG91dDptb2RhbE91dFxuICAgICAgICAgIGFyaWEtbGFiZWxsZWRieT17bGFiZWxsZWRCeX1cbiAgICAgICAgICBjbGFzcz17Y2xhc3NuYW1lcygnbW9kYWwnLCBtb2RhbENsYXNzTmFtZSwge1xuICAgICAgICAgICAgZmFkZSxcbiAgICAgICAgICAgICdwb3NpdGlvbi1zdGF0aWMnOiBzdGF0aWNNb2RhbFxuICAgICAgICAgIH0pfVxuICAgICAgICAgIHJvbGU9XCJkaWFsb2dcIlxuICAgICAgICAgIG9uOmludHJvc3RhcnQ9eygpID0+IGRpc3BhdGNoKCdvcGVuaW5nJyl9XG4gICAgICAgICAgb246aW50cm9lbmQ9e29uTW9kYWxPcGVuZWR9XG4gICAgICAgICAgb246b3V0cm9zdGFydD17b25Nb2RhbENsb3Npbmd9XG4gICAgICAgICAgb246b3V0cm9lbmQ9e29uTW9kYWxDbG9zZWR9XG4gICAgICAgICAgb246Y2xpY2s9e2hhbmRsZUJhY2tkcm9wQ2xpY2t9XG4gICAgICAgICAgb246bW91c2Vkb3duPXtoYW5kbGVCYWNrZHJvcE1vdXNlRG93bn1cbiAgICAgICAgPlxuICAgICAgICAgIDxzbG90IG5hbWU9XCJleHRlcm5hbFwiIC8+XG4gICAgICAgICAgPGRpdiBjbGFzcz17Y2xhc3Nlc30gcm9sZT1cImRvY3VtZW50XCIgYmluZDp0aGlzPXtfZGlhbG9nfT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9e2NsYXNzbmFtZXMoJ21vZGFsLWNvbnRlbnQnLCBjb250ZW50Q2xhc3NOYW1lKX0+XG4gICAgICAgICAgICAgIHsjaWYgaGVhZGVyfVxuICAgICAgICAgICAgICAgIDxNb2RhbEhlYWRlciB7dG9nZ2xlfSBpZD17bGFiZWxsZWRCeX0+XG4gICAgICAgICAgICAgICAgICB7aGVhZGVyfVxuICAgICAgICAgICAgICAgIDwvTW9kYWxIZWFkZXI+XG4gICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgIHsjaWYgYm9keX1cbiAgICAgICAgICAgICAgICA8TW9kYWxCb2R5PlxuICAgICAgICAgICAgICAgICAgPHNsb3QgLz5cbiAgICAgICAgICAgICAgICA8L01vZGFsQm9keT5cbiAgICAgICAgICAgICAgezplbHNlfVxuICAgICAgICAgICAgICAgIDxzbG90IC8+XG4gICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICB7L2lmfVxuICAgIDwvZGl2PlxuICA8L3N2ZWx0ZTpjb21wb25lbnQ+XG57L2lmfVxueyNpZiBiYWNrZHJvcCAmJiAhc3RhdGljTW9kYWx9XG4gIDxzdmVsdGU6Y29tcG9uZW50IHRoaXM9e291dGVyfT5cbiAgICA8TW9kYWxCYWNrZHJvcCB7ZmFkZX0ge2lzT3Blbn0gLz5cbiAgPC9zdmVsdGU6Y29tcG9uZW50Plxuey9pZn1cblxuPHN0eWxlPlxuICA6Z2xvYmFsKC5tb2RhbC1vcGVuKSB7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBwYWRkaW5nLXJpZ2h0OiAwO1xuICB9XG48L3N0eWxlPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQStRVSxXQUFXLEFBQUUsQ0FBQyxBQUNwQixRQUFRLENBQUUsTUFBTSxDQUNoQixhQUFhLENBQUUsQ0FBQyxBQUNsQixDQUFDIn0= */");
}
var get_external_slot_changes = (dirty) => ({});
var get_external_slot_context = (ctx) => ({});
function create_if_block_113(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[13];
  function switch_props(ctx2) {
    return {
      props: {
        $$slots: { default: [create_default_slot_13] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty[0] & 2119615 | dirty[1] & 8) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = ctx2[13])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_113.name,
    type: "if",
    source: "(223:0) {#if _isMounted}",
    ctx
  });
  return block;
}
function create_if_block_210(ctx) {
  let div2;
  let t0;
  let div1;
  let div0;
  let t1;
  let current_block_type_index;
  let if_block1;
  let div0_class_value;
  let div2_class_value;
  let div2_intro;
  let div2_outro;
  let current;
  let mounted;
  let dispose;
  const external_slot_template = ctx[31].external;
  const external_slot = create_slot(external_slot_template, ctx, ctx[34], get_external_slot_context);
  let if_block0 = ctx[3] && create_if_block_43(ctx);
  const if_block_creators = [create_if_block_34, create_else_block17];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div2 = element("div");
      if (external_slot)
        external_slot.c();
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t1 = space();
      if_block1.c();
      attr_dev(div0, "class", div0_class_value = classnames("modal-content", ctx[9]));
      add_location(div0, file58, 244, 12, 5732);
      attr_dev(div1, "class", ctx[14]);
      attr_dev(div1, "role", "document");
      add_location(div1, file58, 243, 10, 5662);
      attr_dev(div2, "aria-labelledby", ctx[5]);
      attr_dev(div2, "class", div2_class_value = classnames("modal", ctx[8], {
        fade: ctx[10],
        "position-static": ctx[0]
      }));
      attr_dev(div2, "role", "dialog");
      add_location(div2, file58, 226, 8, 5106);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      if (external_slot) {
        external_slot.m(div2, null);
      }
      append_dev(div2, t0);
      append_dev(div2, div1);
      append_dev(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_dev(div0, t1);
      if_blocks[current_block_type_index].m(div0, null);
      ctx[32](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div2, "introstart", ctx[33], false, false, false),
          listen_dev(div2, "introend", ctx[17], false, false, false),
          listen_dev(div2, "outrostart", ctx[18], false, false, false),
          listen_dev(div2, "outroend", ctx[19], false, false, false),
          listen_dev(div2, "click", ctx[16], false, false, false),
          listen_dev(div2, "mousedown", ctx[20], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (external_slot) {
        if (external_slot.p && (!current || dirty[1] & 8)) {
          update_slot_base(
            external_slot,
            external_slot_template,
            ctx2,
            ctx2[34],
            !current ? get_all_dirty_from_scope(ctx2[34]) : get_slot_changes(external_slot_template, ctx2[34], dirty, get_external_slot_changes),
            get_external_slot_context
          );
        }
      }
      if (ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_43(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div0, null);
      }
      if (!current || dirty[0] & 512 && div0_class_value !== (div0_class_value = classnames("modal-content", ctx2[9]))) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & 16384) {
        attr_dev(div1, "class", ctx2[14]);
      }
      if (!current || dirty[0] & 32) {
        attr_dev(div2, "aria-labelledby", ctx2[5]);
      }
      if (!current || dirty[0] & 1281 && div2_class_value !== (div2_class_value = classnames("modal", ctx2[8], {
        fade: ctx2[10],
        "position-static": ctx2[0]
      }))) {
        attr_dev(div2, "class", div2_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(external_slot, local);
      transition_in(if_block0);
      transition_in(if_block1);
      add_render_callback(() => {
        if (div2_outro)
          div2_outro.end(1);
        div2_intro = create_in_transition(div2, modalIn, {});
        div2_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(external_slot, local);
      transition_out(if_block0);
      transition_out(if_block1);
      if (div2_intro)
        div2_intro.invalidate();
      div2_outro = create_out_transition(div2, modalOut, {});
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (external_slot)
        external_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      ctx[32](null);
      if (detaching && div2_outro)
        div2_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_210.name,
    type: "if",
    source: "(226:6) {#if isOpen}",
    ctx
  });
  return block;
}
function create_if_block_43(ctx) {
  let modalheader;
  let current;
  modalheader = new ModalHeader_default({
    props: {
      toggle: ctx[4],
      id: ctx[5],
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(modalheader.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(modalheader, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const modalheader_changes = {};
      if (dirty[0] & 16)
        modalheader_changes.toggle = ctx2[4];
      if (dirty[0] & 32)
        modalheader_changes.id = ctx2[5];
      if (dirty[0] & 8 | dirty[1] & 8) {
        modalheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalheader.$set(modalheader_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(modalheader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(modalheader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(modalheader, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_43.name,
    type: "if",
    source: "(246:14) {#if header}",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[3]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 8)
        set_data_dev(t, ctx2[3]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(247:16) <ModalHeader {toggle} id={labelledBy}>",
    ctx
  });
  return block;
}
function create_else_block17(ctx) {
  let current;
  const default_slot_template = ctx[31].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[34], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[34],
            !current ? get_all_dirty_from_scope(ctx2[34]) : get_slot_changes(default_slot_template, ctx2[34], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block17.name,
    type: "else",
    source: "(255:14) {:else}",
    ctx
  });
  return block;
}
function create_if_block_34(ctx) {
  let modalbody;
  let current;
  modalbody = new ModalBody_default({
    props: {
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(modalbody.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(modalbody, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const modalbody_changes = {};
      if (dirty[1] & 8) {
        modalbody_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalbody.$set(modalbody_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(modalbody.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(modalbody.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(modalbody, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_34.name,
    type: "if",
    source: "(251:14) {#if body}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let current;
  const default_slot_template = ctx[31].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[34], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[34],
            !current ? get_all_dirty_from_scope(ctx2[34]) : get_slot_changes(default_slot_template, ctx2[34], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(252:16) <ModalBody>",
    ctx
  });
  return block;
}
function create_default_slot_13(ctx) {
  let div;
  let current;
  let if_block = ctx[1] && create_if_block_210(ctx);
  let div_levels = [
    { class: ctx[7] },
    { tabindex: "-1" },
    ctx[21]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      set_attributes(div, div_data);
      add_location(div, file58, 224, 4, 5020);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_210(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & 128) && { class: ctx2[7] },
        { tabindex: "-1" },
        dirty[0] & 2097152 && ctx2[21]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13.name,
    type: "slot",
    source: "(224:2) <svelte:component this={outer}>",
    ctx
  });
  return block;
}
function create_if_block22(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[13];
  function switch_props(ctx2) {
    return {
      props: {
        $$slots: { default: [create_default_slot4] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty[0] & 1026 | dirty[1] & 8) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = ctx2[13])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block22.name,
    type: "if",
    source: "(265:0) {#if backdrop && !staticModal}",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let modalbackdrop;
  let current;
  modalbackdrop = new ModalBackdrop_default({
    props: {
      fade: ctx[10],
      isOpen: ctx[1]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(modalbackdrop.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(modalbackdrop, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const modalbackdrop_changes = {};
      if (dirty[0] & 1024)
        modalbackdrop_changes.fade = ctx2[10];
      if (dirty[0] & 2)
        modalbackdrop_changes.isOpen = ctx2[1];
      modalbackdrop.$set(modalbackdrop_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(modalbackdrop.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(modalbackdrop.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(modalbackdrop, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(266:2) <svelte:component this={outer}>",
    ctx
  });
  return block;
}
function create_fragment59(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = ctx[11] && create_if_block_113(ctx);
  let if_block1 = ctx[6] && !ctx[0] && create_if_block22(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[11]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 2048) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_113(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[6] && !ctx2[0]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 65) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block22(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment59.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var openCount = 0;
var dialogBaseClass = "modal-dialog";
function instance59($$self, $$props, $$invalidate) {
  let classes;
  let outer;
  const omit_props_names = [
    "class",
    "static",
    "isOpen",
    "autoFocus",
    "body",
    "centered",
    "container",
    "fullscreen",
    "header",
    "scrollable",
    "size",
    "toggle",
    "labelledBy",
    "backdrop",
    "wrapClassName",
    "modalClassName",
    "contentClassName",
    "fade",
    "unmountOnClose",
    "returnFocusAfterClose"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Modal", slots, ["external", "default"]);
  const dispatch = createEventDispatcher();
  let { class: className = "" } = $$props;
  let { static: staticModal = false } = $$props;
  let { isOpen = false } = $$props;
  let { autoFocus = true } = $$props;
  let { body = false } = $$props;
  let { centered = false } = $$props;
  let { container = void 0 } = $$props;
  let { fullscreen = false } = $$props;
  let { header = void 0 } = $$props;
  let { scrollable = false } = $$props;
  let { size = "" } = $$props;
  let { toggle = void 0 } = $$props;
  let { labelledBy = header ? `modal-${uuid()}` : void 0 } = $$props;
  let { backdrop = true } = $$props;
  let { wrapClassName = "" } = $$props;
  let { modalClassName = "" } = $$props;
  let { contentClassName = "" } = $$props;
  let { fade: fade2 = true } = $$props;
  let { unmountOnClose = true } = $$props;
  let { returnFocusAfterClose = true } = $$props;
  let hasOpened = false;
  let _isMounted = false;
  let _triggeringElement;
  let _originalBodyPadding;
  let _lastIsOpen = isOpen;
  let _lastHasOpened = hasOpened;
  let _dialog;
  let _mouseDownElement;
  let _removeEscListener;
  onMount(() => {
    if (isOpen) {
      init2();
      hasOpened = true;
    }
    if (hasOpened && autoFocus) {
      setFocus();
    }
  });
  onDestroy(() => {
    destroy();
    if (hasOpened) {
      close();
    }
  });
  afterUpdate(() => {
    if (isOpen && !_lastIsOpen) {
      init2();
      hasOpened = true;
    }
    if (autoFocus && hasOpened && !_lastHasOpened) {
      setFocus();
    }
    _lastIsOpen = isOpen;
    _lastHasOpened = hasOpened;
  });
  function setFocus() {
    if (_dialog && _dialog.parentNode && typeof _dialog.parentNode.focus === "function") {
      _dialog.parentNode.focus();
    }
  }
  function init2() {
    try {
      _triggeringElement = document.activeElement;
    } catch (err) {
      _triggeringElement = null;
    }
    if (!staticModal) {
      _originalBodyPadding = getOriginalBodyPadding();
      conditionallyUpdateScrollbar();
      if (openCount === 0) {
        document.body.className = classnames(document.body.className, "modal-open");
      }
      ++openCount;
    }
    $$invalidate(11, _isMounted = true);
  }
  function manageFocusAfterClose() {
    if (_triggeringElement) {
      if (typeof _triggeringElement.focus === "function" && returnFocusAfterClose) {
        _triggeringElement.focus();
      }
      _triggeringElement = null;
    }
  }
  function destroy() {
    manageFocusAfterClose();
  }
  function close() {
    if (openCount <= 1) {
      document.body.classList.remove("modal-open");
    }
    manageFocusAfterClose();
    openCount = Math.max(0, openCount - 1);
    setScrollbarWidth(_originalBodyPadding);
  }
  function handleBackdropClick(e) {
    if (e.target === _mouseDownElement) {
      if (!isOpen || !backdrop) {
        return;
      }
      const backdropElem = _dialog ? _dialog.parentNode : null;
      if (backdrop === true && backdropElem && e.target === backdropElem && toggle) {
        e.stopPropagation();
        toggle(e);
      }
    }
  }
  function onModalOpened() {
    dispatch("open");
    _removeEscListener = browserEvent(document, "keydown", (event) => {
      if (event.key && event.key === "Escape") {
        if (toggle && backdrop === true) {
          if (_removeEscListener)
            _removeEscListener();
          toggle(event);
        }
      }
    });
  }
  function onModalClosing() {
    dispatch("closing");
    if (_removeEscListener) {
      _removeEscListener();
    }
  }
  function onModalClosed() {
    dispatch("close");
    if (unmountOnClose) {
      destroy();
    }
    close();
    if (_isMounted) {
      hasOpened = false;
    }
    $$invalidate(11, _isMounted = false);
  }
  function handleBackdropMouseDown(e) {
    _mouseDownElement = e.target;
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      _dialog = $$value;
      $$invalidate(12, _dialog);
    });
  }
  const introstart_handler = () => dispatch("opening");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(21, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(22, className = $$new_props.class);
    if ("static" in $$new_props)
      $$invalidate(0, staticModal = $$new_props.static);
    if ("isOpen" in $$new_props)
      $$invalidate(1, isOpen = $$new_props.isOpen);
    if ("autoFocus" in $$new_props)
      $$invalidate(23, autoFocus = $$new_props.autoFocus);
    if ("body" in $$new_props)
      $$invalidate(2, body = $$new_props.body);
    if ("centered" in $$new_props)
      $$invalidate(24, centered = $$new_props.centered);
    if ("container" in $$new_props)
      $$invalidate(25, container = $$new_props.container);
    if ("fullscreen" in $$new_props)
      $$invalidate(26, fullscreen = $$new_props.fullscreen);
    if ("header" in $$new_props)
      $$invalidate(3, header = $$new_props.header);
    if ("scrollable" in $$new_props)
      $$invalidate(27, scrollable = $$new_props.scrollable);
    if ("size" in $$new_props)
      $$invalidate(28, size = $$new_props.size);
    if ("toggle" in $$new_props)
      $$invalidate(4, toggle = $$new_props.toggle);
    if ("labelledBy" in $$new_props)
      $$invalidate(5, labelledBy = $$new_props.labelledBy);
    if ("backdrop" in $$new_props)
      $$invalidate(6, backdrop = $$new_props.backdrop);
    if ("wrapClassName" in $$new_props)
      $$invalidate(7, wrapClassName = $$new_props.wrapClassName);
    if ("modalClassName" in $$new_props)
      $$invalidate(8, modalClassName = $$new_props.modalClassName);
    if ("contentClassName" in $$new_props)
      $$invalidate(9, contentClassName = $$new_props.contentClassName);
    if ("fade" in $$new_props)
      $$invalidate(10, fade2 = $$new_props.fade);
    if ("unmountOnClose" in $$new_props)
      $$invalidate(29, unmountOnClose = $$new_props.unmountOnClose);
    if ("returnFocusAfterClose" in $$new_props)
      $$invalidate(30, returnFocusAfterClose = $$new_props.returnFocusAfterClose);
    if ("$$scope" in $$new_props)
      $$invalidate(34, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    openCount,
    classnames,
    browserEvent,
    createEventDispatcher,
    onDestroy,
    onMount,
    afterUpdate,
    modalIn,
    modalOut,
    InlineContainer: InlineContainer_default,
    ModalBackdrop: ModalBackdrop_default,
    ModalBody: ModalBody_default,
    ModalHeader: ModalHeader_default,
    Portal: Portal_default,
    conditionallyUpdateScrollbar,
    getOriginalBodyPadding,
    setScrollbarWidth,
    uuid,
    dispatch,
    className,
    staticModal,
    isOpen,
    autoFocus,
    body,
    centered,
    container,
    fullscreen,
    header,
    scrollable,
    size,
    toggle,
    labelledBy,
    backdrop,
    wrapClassName,
    modalClassName,
    contentClassName,
    fade: fade2,
    unmountOnClose,
    returnFocusAfterClose,
    hasOpened,
    _isMounted,
    _triggeringElement,
    _originalBodyPadding,
    _lastIsOpen,
    _lastHasOpened,
    _dialog,
    _mouseDownElement,
    _removeEscListener,
    setFocus,
    init: init2,
    manageFocusAfterClose,
    destroy,
    close,
    handleBackdropClick,
    onModalOpened,
    onModalClosing,
    onModalClosed,
    handleBackdropMouseDown,
    dialogBaseClass,
    outer,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(22, className = $$new_props.className);
    if ("staticModal" in $$props)
      $$invalidate(0, staticModal = $$new_props.staticModal);
    if ("isOpen" in $$props)
      $$invalidate(1, isOpen = $$new_props.isOpen);
    if ("autoFocus" in $$props)
      $$invalidate(23, autoFocus = $$new_props.autoFocus);
    if ("body" in $$props)
      $$invalidate(2, body = $$new_props.body);
    if ("centered" in $$props)
      $$invalidate(24, centered = $$new_props.centered);
    if ("container" in $$props)
      $$invalidate(25, container = $$new_props.container);
    if ("fullscreen" in $$props)
      $$invalidate(26, fullscreen = $$new_props.fullscreen);
    if ("header" in $$props)
      $$invalidate(3, header = $$new_props.header);
    if ("scrollable" in $$props)
      $$invalidate(27, scrollable = $$new_props.scrollable);
    if ("size" in $$props)
      $$invalidate(28, size = $$new_props.size);
    if ("toggle" in $$props)
      $$invalidate(4, toggle = $$new_props.toggle);
    if ("labelledBy" in $$props)
      $$invalidate(5, labelledBy = $$new_props.labelledBy);
    if ("backdrop" in $$props)
      $$invalidate(6, backdrop = $$new_props.backdrop);
    if ("wrapClassName" in $$props)
      $$invalidate(7, wrapClassName = $$new_props.wrapClassName);
    if ("modalClassName" in $$props)
      $$invalidate(8, modalClassName = $$new_props.modalClassName);
    if ("contentClassName" in $$props)
      $$invalidate(9, contentClassName = $$new_props.contentClassName);
    if ("fade" in $$props)
      $$invalidate(10, fade2 = $$new_props.fade);
    if ("unmountOnClose" in $$props)
      $$invalidate(29, unmountOnClose = $$new_props.unmountOnClose);
    if ("returnFocusAfterClose" in $$props)
      $$invalidate(30, returnFocusAfterClose = $$new_props.returnFocusAfterClose);
    if ("hasOpened" in $$props)
      hasOpened = $$new_props.hasOpened;
    if ("_isMounted" in $$props)
      $$invalidate(11, _isMounted = $$new_props._isMounted);
    if ("_triggeringElement" in $$props)
      _triggeringElement = $$new_props._triggeringElement;
    if ("_originalBodyPadding" in $$props)
      _originalBodyPadding = $$new_props._originalBodyPadding;
    if ("_lastIsOpen" in $$props)
      _lastIsOpen = $$new_props._lastIsOpen;
    if ("_lastHasOpened" in $$props)
      _lastHasOpened = $$new_props._lastHasOpened;
    if ("_dialog" in $$props)
      $$invalidate(12, _dialog = $$new_props._dialog);
    if ("_mouseDownElement" in $$props)
      _mouseDownElement = $$new_props._mouseDownElement;
    if ("_removeEscListener" in $$props)
      _removeEscListener = $$new_props._removeEscListener;
    if ("outer" in $$props)
      $$invalidate(13, outer = $$new_props.outer);
    if ("classes" in $$props)
      $$invalidate(14, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 490733568) {
      $:
        $$invalidate(14, classes = classnames(dialogBaseClass, className, {
          [`modal-${size}`]: size,
          "modal-fullscreen": fullscreen === true,
          [`modal-fullscreen-${fullscreen}-down`]: fullscreen && typeof fullscreen === "string",
          [`${dialogBaseClass}-centered`]: centered,
          [`${dialogBaseClass}-scrollable`]: scrollable
        }));
    }
    if ($$self.$$.dirty[0] & 33554433) {
      $:
        $$invalidate(13, outer = container === "inline" || staticModal ? InlineContainer_default : Portal_default);
    }
  };
  return [
    staticModal,
    isOpen,
    body,
    header,
    toggle,
    labelledBy,
    backdrop,
    wrapClassName,
    modalClassName,
    contentClassName,
    fade2,
    _isMounted,
    _dialog,
    outer,
    classes,
    dispatch,
    handleBackdropClick,
    onModalOpened,
    onModalClosing,
    onModalClosed,
    handleBackdropMouseDown,
    $$restProps,
    className,
    autoFocus,
    centered,
    container,
    fullscreen,
    scrollable,
    size,
    unmountOnClose,
    returnFocusAfterClose,
    slots,
    div1_binding,
    introstart_handler,
    $$scope
  ];
}
var Modal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance59,
      create_fragment59,
      safe_not_equal,
      {
        class: 22,
        static: 0,
        isOpen: 1,
        autoFocus: 23,
        body: 2,
        centered: 24,
        container: 25,
        fullscreen: 26,
        header: 3,
        scrollable: 27,
        size: 28,
        toggle: 4,
        labelledBy: 5,
        backdrop: 6,
        wrapClassName: 7,
        modalClassName: 8,
        contentClassName: 9,
        fade: 10,
        unmountOnClose: 29,
        returnFocusAfterClose: 30
      },
      add_css,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Modal",
      options,
      id: create_fragment59.name
    });
  }
  get class() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get static() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set static(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoFocus() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoFocus(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get body() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set body(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get centered() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set centered(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fullscreen() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fullscreen(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollable() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollable(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledBy() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledBy(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdrop() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdrop(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapClassName() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapClassName(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get modalClassName() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set modalClassName(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get contentClassName() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set contentClassName(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fade() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fade(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get unmountOnClose() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set unmountOnClose(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get returnFocusAfterClose() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set returnFocusAfterClose(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Modal_default = Modal;

// node_modules/sveltestrap/src/ModalFooter.svelte
var file59 = "node_modules/sveltestrap/src/ModalFooter.svelte";
function create_fragment60(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let div_levels = [ctx[1], { class: ctx[0] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file59, 9, 0, 167);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment60.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance60($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ModalFooter", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(0, classes = classnames(className, "modal-footer"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var ModalFooter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance60, create_fragment60, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ModalFooter",
      options,
      id: create_fragment60.name
    });
  }
  get class() {
    throw new Error("<ModalFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ModalFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ModalFooter_default = ModalFooter;

// node_modules/sveltestrap/src/Nav.svelte
var file60 = "node_modules/sveltestrap/src/Nav.svelte";
function create_fragment61(ctx) {
  let ul;
  let current;
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  let ul_levels = [ctx[1], { class: ctx[0] }];
  let ul_data = {};
  for (let i = 0; i < ul_levels.length; i += 1) {
    ul_data = assign(ul_data, ul_levels[i]);
  }
  const block = {
    c: function create() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      set_attributes(ul, ul_data);
      add_location(ul, file60, 39, 0, 941);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(ul);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment61.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getVerticalClass(vertical) {
  if (vertical === false) {
    return false;
  } else if (vertical === true || vertical === "xs") {
    return "flex-column";
  }
  return `flex-${vertical}-column`;
}
function instance61($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "tabs",
    "pills",
    "vertical",
    "horizontal",
    "justified",
    "fill",
    "navbar",
    "card"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Nav", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { tabs = false } = $$props;
  let { pills = false } = $$props;
  let { vertical = false } = $$props;
  let { horizontal = "" } = $$props;
  let { justified = false } = $$props;
  let { fill = false } = $$props;
  let { navbar = false } = $$props;
  let { card = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("tabs" in $$new_props)
      $$invalidate(3, tabs = $$new_props.tabs);
    if ("pills" in $$new_props)
      $$invalidate(4, pills = $$new_props.pills);
    if ("vertical" in $$new_props)
      $$invalidate(5, vertical = $$new_props.vertical);
    if ("horizontal" in $$new_props)
      $$invalidate(6, horizontal = $$new_props.horizontal);
    if ("justified" in $$new_props)
      $$invalidate(7, justified = $$new_props.justified);
    if ("fill" in $$new_props)
      $$invalidate(8, fill = $$new_props.fill);
    if ("navbar" in $$new_props)
      $$invalidate(9, navbar = $$new_props.navbar);
    if ("card" in $$new_props)
      $$invalidate(10, card = $$new_props.card);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    tabs,
    pills,
    vertical,
    horizontal,
    justified,
    fill,
    navbar,
    card,
    getVerticalClass,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("tabs" in $$props)
      $$invalidate(3, tabs = $$new_props.tabs);
    if ("pills" in $$props)
      $$invalidate(4, pills = $$new_props.pills);
    if ("vertical" in $$props)
      $$invalidate(5, vertical = $$new_props.vertical);
    if ("horizontal" in $$props)
      $$invalidate(6, horizontal = $$new_props.horizontal);
    if ("justified" in $$props)
      $$invalidate(7, justified = $$new_props.justified);
    if ("fill" in $$props)
      $$invalidate(8, fill = $$new_props.fill);
    if ("navbar" in $$props)
      $$invalidate(9, navbar = $$new_props.navbar);
    if ("card" in $$props)
      $$invalidate(10, card = $$new_props.card);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2044) {
      $:
        $$invalidate(0, classes = classnames(className, navbar ? "navbar-nav" : "nav", horizontal ? `justify-content-${horizontal}` : false, getVerticalClass(vertical), {
          "nav-tabs": tabs,
          "card-header-tabs": card && tabs,
          "nav-pills": pills,
          "card-header-pills": card && pills,
          "nav-justified": justified,
          "nav-fill": fill
        }));
    }
  };
  return [
    classes,
    $$restProps,
    className,
    tabs,
    pills,
    vertical,
    horizontal,
    justified,
    fill,
    navbar,
    card,
    $$scope,
    slots
  ];
}
var Nav = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance61, create_fragment61, safe_not_equal, {
      class: 2,
      tabs: 3,
      pills: 4,
      vertical: 5,
      horizontal: 6,
      justified: 7,
      fill: 8,
      navbar: 9,
      card: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Nav",
      options,
      id: create_fragment61.name
    });
  }
  get class() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabs() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabs(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pills() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pills(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertical() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get horizontal() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set horizontal(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get justified() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justified(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navbar() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navbar(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get card() {
    throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set card(value) {
    throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Nav_default = Nav;

// node_modules/sveltestrap/src/Navbar.svelte
var file61 = "node_modules/sveltestrap/src/Navbar.svelte";
function create_else_block18(ctx) {
  let current;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block18.name,
    type: "else",
    source: "(44:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block23(ctx) {
  let container_1;
  let current;
  container_1 = new Container_default({
    props: {
      fluid: ctx[0] === "fluid",
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(container_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(container_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const container_1_changes = {};
      if (dirty & 1)
        container_1_changes.fluid = ctx2[0] === "fluid";
      if (dirty & 2048) {
        container_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      container_1.$set(container_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(container_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(container_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(container_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block23.name,
    type: "if",
    source: "(40:2) {#if container}",
    ctx
  });
  return block;
}
function create_default_slot5(ctx) {
  let current;
  const default_slot_template = ctx[10].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[11], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[11],
            !current ? get_all_dirty_from_scope(ctx2[11]) : get_slot_changes(default_slot_template, ctx2[11], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: "(41:4) <Container fluid={container === 'fluid'}>",
    ctx
  });
  return block;
}
function create_fragment62(ctx) {
  let nav;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block23, create_else_block18];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let nav_levels = [ctx[2], { class: ctx[1] }];
  let nav_data = {};
  for (let i = 0; i < nav_levels.length; i += 1) {
    nav_data = assign(nav_data, nav_levels[i]);
  }
  const block = {
    c: function create() {
      nav = element("nav");
      if_block.c();
      set_attributes(nav, nav_data);
      add_location(nav, file61, 38, 0, 889);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, nav, anchor);
      if_blocks[current_block_type_index].m(nav, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(nav, null);
      }
      set_attributes(nav, nav_data = get_spread_update(nav_levels, [
        dirty & 4 && ctx2[2],
        (!current || dirty & 2) && { class: ctx2[1] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(nav);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment62.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getExpandClass(expand) {
  if (expand === false) {
    return false;
  } else if (expand === true || expand === "xs") {
    return "navbar-expand";
  }
  return `navbar-expand-${expand}`;
}
function instance62($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "container", "color", "dark", "expand", "fixed", "light", "sticky"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Navbar", slots, ["default"]);
  setContext("navbar", { inNavbar: true });
  let { class: className = "" } = $$props;
  let { container = "fluid" } = $$props;
  let { color = "" } = $$props;
  let { dark = false } = $$props;
  let { expand = "" } = $$props;
  let { fixed = "" } = $$props;
  let { light = false } = $$props;
  let { sticky = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("container" in $$new_props)
      $$invalidate(0, container = $$new_props.container);
    if ("color" in $$new_props)
      $$invalidate(4, color = $$new_props.color);
    if ("dark" in $$new_props)
      $$invalidate(5, dark = $$new_props.dark);
    if ("expand" in $$new_props)
      $$invalidate(6, expand = $$new_props.expand);
    if ("fixed" in $$new_props)
      $$invalidate(7, fixed = $$new_props.fixed);
    if ("light" in $$new_props)
      $$invalidate(8, light = $$new_props.light);
    if ("sticky" in $$new_props)
      $$invalidate(9, sticky = $$new_props.sticky);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    Container: Container_default,
    setContext,
    className,
    container,
    color,
    dark,
    expand,
    fixed,
    light,
    sticky,
    getExpandClass,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("container" in $$props)
      $$invalidate(0, container = $$new_props.container);
    if ("color" in $$props)
      $$invalidate(4, color = $$new_props.color);
    if ("dark" in $$props)
      $$invalidate(5, dark = $$new_props.dark);
    if ("expand" in $$props)
      $$invalidate(6, expand = $$new_props.expand);
    if ("fixed" in $$props)
      $$invalidate(7, fixed = $$new_props.fixed);
    if ("light" in $$props)
      $$invalidate(8, light = $$new_props.light);
    if ("sticky" in $$props)
      $$invalidate(9, sticky = $$new_props.sticky);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1016) {
      $:
        $$invalidate(1, classes = classnames(className, "navbar", getExpandClass(expand), {
          "navbar-light": light,
          "navbar-dark": dark,
          [`bg-${color}`]: color,
          [`fixed-${fixed}`]: fixed,
          [`sticky-${sticky}`]: sticky
        }));
    }
  };
  return [
    container,
    classes,
    $$restProps,
    className,
    color,
    dark,
    expand,
    fixed,
    light,
    sticky,
    slots,
    $$scope
  ];
}
var Navbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance62, create_fragment62, safe_not_equal, {
      class: 3,
      container: 0,
      color: 4,
      dark: 5,
      expand: 6,
      fixed: 7,
      light: 8,
      sticky: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Navbar",
      options,
      id: create_fragment62.name
    });
  }
  get class() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dark() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dark(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expand() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expand(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fixed() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fixed(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get light() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set light(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sticky() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sticky(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Navbar_default = Navbar;

// node_modules/sveltestrap/src/NavItem.svelte
var file62 = "node_modules/sveltestrap/src/NavItem.svelte";
function create_fragment63(ctx) {
  let li;
  let current;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  let li_levels = [ctx[1], { class: ctx[0] }];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      set_attributes(li, li_data);
      add_location(li, file62, 10, 0, 219);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment63.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance63($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "active"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavItem", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(3, active = $$new_props.active);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, active, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(3, active = $$new_props.active);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12) {
      $:
        $$invalidate(0, classes = classnames(className, "nav-item", active ? "active" : false));
    }
  };
  return [classes, $$restProps, className, active, $$scope, slots];
}
var NavItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance63, create_fragment63, safe_not_equal, { class: 2, active: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavItem",
      options,
      id: create_fragment63.name
    });
  }
  get class() {
    throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavItem_default = NavItem;

// node_modules/sveltestrap/src/NavLink.svelte
var file63 = "node_modules/sveltestrap/src/NavLink.svelte";
function create_fragment64(ctx) {
  let a;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  let a_levels = [
    ctx[3],
    { href: ctx[0] },
    { class: ctx[1] }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
      add_location(a, file63, 27, 0, 472);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(a, "click", ctx[9], false, false, false),
          listen_dev(a, "click", ctx[2], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & 8 && ctx2[3],
        (!current || dirty & 1) && { href: ctx2[0] },
        (!current || dirty & 2) && { class: ctx2[1] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment64.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance64($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "disabled", "active", "href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavLink", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { disabled = false } = $$props;
  let { active = false } = $$props;
  let { href = "#" } = $$props;
  function handleClick(e) {
    if (disabled) {
      e.preventDefault();
      e.stopImmediatePropagation();
      return;
    }
    if (href === "#") {
      e.preventDefault();
    }
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("disabled" in $$new_props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("active" in $$new_props)
      $$invalidate(6, active = $$new_props.active);
    if ("href" in $$new_props)
      $$invalidate(0, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    disabled,
    active,
    href,
    handleClick,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("disabled" in $$props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("active" in $$props)
      $$invalidate(6, active = $$new_props.active);
    if ("href" in $$props)
      $$invalidate(0, href = $$new_props.href);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 112) {
      $:
        $$invalidate(1, classes = classnames(className, "nav-link", { disabled, active }));
    }
  };
  return [
    href,
    classes,
    handleClick,
    $$restProps,
    className,
    disabled,
    active,
    $$scope,
    slots,
    click_handler
  ];
}
var NavLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance64, create_fragment64, safe_not_equal, {
      class: 4,
      disabled: 5,
      active: 6,
      href: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavLink",
      options,
      id: create_fragment64.name
    });
  }
  get class() {
    throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavLink_default = NavLink;

// node_modules/sveltestrap/src/NavbarBrand.svelte
var file64 = "node_modules/sveltestrap/src/NavbarBrand.svelte";
function create_fragment65(ctx) {
  let a;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  let a_levels = [
    ctx[2],
    { class: ctx[1] },
    { href: ctx[0] }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (default_slot)
        default_slot.c();
      set_attributes(a, a_data);
      add_location(a, file64, 10, 0, 192);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(a, "click", ctx[6], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & 4 && ctx2[2],
        (!current || dirty & 2) && { class: ctx2[1] },
        (!current || dirty & 1) && { href: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment65.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance65($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavbarBrand", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { href = "/" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("href" in $$new_props)
      $$invalidate(0, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, href, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("href" in $$props)
      $$invalidate(0, href = $$new_props.href);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8) {
      $:
        $$invalidate(1, classes = classnames(className, "navbar-brand"));
    }
  };
  return [href, classes, $$restProps, className, $$scope, slots, click_handler];
}
var NavbarBrand = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance65, create_fragment65, safe_not_equal, { class: 3, href: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavbarBrand",
      options,
      id: create_fragment65.name
    });
  }
  get class() {
    throw new Error("<NavbarBrand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NavbarBrand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<NavbarBrand>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<NavbarBrand>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavbarBrand_default = NavbarBrand;

// node_modules/sveltestrap/src/NavbarToggler.svelte
var file65 = "node_modules/sveltestrap/src/NavbarToggler.svelte";
function fallback_block5(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", "navbar-toggler-icon");
      add_location(span, file65, 13, 4, 274);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block5.name,
    type: "fallback",
    source: "(13:8)      ",
    ctx
  });
  return block;
}
function create_default_slot6(ctx) {
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  const default_slot_or_fallback = default_slot || fallback_block5(ctx);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: "(12:0) <Button {...$$restProps} on:click class={classes}>",
    ctx
  });
  return block;
}
function create_fragment66(ctx) {
  let button;
  let current;
  const button_spread_levels = [ctx[1], { class: ctx[0] }];
  let button_props = {
    $$slots: { default: [create_default_slot6] },
    $$scope: { ctx }
  };
  for (let i = 0; i < button_spread_levels.length; i += 1) {
    button_props = assign(button_props, button_spread_levels[i]);
  }
  button = new Button_default({ props: button_props, $$inline: true });
  button.$on("click", ctx[4]);
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const button_changes = dirty & 3 ? get_spread_update(button_spread_levels, [
        dirty & 2 && get_spread_object(ctx2[1]),
        dirty & 1 && { class: ctx2[0] }
      ]) : {};
      if (dirty & 32) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment66.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance66($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavbarToggler", slots, ["default"]);
  let { class: className = "" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, Button: Button_default, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(0, classes = classnames(className, "navbar-toggler"));
    }
  };
  return [classes, $$restProps, className, slots, click_handler, $$scope];
}
var NavbarToggler = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance66, create_fragment66, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavbarToggler",
      options,
      id: create_fragment66.name
    });
  }
  get class() {
    throw new Error("<NavbarToggler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NavbarToggler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavbarToggler_default = NavbarToggler;

// node_modules/sveltestrap/src/OffcanvasBackdrop.svelte
var file66 = "node_modules/sveltestrap/src/OffcanvasBackdrop.svelte";
function create_if_block24(ctx) {
  let div;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  let div_levels = [ctx[3], { class: ctx[2] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      set_attributes(div, div_data);
      toggle_class(div, "fade", ctx[1]);
      add_location(div, file66, 12, 2, 354);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(div, "click", ctx[5], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 8 && ctx2[3],
        (!current || dirty & 4) && { class: ctx2[2] }
      ]));
      toggle_class(div, "fade", ctx2[1]);
    },
    i: function intro(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (div_outro)
          div_outro.end(1);
        div_intro = create_in_transition(div, backdropIn, {});
        div_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      if (div_intro)
        div_intro.invalidate();
      div_outro = create_out_transition(div, backdropOut, {});
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (detaching && div_outro)
        div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block24.name,
    type: "if",
    source: "(12:0) {#if isOpen}",
    ctx
  });
  return block;
}
function create_fragment67(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block24(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block24(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment67.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance67($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "isOpen", "fade"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OffcanvasBackdrop", slots, []);
  let { class: className = "" } = $$props;
  let { isOpen = false } = $$props;
  let { fade: fade2 = true } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("fade" in $$new_props)
      $$invalidate(1, fade2 = $$new_props.fade);
  };
  $$self.$capture_state = () => ({
    classnames,
    backdropIn,
    backdropOut,
    className,
    isOpen,
    fade: fade2,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("fade" in $$props)
      $$invalidate(1, fade2 = $$new_props.fade);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      $:
        $$invalidate(2, classes = classnames(className, "offcanvas-backdrop"));
    }
  };
  return [isOpen, fade2, classes, $$restProps, className, click_handler];
}
var OffcanvasBackdrop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance67, create_fragment67, safe_not_equal, { class: 4, isOpen: 0, fade: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OffcanvasBackdrop",
      options,
      id: create_fragment67.name
    });
  }
  get class() {
    throw new Error("<OffcanvasBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<OffcanvasBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<OffcanvasBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<OffcanvasBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fade() {
    throw new Error("<OffcanvasBackdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fade(value) {
    throw new Error("<OffcanvasBackdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OffcanvasBackdrop_default = OffcanvasBackdrop;

// node_modules/sveltestrap/src/OffcanvasBody.svelte
var file67 = "node_modules/sveltestrap/src/OffcanvasBody.svelte";
function create_fragment68(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let div_levels = [ctx[1], { class: ctx[0] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file67, 9, 0, 169);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment68.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance68($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OffcanvasBody", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(0, classes = classnames(className, "offcanvas-body"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var OffcanvasBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance68, create_fragment68, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OffcanvasBody",
      options,
      id: create_fragment68.name
    });
  }
  get class() {
    throw new Error("<OffcanvasBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<OffcanvasBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OffcanvasBody_default = OffcanvasBody;

// node_modules/sveltestrap/src/OffcanvasHeader.svelte
var file68 = "node_modules/sveltestrap/src/OffcanvasHeader.svelte";
var get_close_slot_changes2 = (dirty) => ({});
var get_close_slot_context2 = (ctx) => ({});
function create_else_block19(ctx) {
  let current;
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block19.name,
    type: "else",
    source: "(17:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_114(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[0]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1)
        set_data_dev(t, ctx2[0]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_114.name,
    type: "if",
    source: "(15:4) {#if children}",
    ctx
  });
  return block;
}
function create_if_block25(ctx) {
  let button;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      attr_dev(button, "aria-label", ctx[1]);
      attr_dev(button, "class", "btn-close");
      attr_dev(button, "type", "button");
      add_location(button, file68, 22, 6, 496);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(ctx[2]))
              ctx[2].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2) {
        attr_dev(button, "aria-label", ctx[1]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block25.name,
    type: "if",
    source: "(22:4) {#if typeof toggle === 'function'}",
    ctx
  });
  return block;
}
function fallback_block6(ctx) {
  let if_block_anchor;
  let if_block = typeof ctx[2] === "function" && create_if_block25(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (typeof ctx2[2] === "function") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block25(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block6.name,
    type: "fallback",
    source: "(21:21)      ",
    ctx
  });
  return block;
}
function create_fragment69(ctx) {
  let div;
  let h5;
  let current_block_type_index;
  let if_block;
  let t;
  let current;
  const if_block_creators = [create_if_block_114, create_else_block19];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const close_slot_template = ctx[7].close;
  const close_slot = create_slot(close_slot_template, ctx, ctx[6], get_close_slot_context2);
  const close_slot_or_fallback = close_slot || fallback_block6(ctx);
  let div_levels = [ctx[4], { class: ctx[3] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      h5 = element("h5");
      if_block.c();
      t = space();
      if (close_slot_or_fallback)
        close_slot_or_fallback.c();
      attr_dev(h5, "class", "offcanvas-title");
      add_location(h5, file68, 13, 2, 319);
      set_attributes(div, div_data);
      add_location(div, file68, 12, 0, 278);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, h5);
      if_blocks[current_block_type_index].m(h5, null);
      append_dev(div, t);
      if (close_slot_or_fallback) {
        close_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(h5, null);
      }
      if (close_slot) {
        if (close_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            close_slot,
            close_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(close_slot_template, ctx2[6], dirty, get_close_slot_changes2),
            get_close_slot_context2
          );
        }
      } else {
        if (close_slot_or_fallback && close_slot_or_fallback.p && (!current || dirty & 6)) {
          close_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 16 && ctx2[4],
        (!current || dirty & 8) && { class: ctx2[3] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(close_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(close_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      if (close_slot_or_fallback)
        close_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment69.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance69($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "children", "closeAriaLabel", "toggle"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OffcanvasHeader", slots, ["default", "close"]);
  let { class: className = "" } = $$props;
  let { children = void 0 } = $$props;
  let { closeAriaLabel = "Close" } = $$props;
  let { toggle = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(5, className = $$new_props.class);
    if ("children" in $$new_props)
      $$invalidate(0, children = $$new_props.children);
    if ("closeAriaLabel" in $$new_props)
      $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("toggle" in $$new_props)
      $$invalidate(2, toggle = $$new_props.toggle);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    children,
    closeAriaLabel,
    toggle,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(5, className = $$new_props.className);
    if ("children" in $$props)
      $$invalidate(0, children = $$new_props.children);
    if ("closeAriaLabel" in $$props)
      $$invalidate(1, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("toggle" in $$props)
      $$invalidate(2, toggle = $$new_props.toggle);
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32) {
      $:
        $$invalidate(3, classes = classnames(className, "offcanvas-header"));
    }
  };
  return [
    children,
    closeAriaLabel,
    toggle,
    classes,
    $$restProps,
    className,
    $$scope,
    slots
  ];
}
var OffcanvasHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance69, create_fragment69, safe_not_equal, {
      class: 5,
      children: 0,
      closeAriaLabel: 1,
      toggle: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OffcanvasHeader",
      options,
      id: create_fragment69.name
    });
  }
  get class() {
    throw new Error("<OffcanvasHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<OffcanvasHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<OffcanvasHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<OffcanvasHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeAriaLabel() {
    throw new Error("<OffcanvasHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeAriaLabel(value) {
    throw new Error("<OffcanvasHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<OffcanvasHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<OffcanvasHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OffcanvasHeader_default = OffcanvasHeader;

// node_modules/sveltestrap/src/Offcanvas.svelte
var { document: document_1 } = globals;
var file69 = "node_modules/sveltestrap/src/Offcanvas.svelte";
function add_css2(target) {
  append_styles(target, "svelte-xe7n9u", ".overflow-noscroll{overflow:hidden;padding-right:0px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiT2ZmY2FudmFzLnN2ZWx0ZSIsInNvdXJjZXMiOlsiT2ZmY2FudmFzLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIsIG9uTW91bnQgfSBmcm9tICdzdmVsdGUnO1xuICBpbXBvcnQgSW5saW5lQ29udGFpbmVyIGZyb20gJy4vSW5saW5lQ29udGFpbmVyLnN2ZWx0ZSc7XG4gIGltcG9ydCBPZmZjYW52YXNCYWNrZHJvcCBmcm9tICcuL09mZmNhbnZhc0JhY2tkcm9wLnN2ZWx0ZSc7XG4gIGltcG9ydCBPZmZjYW52YXNCb2R5IGZyb20gJy4vT2ZmY2FudmFzQm9keS5zdmVsdGUnO1xuICBpbXBvcnQgT2ZmY2FudmFzSGVhZGVyIGZyb20gJy4vT2ZmY2FudmFzSGVhZGVyLnN2ZWx0ZSc7XG4gIGltcG9ydCBQb3J0YWwgZnJvbSAnLi9Qb3J0YWwuc3ZlbHRlJztcbiAgaW1wb3J0IGNsYXNzbmFtZXMsIHsgYnJvd3NlckV2ZW50LCBnZXRUcmFuc2l0aW9uRHVyYXRpb24gfSBmcm9tICcuL3V0aWxzJztcblxuICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gIGxldCBjbGFzc05hbWUgPSAnJztcbiAgZXhwb3J0IHsgY2xhc3NOYW1lIGFzIGNsYXNzIH07XG4gIGV4cG9ydCBsZXQgYmFja2Ryb3AgPSB0cnVlO1xuICBleHBvcnQgbGV0IGJvZHkgPSB0cnVlO1xuICBleHBvcnQgbGV0IGNvbnRhaW5lciA9ICdib2R5JztcbiAgZXhwb3J0IGxldCBmYWRlID0gdHJ1ZTtcbiAgZXhwb3J0IGxldCBoZWFkZXIgPSB1bmRlZmluZWQ7XG4gIGV4cG9ydCBsZXQgaXNPcGVuID0gZmFsc2U7XG4gIGV4cG9ydCBsZXQgcGxhY2VtZW50ID0gJ3N0YXJ0JztcbiAgZXhwb3J0IGxldCBzY3JvbGwgPSBmYWxzZTtcbiAgZXhwb3J0IGxldCBzbSA9IGZhbHNlO1xuICBleHBvcnQgbGV0IG1kID0gZmFsc2U7XG4gIGV4cG9ydCBsZXQgbGcgPSBmYWxzZTtcbiAgZXhwb3J0IGxldCB4bCA9IGZhbHNlO1xuICBleHBvcnQgbGV0IHh4bCA9IGZhbHNlO1xuICBleHBvcnQgbGV0IHN0eWxlID0gJyc7XG4gIGV4cG9ydCBsZXQgdG9nZ2xlID0gdW5kZWZpbmVkO1xuXG4gIC8vIFRPRE8gc3VwcG9ydCB0aGVzZSBsaWtlIE1vZGFsczpcbiAgLy8gZXhwb3J0IGxldCBhdXRvRm9jdXMgPSB0cnVlO1xuICAvLyBleHBvcnQgbGV0IHVubW91bnRPbkNsb3NlID0gdHJ1ZTtcbiAgLy8gVE9ETyBmb2N1cyB0cmFwXG5cbiAgbGV0IGJvZHlFbGVtZW50O1xuICBsZXQgaXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gIGxldCBlbGVtZW50O1xuICBsZXQgcmVtb3ZlRXNjTGlzdGVuZXI7XG5cbiAgb25Nb3VudCgoKSA9PiAoYm9keUVsZW1lbnQgPSBkb2N1bWVudC5ib2R5KSk7XG5cbiAgJDogaWYgKGJvZHlFbGVtZW50KSB7XG4gICAgaWYgKCFzY3JvbGwpIHtcbiAgICAgIGJvZHlFbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoJ292ZXJmbG93LW5vc2Nyb2xsJywgaXNPcGVuIHx8IGlzVHJhbnNpdGlvbmluZyk7XG4gICAgfVxuICB9XG4gICQ6IGlmIChlbGVtZW50KSB7XG4gICAgaXNPcGVuID0gaXNPcGVuOyAvLyBVc2VkIHRvIHRyaWdnZXIgcmVhY3RpdmUgb24gaXNPcGVuIGNoYW5nZXMuXG4gICAgaXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICBkaXNwYXRjaChpc09wZW4gPyAnb3BlbmluZycgOiAnY2xvc2luZycpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICBkaXNwYXRjaChpc09wZW4gPyAnb3BlbicgOiAnY2xvc2UnKTtcbiAgICB9LCBnZXRUcmFuc2l0aW9uRHVyYXRpb24oZWxlbWVudCkpO1xuICB9XG4gICQ6IGlmIChpc09wZW4gJiYgdG9nZ2xlICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmVtb3ZlRXNjTGlzdGVuZXIgPSBicm93c2VyRXZlbnQoZG9jdW1lbnQsICdrZXlkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQua2V5ICYmIGV2ZW50LmtleSA9PT0gJ0VzY2FwZScpIHRvZ2dsZSgpO1xuICAgIH0pO1xuICB9XG4gICQ6IGlmICghaXNPcGVuICYmIHJlbW92ZUVzY0xpc3RlbmVyKSB7XG4gICAgcmVtb3ZlRXNjTGlzdGVuZXIoKTtcbiAgfVxuICAkOiBoYW5kbGVNb3VzZURvd24gPVxuICAgIGJhY2tkcm9wICYmIHRvZ2dsZSAmJiBib2R5RWxlbWVudCAmJiBpc09wZW5cbiAgICAgID8gKGUpID0+IHtcbiAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IGJvZHlFbGVtZW50KSB7XG4gICAgICAgICAgICB0b2dnbGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIDogdW5kZWZpbmVkO1xuICAkOiBjbGFzc2VzID0gY2xhc3NuYW1lcyh7XG4gICAgb2ZmY2FudmFzOiAhc20gJiYgIW1kICYmICFsZyAmJiAheGwgJiYgIXh4bCwgXG4gICAgJ29mZmNhbnZhcy1zbSc6IHNtLFxuICAgICdvZmZjYW52YXMtbWQnOiBtZCxcbiAgICAnb2ZmY2FudmFzLWxnJzogbGcsXG4gICAgJ29mZmNhbnZhcy14bCc6IHhsLFxuICAgICdvZmZjYW52YXMteHhsJzogeHhsLFxuICAgIHNob3c6IGlzT3BlblxuICB9LCBgb2ZmY2FudmFzLSR7cGxhY2VtZW50fWAsIGNsYXNzTmFtZSk7XG4gICQ6IG91dGVyID0gY29udGFpbmVyID09PSAnaW5saW5lJyA/IElubGluZUNvbnRhaW5lciA6IFBvcnRhbDtcbjwvc2NyaXB0PlxuXG48c3ZlbHRlOmJvZHkgb246bW91c2Vkb3duPXtoYW5kbGVNb3VzZURvd259IC8+XG5cbjxzdmVsdGU6Y29tcG9uZW50IHRoaXM9e291dGVyfT5cbiAgPGRpdlxuICAgIHsuLi4kJHJlc3RQcm9wc31cbiAgICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gICAgYXJpYS1oaWRkZW49eyFpc09wZW4gPyB0cnVlIDogdW5kZWZpbmVkfVxuICAgIGFyaWEtbW9kYWw9e2lzT3BlbiA/IHRydWUgOiB1bmRlZmluZWR9XG4gICAgY2xhc3M9e2NsYXNzZXN9XG4gICAgcm9sZT17aXNPcGVuIHx8IGlzVHJhbnNpdGlvbmluZyA/ICdkaWFsb2cnIDogdW5kZWZpbmVkfVxuICAgIHN0eWxlPXtgdmlzaWJpbGl0eTogJHtpc09wZW4gfHwgaXNUcmFuc2l0aW9uaW5nID8gJ3Zpc2libGUnIDogJ2hpZGRlbid9OyR7c3R5bGV9YH1cbiAgICB0YWJpbmRleD1cIi0xXCJcbiAgPlxuICAgIHsjaWYgdG9nZ2xlIHx8IGhlYWRlciB8fCAkJHNsb3RzLmhlYWRlcn1cbiAgICAgIDxPZmZjYW52YXNIZWFkZXIge3RvZ2dsZX0+XG4gICAgICAgIHsjaWYgaGVhZGVyfXtoZWFkZXJ9ey9pZn1cbiAgICAgICAgPHNsb3QgbmFtZT1cImhlYWRlclwiIC8+XG4gICAgICA8L09mZmNhbnZhc0hlYWRlcj5cbiAgICB7L2lmfVxuICAgIHsjaWYgYm9keX1cbiAgICAgIDxPZmZjYW52YXNCb2R5PlxuICAgICAgICA8c2xvdCAvPlxuICAgICAgPC9PZmZjYW52YXNCb2R5PlxuICAgIHs6ZWxzZX1cbiAgICAgIDxzbG90IC8+XG4gICAgey9pZn1cbiAgPC9kaXY+XG4gIHsjaWYgYmFja2Ryb3B9XG4gICAgPE9mZmNhbnZhc0JhY2tkcm9wIG9uOmNsaWNrPXt0b2dnbGUgPyAoKSA9PiB0b2dnbGUoKSA6IHVuZGVmaW5lZH0ge2ZhZGV9IHtpc09wZW59IC8+XG4gIHsvaWZ9XG48L3N2ZWx0ZTpjb21wb25lbnQ+XG5cbjxzdHlsZT5cbiAgOmdsb2JhbCgub3ZlcmZsb3ctbm9zY3JvbGwpIHtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIHBhZGRpbmctcmlnaHQ6IDBweDtcbiAgfVxuPC9zdHlsZT5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFvSFUsa0JBQWtCLEFBQUUsQ0FBQyxBQUMzQixRQUFRLENBQUUsTUFBTSxDQUNoQixhQUFhLENBQUUsR0FBRyxBQUNwQixDQUFDIn0= */");
}
var get_header_slot_changes3 = (dirty) => ({});
var get_header_slot_context3 = (ctx) => ({});
function create_if_block_211(ctx) {
  let offcanvasheader;
  let current;
  offcanvasheader = new OffcanvasHeader_default({
    props: {
      toggle: ctx[6],
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(offcanvasheader.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(offcanvasheader, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const offcanvasheader_changes = {};
      if (dirty & 64)
        offcanvasheader_changes.toggle = ctx2[6];
      if (dirty & 268435472) {
        offcanvasheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      offcanvasheader.$set(offcanvasheader_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(offcanvasheader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(offcanvasheader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(offcanvasheader, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_211.name,
    type: "if",
    source: "(97:4) {#if toggle || header || $$slots.header}",
    ctx
  });
  return block;
}
function create_if_block_35(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[4]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 16)
        set_data_dev(t, ctx2[4]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_35.name,
    type: "if",
    source: "(99:8) {#if header}",
    ctx
  });
  return block;
}
function create_default_slot_22(ctx) {
  let t;
  let current;
  let if_block = ctx[4] && create_if_block_35(ctx);
  const header_slot_template = ctx[25].header;
  const header_slot = create_slot(header_slot_template, ctx, ctx[28], get_header_slot_context3);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      if (header_slot)
        header_slot.c();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, t, anchor);
      if (header_slot) {
        header_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_35(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (header_slot) {
        if (header_slot.p && (!current || dirty & 268435456)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            ctx2[28],
            !current ? get_all_dirty_from_scope(ctx2[28]) : get_slot_changes(header_slot_template, ctx2[28], dirty, get_header_slot_changes3),
            get_header_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22.name,
    type: "slot",
    source: "(98:6) <OffcanvasHeader {toggle}>",
    ctx
  });
  return block;
}
function create_else_block20(ctx) {
  let current;
  const default_slot_template = ctx[25].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[28], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[28],
            !current ? get_all_dirty_from_scope(ctx2[28]) : get_slot_changes(default_slot_template, ctx2[28], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block20.name,
    type: "else",
    source: "(107:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_115(ctx) {
  let offcanvasbody;
  let current;
  offcanvasbody = new OffcanvasBody_default({
    props: {
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(offcanvasbody.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(offcanvasbody, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const offcanvasbody_changes = {};
      if (dirty & 268435456) {
        offcanvasbody_changes.$$scope = { dirty, ctx: ctx2 };
      }
      offcanvasbody.$set(offcanvasbody_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(offcanvasbody.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(offcanvasbody.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(offcanvasbody, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_115.name,
    type: "if",
    source: "(103:4) {#if body}",
    ctx
  });
  return block;
}
function create_default_slot_14(ctx) {
  let current;
  const default_slot_template = ctx[25].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[28], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[28],
            !current ? get_all_dirty_from_scope(ctx2[28]) : get_slot_changes(default_slot_template, ctx2[28], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_14.name,
    type: "slot",
    source: "(104:6) <OffcanvasBody>",
    ctx
  });
  return block;
}
function create_if_block26(ctx) {
  let offcanvasbackdrop;
  let current;
  offcanvasbackdrop = new OffcanvasBackdrop_default({
    props: {
      fade: ctx[3],
      isOpen: ctx[0]
    },
    $$inline: true
  });
  offcanvasbackdrop.$on("click", function() {
    if (is_function(ctx[6] ? ctx[27] : void 0))
      (ctx[6] ? ctx[27] : void 0).apply(this, arguments);
  });
  const block = {
    c: function create() {
      create_component(offcanvasbackdrop.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(offcanvasbackdrop, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const offcanvasbackdrop_changes = {};
      if (dirty & 8)
        offcanvasbackdrop_changes.fade = ctx[3];
      if (dirty & 1)
        offcanvasbackdrop_changes.isOpen = ctx[0];
      offcanvasbackdrop.$set(offcanvasbackdrop_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(offcanvasbackdrop.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(offcanvasbackdrop.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(offcanvasbackdrop, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block26.name,
    type: "if",
    source: "(111:2) {#if backdrop}",
    ctx
  });
  return block;
}
function create_default_slot7(ctx) {
  let div;
  let t0;
  let current_block_type_index;
  let if_block1;
  let div_aria_hidden_value;
  let div_aria_modal_value;
  let div_role_value;
  let div_style_value;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = (ctx[6] || ctx[4] || ctx[13].header) && create_if_block_211(ctx);
  const if_block_creators = [create_if_block_115, create_else_block20];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [
    ctx[12],
    {
      "aria-hidden": div_aria_hidden_value = !ctx[0] ? true : void 0
    },
    {
      "aria-modal": div_aria_modal_value = ctx[0] ? true : void 0
    },
    { class: ctx[10] },
    {
      role: div_role_value = ctx[0] || ctx[7] ? "dialog" : void 0
    },
    {
      style: div_style_value = `visibility: ${ctx[0] || ctx[7] ? "visible" : "hidden"};${ctx[5]}`
    },
    { tabindex: "-1" }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  let if_block2 = ctx[1] && create_if_block26(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      set_attributes(div, div_data);
      add_location(div, file69, 86, 2, 2537);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      if_blocks[current_block_type_index].m(div, null);
      ctx[26](div);
      insert_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[6] || ctx2[4] || ctx2[13].header) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 8272) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_211(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 4096 && ctx2[12],
        (!current || dirty & 1 && div_aria_hidden_value !== (div_aria_hidden_value = !ctx2[0] ? true : void 0)) && { "aria-hidden": div_aria_hidden_value },
        (!current || dirty & 1 && div_aria_modal_value !== (div_aria_modal_value = ctx2[0] ? true : void 0)) && { "aria-modal": div_aria_modal_value },
        (!current || dirty & 1024) && { class: ctx2[10] },
        (!current || dirty & 129 && div_role_value !== (div_role_value = ctx2[0] || ctx2[7] ? "dialog" : void 0)) && { role: div_role_value },
        (!current || dirty & 161 && div_style_value !== (div_style_value = `visibility: ${ctx2[0] || ctx2[7] ? "visible" : "hidden"};${ctx2[5]}`)) && { style: div_style_value },
        { tabindex: "-1" }
      ]));
      if (ctx2[1]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block26(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      ctx[26](null);
      if (detaching)
        detach_dev(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: "(86:0) <svelte:component this={outer}>",
    ctx
  });
  return block;
}
function create_fragment70(ctx) {
  let t;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  let mounted;
  let dispose;
  var switch_value = ctx[9];
  function switch_props(ctx2) {
    return {
      props: {
        $$slots: { default: [create_default_slot7] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      t = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          document_1.body,
          "mousedown",
          function() {
            if (is_function(ctx[11]))
              ctx[11].apply(this, arguments);
          },
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty & 268449279) {
        switch_instance_changes.$$scope = { dirty, ctx };
      }
      if (switch_value !== (switch_value = ctx[9])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment70.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance70($$self, $$props, $$invalidate) {
  let handleMouseDown;
  let classes;
  let outer;
  const omit_props_names = [
    "class",
    "backdrop",
    "body",
    "container",
    "fade",
    "header",
    "isOpen",
    "placement",
    "scroll",
    "sm",
    "md",
    "lg",
    "xl",
    "xxl",
    "style",
    "toggle"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Offcanvas", slots, ["header", "default"]);
  const $$slots = compute_slots(slots);
  const dispatch = createEventDispatcher();
  let { class: className = "" } = $$props;
  let { backdrop = true } = $$props;
  let { body = true } = $$props;
  let { container = "body" } = $$props;
  let { fade: fade2 = true } = $$props;
  let { header = void 0 } = $$props;
  let { isOpen = false } = $$props;
  let { placement = "start" } = $$props;
  let { scroll = false } = $$props;
  let { sm = false } = $$props;
  let { md = false } = $$props;
  let { lg = false } = $$props;
  let { xl = false } = $$props;
  let { xxl = false } = $$props;
  let { style = "" } = $$props;
  let { toggle = void 0 } = $$props;
  let bodyElement;
  let isTransitioning = false;
  let element2;
  let removeEscListener;
  onMount(() => $$invalidate(23, bodyElement = document.body));
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(8, element2);
    });
  }
  const click_handler = () => toggle();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(14, className = $$new_props.class);
    if ("backdrop" in $$new_props)
      $$invalidate(1, backdrop = $$new_props.backdrop);
    if ("body" in $$new_props)
      $$invalidate(2, body = $$new_props.body);
    if ("container" in $$new_props)
      $$invalidate(15, container = $$new_props.container);
    if ("fade" in $$new_props)
      $$invalidate(3, fade2 = $$new_props.fade);
    if ("header" in $$new_props)
      $$invalidate(4, header = $$new_props.header);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("placement" in $$new_props)
      $$invalidate(16, placement = $$new_props.placement);
    if ("scroll" in $$new_props)
      $$invalidate(17, scroll = $$new_props.scroll);
    if ("sm" in $$new_props)
      $$invalidate(18, sm = $$new_props.sm);
    if ("md" in $$new_props)
      $$invalidate(19, md = $$new_props.md);
    if ("lg" in $$new_props)
      $$invalidate(20, lg = $$new_props.lg);
    if ("xl" in $$new_props)
      $$invalidate(21, xl = $$new_props.xl);
    if ("xxl" in $$new_props)
      $$invalidate(22, xxl = $$new_props.xxl);
    if ("style" in $$new_props)
      $$invalidate(5, style = $$new_props.style);
    if ("toggle" in $$new_props)
      $$invalidate(6, toggle = $$new_props.toggle);
    if ("$$scope" in $$new_props)
      $$invalidate(28, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    InlineContainer: InlineContainer_default,
    OffcanvasBackdrop: OffcanvasBackdrop_default,
    OffcanvasBody: OffcanvasBody_default,
    OffcanvasHeader: OffcanvasHeader_default,
    Portal: Portal_default,
    classnames,
    browserEvent,
    getTransitionDuration,
    dispatch,
    className,
    backdrop,
    body,
    container,
    fade: fade2,
    header,
    isOpen,
    placement,
    scroll,
    sm,
    md,
    lg,
    xl,
    xxl,
    style,
    toggle,
    bodyElement,
    isTransitioning,
    element: element2,
    removeEscListener,
    outer,
    classes,
    handleMouseDown
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(14, className = $$new_props.className);
    if ("backdrop" in $$props)
      $$invalidate(1, backdrop = $$new_props.backdrop);
    if ("body" in $$props)
      $$invalidate(2, body = $$new_props.body);
    if ("container" in $$props)
      $$invalidate(15, container = $$new_props.container);
    if ("fade" in $$props)
      $$invalidate(3, fade2 = $$new_props.fade);
    if ("header" in $$props)
      $$invalidate(4, header = $$new_props.header);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("placement" in $$props)
      $$invalidate(16, placement = $$new_props.placement);
    if ("scroll" in $$props)
      $$invalidate(17, scroll = $$new_props.scroll);
    if ("sm" in $$props)
      $$invalidate(18, sm = $$new_props.sm);
    if ("md" in $$props)
      $$invalidate(19, md = $$new_props.md);
    if ("lg" in $$props)
      $$invalidate(20, lg = $$new_props.lg);
    if ("xl" in $$props)
      $$invalidate(21, xl = $$new_props.xl);
    if ("xxl" in $$props)
      $$invalidate(22, xxl = $$new_props.xxl);
    if ("style" in $$props)
      $$invalidate(5, style = $$new_props.style);
    if ("toggle" in $$props)
      $$invalidate(6, toggle = $$new_props.toggle);
    if ("bodyElement" in $$props)
      $$invalidate(23, bodyElement = $$new_props.bodyElement);
    if ("isTransitioning" in $$props)
      $$invalidate(7, isTransitioning = $$new_props.isTransitioning);
    if ("element" in $$props)
      $$invalidate(8, element2 = $$new_props.element);
    if ("removeEscListener" in $$props)
      $$invalidate(24, removeEscListener = $$new_props.removeEscListener);
    if ("outer" in $$props)
      $$invalidate(9, outer = $$new_props.outer);
    if ("classes" in $$props)
      $$invalidate(10, classes = $$new_props.classes);
    if ("handleMouseDown" in $$props)
      $$invalidate(11, handleMouseDown = $$new_props.handleMouseDown);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 257) {
      $:
        if (element2) {
          $$invalidate(0, isOpen), $$invalidate(8, element2);
          $$invalidate(7, isTransitioning = true);
          dispatch(isOpen ? "opening" : "closing");
          setTimeout(
            () => {
              $$invalidate(7, isTransitioning = false);
              dispatch(isOpen ? "open" : "close");
            },
            getTransitionDuration(element2)
          );
        }
    }
    if ($$self.$$.dirty & 8519809) {
      $:
        if (bodyElement) {
          if (!scroll) {
            bodyElement.classList.toggle("overflow-noscroll", isOpen || isTransitioning);
          }
        }
    }
    if ($$self.$$.dirty & 65) {
      $:
        if (isOpen && toggle && typeof window !== "undefined") {
          $$invalidate(24, removeEscListener = browserEvent(document, "keydown", (event) => {
            if (event.key && event.key === "Escape")
              toggle();
          }));
        }
    }
    if ($$self.$$.dirty & 16777217) {
      $:
        if (!isOpen && removeEscListener) {
          removeEscListener();
        }
    }
    if ($$self.$$.dirty & 8388675) {
      $:
        $$invalidate(11, handleMouseDown = backdrop && toggle && bodyElement && isOpen ? (e) => {
          if (e.target === bodyElement) {
            toggle();
          }
        } : void 0);
    }
    if ($$self.$$.dirty & 8208385) {
      $:
        $$invalidate(10, classes = classnames(
          {
            offcanvas: !sm && !md && !lg && !xl && !xxl,
            "offcanvas-sm": sm,
            "offcanvas-md": md,
            "offcanvas-lg": lg,
            "offcanvas-xl": xl,
            "offcanvas-xxl": xxl,
            show: isOpen
          },
          `offcanvas-${placement}`,
          className
        ));
    }
    if ($$self.$$.dirty & 32768) {
      $:
        $$invalidate(9, outer = container === "inline" ? InlineContainer_default : Portal_default);
    }
  };
  return [
    isOpen,
    backdrop,
    body,
    fade2,
    header,
    style,
    toggle,
    isTransitioning,
    element2,
    outer,
    classes,
    handleMouseDown,
    $$restProps,
    $$slots,
    className,
    container,
    placement,
    scroll,
    sm,
    md,
    lg,
    xl,
    xxl,
    bodyElement,
    removeEscListener,
    slots,
    div_binding,
    click_handler,
    $$scope
  ];
}
var Offcanvas = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance70,
      create_fragment70,
      safe_not_equal,
      {
        class: 14,
        backdrop: 1,
        body: 2,
        container: 15,
        fade: 3,
        header: 4,
        isOpen: 0,
        placement: 16,
        scroll: 17,
        sm: 18,
        md: 19,
        lg: 20,
        xl: 21,
        xxl: 22,
        style: 5,
        toggle: 6
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Offcanvas",
      options,
      id: create_fragment70.name
    });
  }
  get class() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backdrop() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backdrop(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get body() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set body(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fade() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fade(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placement() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placement(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scroll() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scroll(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sm() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sm(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get md() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set md(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lg() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lg(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xl() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xl(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xxl() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xxl(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<Offcanvas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<Offcanvas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Offcanvas_default = Offcanvas;

// node_modules/sveltestrap/src/Pagination.svelte
var file70 = "node_modules/sveltestrap/src/Pagination.svelte";
function create_fragment71(ctx) {
  let nav;
  let ul;
  let current;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  let nav_levels = [
    ctx[3],
    { class: ctx[2] },
    { "aria-label": ctx[0] }
  ];
  let nav_data = {};
  for (let i = 0; i < nav_levels.length; i += 1) {
    nav_data = assign(nav_data, nav_levels[i]);
  }
  const block = {
    c: function create() {
      nav = element("nav");
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      attr_dev(ul, "class", ctx[1]);
      add_location(ul, file70, 17, 2, 414);
      set_attributes(nav, nav_data);
      add_location(nav, file70, 16, 0, 350);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, nav, anchor);
      append_dev(nav, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 2) {
        attr_dev(ul, "class", ctx2[1]);
      }
      set_attributes(nav, nav_data = get_spread_update(nav_levels, [
        dirty & 8 && ctx2[3],
        (!current || dirty & 4) && { class: ctx2[2] },
        (!current || dirty & 1) && { "aria-label": ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(nav);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment71.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance71($$self, $$props, $$invalidate) {
  let classes;
  let listClasses;
  const omit_props_names = ["class", "listClassName", "size", "ariaLabel"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pagination", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { listClassName = "" } = $$props;
  let { size = "" } = $$props;
  let { ariaLabel = "pagination" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("listClassName" in $$new_props)
      $$invalidate(5, listClassName = $$new_props.listClassName);
    if ("size" in $$new_props)
      $$invalidate(6, size = $$new_props.size);
    if ("ariaLabel" in $$new_props)
      $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    listClassName,
    size,
    ariaLabel,
    listClasses,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("listClassName" in $$props)
      $$invalidate(5, listClassName = $$new_props.listClassName);
    if ("size" in $$props)
      $$invalidate(6, size = $$new_props.size);
    if ("ariaLabel" in $$props)
      $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
    if ("listClasses" in $$props)
      $$invalidate(1, listClasses = $$new_props.listClasses);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      $:
        $$invalidate(2, classes = classnames(className));
    }
    if ($$self.$$.dirty & 96) {
      $:
        $$invalidate(1, listClasses = classnames(listClassName, "pagination", { [`pagination-${size}`]: !!size }));
    }
  };
  return [
    ariaLabel,
    listClasses,
    classes,
    $$restProps,
    className,
    listClassName,
    size,
    $$scope,
    slots
  ];
}
var Pagination = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance71, create_fragment71, safe_not_equal, {
      class: 4,
      listClassName: 5,
      size: 6,
      ariaLabel: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pagination",
      options,
      id: create_fragment71.name
    });
  }
  get class() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listClassName() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listClassName(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Pagination_default = Pagination;

// node_modules/sveltestrap/src/PaginationItem.svelte
var file71 = "node_modules/sveltestrap/src/PaginationItem.svelte";
function create_fragment72(ctx) {
  let li;
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  let li_levels = [ctx[1], { class: ctx[0] }];
  let li_data = {};
  for (let i = 0; i < li_levels.length; i += 1) {
    li_data = assign(li_data, li_levels[i]);
  }
  const block = {
    c: function create() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      set_attributes(li, li_data);
      add_location(li, file71, 14, 0, 256);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment72.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance72($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "active", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PaginationItem", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { disabled = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(3, active = $$new_props.active);
    if ("disabled" in $$new_props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    active,
    disabled,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(3, active = $$new_props.active);
    if ("disabled" in $$props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 28) {
      $:
        $$invalidate(0, classes = classnames(className, "page-item", { active, disabled }));
    }
  };
  return [classes, $$restProps, className, active, disabled, $$scope, slots];
}
var PaginationItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance72, create_fragment72, safe_not_equal, { class: 2, active: 3, disabled: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PaginationItem",
      options,
      id: create_fragment72.name
    });
  }
  get class() {
    throw new Error("<PaginationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PaginationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<PaginationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<PaginationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<PaginationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<PaginationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PaginationItem_default = PaginationItem;

// node_modules/sveltestrap/src/PaginationLink.svelte
var file72 = "node_modules/sveltestrap/src/PaginationLink.svelte";
function create_else_block21(ctx) {
  let current;
  const default_slot_template = ctx[13].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block21.name,
    type: "else",
    source: "(47:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block27(ctx) {
  let span0;
  let t0;
  let span1;
  let t1;
  let current;
  const default_slot_template = ctx[13].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
  const default_slot_or_fallback = default_slot || fallback_block7(ctx);
  const block = {
    c: function create() {
      span0 = element("span");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t0 = space();
      span1 = element("span");
      t1 = text(ctx[6]);
      attr_dev(span0, "aria-hidden", "true");
      add_location(span0, file72, 42, 4, 948);
      attr_dev(span1, "class", "visually-hidden");
      add_location(span1, file72, 45, 4, 1024);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span0, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(span0, null);
      }
      insert_dev(target, t0, anchor);
      insert_dev(target, span1, anchor);
      append_dev(span1, t1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 32)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & 64)
        set_data_dev(t1, ctx2[6]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span0);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(span1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block27.name,
    type: "if",
    source: "(42:2) {#if previous || next || first || last}",
    ctx
  });
  return block;
}
function fallback_block7(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[5]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 32)
        set_data_dev(t, ctx2[5]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block7.name,
    type: "fallback",
    source: "(44:12) {defaultCaret}",
    ctx
  });
  return block;
}
function create_fragment73(ctx) {
  let a;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block27, create_else_block21];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1] || ctx2[0] || ctx2[2] || ctx2[3])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let a_levels = [
    ctx[8],
    { class: ctx[7] },
    { href: ctx[4] }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if_block.c();
      set_attributes(a, a_data);
      add_location(a, file72, 40, 0, 849);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, a, anchor);
      if_blocks[current_block_type_index].m(a, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(a, "click", ctx[14], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(a, null);
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        dirty & 256 && ctx2[8],
        (!current || dirty & 128) && { class: ctx2[7] },
        (!current || dirty & 16) && { href: ctx2[4] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(a);
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment73.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance73($$self, $$props, $$invalidate) {
  let classes;
  let realLabel;
  const omit_props_names = ["class", "next", "previous", "first", "last", "ariaLabel", "href"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PaginationLink", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { next = false } = $$props;
  let { previous = false } = $$props;
  let { first = false } = $$props;
  let { last = false } = $$props;
  let { ariaLabel = "" } = $$props;
  let { href = "" } = $$props;
  let defaultAriaLabel;
  let defaultCaret;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(9, className = $$new_props.class);
    if ("next" in $$new_props)
      $$invalidate(0, next = $$new_props.next);
    if ("previous" in $$new_props)
      $$invalidate(1, previous = $$new_props.previous);
    if ("first" in $$new_props)
      $$invalidate(2, first = $$new_props.first);
    if ("last" in $$new_props)
      $$invalidate(3, last = $$new_props.last);
    if ("ariaLabel" in $$new_props)
      $$invalidate(10, ariaLabel = $$new_props.ariaLabel);
    if ("href" in $$new_props)
      $$invalidate(4, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    next,
    previous,
    first,
    last,
    ariaLabel,
    href,
    defaultAriaLabel,
    defaultCaret,
    realLabel,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(9, className = $$new_props.className);
    if ("next" in $$props)
      $$invalidate(0, next = $$new_props.next);
    if ("previous" in $$props)
      $$invalidate(1, previous = $$new_props.previous);
    if ("first" in $$props)
      $$invalidate(2, first = $$new_props.first);
    if ("last" in $$props)
      $$invalidate(3, last = $$new_props.last);
    if ("ariaLabel" in $$props)
      $$invalidate(10, ariaLabel = $$new_props.ariaLabel);
    if ("href" in $$props)
      $$invalidate(4, href = $$new_props.href);
    if ("defaultAriaLabel" in $$props)
      $$invalidate(11, defaultAriaLabel = $$new_props.defaultAriaLabel);
    if ("defaultCaret" in $$props)
      $$invalidate(5, defaultCaret = $$new_props.defaultCaret);
    if ("realLabel" in $$props)
      $$invalidate(6, realLabel = $$new_props.realLabel);
    if ("classes" in $$props)
      $$invalidate(7, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 512) {
      $:
        $$invalidate(7, classes = classnames(className, "page-link"));
    }
    if ($$self.$$.dirty & 15) {
      $:
        if (previous) {
          $$invalidate(11, defaultAriaLabel = "Previous");
        } else if (next) {
          $$invalidate(11, defaultAriaLabel = "Next");
        } else if (first) {
          $$invalidate(11, defaultAriaLabel = "First");
        } else if (last) {
          $$invalidate(11, defaultAriaLabel = "Last");
        }
    }
    if ($$self.$$.dirty & 3072) {
      $:
        $$invalidate(6, realLabel = ariaLabel || defaultAriaLabel);
    }
    if ($$self.$$.dirty & 15) {
      $:
        if (previous) {
          $$invalidate(5, defaultCaret = "\u2039");
        } else if (next) {
          $$invalidate(5, defaultCaret = "\u203A");
        } else if (first) {
          $$invalidate(5, defaultCaret = "\xAB");
        } else if (last) {
          $$invalidate(5, defaultCaret = "\xBB");
        }
    }
  };
  return [
    next,
    previous,
    first,
    last,
    href,
    defaultCaret,
    realLabel,
    classes,
    $$restProps,
    className,
    ariaLabel,
    defaultAriaLabel,
    $$scope,
    slots,
    click_handler
  ];
}
var PaginationLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance73, create_fragment73, safe_not_equal, {
      class: 9,
      next: 0,
      previous: 1,
      first: 2,
      last: 3,
      ariaLabel: 10,
      href: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PaginationLink",
      options,
      id: create_fragment73.name
    });
  }
  get class() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get next() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set next(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get previous() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set previous(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get first() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set first(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get last() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set last(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<PaginationLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<PaginationLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PaginationLink_default = PaginationLink;

// node_modules/sveltestrap/src/Popover.svelte
var { Error: Error_12 } = globals;
var file73 = "node_modules/sveltestrap/src/Popover.svelte";
var get_title_slot_changes = (dirty) => ({});
var get_title_slot_context = (ctx) => ({});
function create_if_block28(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[5];
  function switch_props(ctx2) {
    return {
      props: {
        $$slots: { default: [create_default_slot8] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & 1048798) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = ctx2[5])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block28.name,
    type: "if",
    source: "(115:0) {#if isOpen}",
    ctx
  });
  return block;
}
function fallback_block8(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[2]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4)
        set_data_dev(t, ctx2[2]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block8.name,
    type: "fallback",
    source: "(126:27) {title}",
    ctx
  });
  return block;
}
function create_else_block22(ctx) {
  let current;
  const default_slot_template = ctx[18].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[20], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(default_slot_template, ctx2[20], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block22.name,
    type: "else",
    source: "(131:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_116(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_116.name,
    type: "if",
    source: "(129:8) {#if children}",
    ctx
  });
  return block;
}
function create_default_slot8(ctx) {
  let div2;
  let div0;
  let t0;
  let h3;
  let t1;
  let div1;
  let current_block_type_index;
  let if_block;
  let current;
  const title_slot_template = ctx[18].title;
  const title_slot = create_slot(title_slot_template, ctx, ctx[20], get_title_slot_context);
  const title_slot_or_fallback = title_slot || fallback_block8(ctx);
  const if_block_creators = [create_if_block_116, create_else_block22];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div2_levels = [
    ctx[7],
    { class: ctx[6] },
    { role: "tooltip" },
    {
      "x-placement": ctx[4]
    }
  ];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      h3 = element("h3");
      if (title_slot_or_fallback)
        title_slot_or_fallback.c();
      t1 = space();
      div1 = element("div");
      if_block.c();
      attr_dev(div0, "class", "popover-arrow");
      attr_dev(div0, "data-popper-arrow", "");
      add_location(div0, file73, 123, 6, 3186);
      attr_dev(h3, "class", "popover-header");
      add_location(h3, file73, 124, 6, 3240);
      attr_dev(div1, "class", "popover-body");
      add_location(div1, file73, 127, 6, 3328);
      set_attributes(div2, div2_data);
      add_location(div2, file73, 116, 4, 3039);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div0);
      append_dev(div2, t0);
      append_dev(div2, h3);
      if (title_slot_or_fallback) {
        title_slot_or_fallback.m(h3, null);
      }
      append_dev(div2, t1);
      append_dev(div2, div1);
      if_blocks[current_block_type_index].m(div1, null);
      ctx[19](div2);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & 1048576)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(title_slot_template, ctx2[20], dirty, get_title_slot_changes),
            get_title_slot_context
          );
        }
      } else {
        if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty & 4)) {
          title_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div1, null);
      }
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [
        dirty & 128 && ctx2[7],
        (!current || dirty & 64) && { class: ctx2[6] },
        { role: "tooltip" },
        (!current || dirty & 16) && {
          "x-placement": ctx2[4]
        }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot_or_fallback, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot_or_fallback, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (title_slot_or_fallback)
        title_slot_or_fallback.d(detaching);
      if_blocks[current_block_type_index].d();
      ctx[19](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: "(116:2) <svelte:component this={outer}>",
    ctx
  });
  return block;
}
function create_fragment74(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block28(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error_12("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block28(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment74.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance74($$self, $$props, $$invalidate) {
  let classes;
  let outer;
  const omit_props_names = [
    "class",
    "animation",
    "children",
    "container",
    "dismissible",
    "isOpen",
    "placement",
    "target",
    "title",
    "trigger"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Popover", slots, ["title", "default"]);
  let { class: className = "" } = $$props;
  let { animation = true } = $$props;
  let { children = void 0 } = $$props;
  let { container = void 0 } = $$props;
  let { dismissible = false } = $$props;
  let { isOpen = false } = $$props;
  let { placement = "top" } = $$props;
  let { target = "" } = $$props;
  let { title = "" } = $$props;
  let { trigger = "click" } = $$props;
  let targetEl;
  let popoverEl;
  let popperInstance;
  let bsPlacement;
  let popperPlacement = placement;
  const checkPopperPlacement = {
    name: "checkPopperPlacement",
    enabled: true,
    phase: "main",
    fn({ state }) {
      $$invalidate(4, popperPlacement = state.placement);
    }
  };
  const open = () => $$invalidate(0, isOpen = true);
  const close = () => $$invalidate(0, isOpen = false);
  const toggle = () => $$invalidate(0, isOpen = !isOpen);
  onMount(() => {
    $$invalidate(15, targetEl = document.querySelector(`#${target}`));
    switch (trigger) {
      case "hover":
        targetEl.addEventListener("mouseover", open);
        targetEl.addEventListener("mouseleave", close);
        break;
      case "focus":
        targetEl.addEventListener("focus", open);
        targetEl.addEventListener("blur", close);
        break;
      default:
        targetEl.addEventListener("click", toggle);
        if (dismissible)
          targetEl.addEventListener("blur", close);
        break;
    }
    return () => {
      switch (trigger) {
        case "hover":
          targetEl.removeEventListener("mouseover", open);
          targetEl.removeEventListener("mouseleave", close);
          break;
        case "focus":
          targetEl.removeEventListener("focus", open);
          targetEl.removeEventListener("blur", close);
          break;
        default:
          targetEl.removeEventListener("click", toggle);
          if (dismissible)
            targetEl.removeEventListener("blur", close);
          break;
      }
    };
  });
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      popoverEl = $$value;
      $$invalidate(3, popoverEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(8, className = $$new_props.class);
    if ("animation" in $$new_props)
      $$invalidate(9, animation = $$new_props.animation);
    if ("children" in $$new_props)
      $$invalidate(1, children = $$new_props.children);
    if ("container" in $$new_props)
      $$invalidate(10, container = $$new_props.container);
    if ("dismissible" in $$new_props)
      $$invalidate(11, dismissible = $$new_props.dismissible);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("placement" in $$new_props)
      $$invalidate(12, placement = $$new_props.placement);
    if ("target" in $$new_props)
      $$invalidate(13, target = $$new_props.target);
    if ("title" in $$new_props)
      $$invalidate(2, title = $$new_props.title);
    if ("trigger" in $$new_props)
      $$invalidate(14, trigger = $$new_props.trigger);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    createPopper: createPopper3,
    classnames,
    InlineContainer: InlineContainer_default,
    Portal: Portal_default,
    className,
    animation,
    children,
    container,
    dismissible,
    isOpen,
    placement,
    target,
    title,
    trigger,
    targetEl,
    popoverEl,
    popperInstance,
    bsPlacement,
    popperPlacement,
    checkPopperPlacement,
    open,
    close,
    toggle,
    outer,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(8, className = $$new_props.className);
    if ("animation" in $$props)
      $$invalidate(9, animation = $$new_props.animation);
    if ("children" in $$props)
      $$invalidate(1, children = $$new_props.children);
    if ("container" in $$props)
      $$invalidate(10, container = $$new_props.container);
    if ("dismissible" in $$props)
      $$invalidate(11, dismissible = $$new_props.dismissible);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("placement" in $$props)
      $$invalidate(12, placement = $$new_props.placement);
    if ("target" in $$props)
      $$invalidate(13, target = $$new_props.target);
    if ("title" in $$props)
      $$invalidate(2, title = $$new_props.title);
    if ("trigger" in $$props)
      $$invalidate(14, trigger = $$new_props.trigger);
    if ("targetEl" in $$props)
      $$invalidate(15, targetEl = $$new_props.targetEl);
    if ("popoverEl" in $$props)
      $$invalidate(3, popoverEl = $$new_props.popoverEl);
    if ("popperInstance" in $$props)
      $$invalidate(16, popperInstance = $$new_props.popperInstance);
    if ("bsPlacement" in $$props)
      $$invalidate(17, bsPlacement = $$new_props.bsPlacement);
    if ("popperPlacement" in $$props)
      $$invalidate(4, popperPlacement = $$new_props.popperPlacement);
    if ("outer" in $$props)
      $$invalidate(5, outer = $$new_props.outer);
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 102409) {
      $: {
        if (isOpen && popoverEl) {
          $$invalidate(16, popperInstance = createPopper3(targetEl, popoverEl, {
            placement,
            modifiers: [
              checkPopperPlacement,
              {
                name: "offset",
                options: {
                  offset: () => {
                    return [0, 8];
                  }
                }
              }
            ]
          }));
        } else if (popperInstance) {
          popperInstance.destroy();
          $$invalidate(16, popperInstance = void 0);
        }
      }
    }
    if ($$self.$$.dirty & 8192) {
      $:
        if (!target) {
          throw new Error("Need target!");
        }
    }
    if ($$self.$$.dirty & 16) {
      $: {
        if (popperPlacement === "left")
          $$invalidate(17, bsPlacement = "start");
        else if (popperPlacement === "right")
          $$invalidate(17, bsPlacement = "end");
        else
          $$invalidate(17, bsPlacement = popperPlacement);
      }
    }
    if ($$self.$$.dirty & 131841) {
      $:
        $$invalidate(6, classes = classnames(className, "popover", animation ? "fade" : false, `bs-popover-${bsPlacement}`, isOpen ? "show" : false));
    }
    if ($$self.$$.dirty & 1024) {
      $:
        $$invalidate(5, outer = container === "inline" ? InlineContainer_default : Portal_default);
    }
  };
  return [
    isOpen,
    children,
    title,
    popoverEl,
    popperPlacement,
    outer,
    classes,
    $$restProps,
    className,
    animation,
    container,
    dismissible,
    placement,
    target,
    trigger,
    targetEl,
    popperInstance,
    bsPlacement,
    slots,
    div2_binding,
    $$scope
  ];
}
var Popover = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance74, create_fragment74, safe_not_equal, {
      class: 8,
      animation: 9,
      children: 1,
      container: 10,
      dismissible: 11,
      isOpen: 0,
      placement: 12,
      target: 13,
      title: 2,
      trigger: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Popover",
      options,
      id: create_fragment74.name
    });
  }
  get class() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animation() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animation(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dismissible() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dismissible(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placement() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placement(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get trigger() {
    throw new Error_12("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set trigger(value) {
    throw new Error_12("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Popover_default = Popover;

// node_modules/sveltestrap/src/Progress.svelte
var file74 = "node_modules/sveltestrap/src/Progress.svelte";
function create_else_block_14(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_212, create_else_block_23];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [ctx[7], { class: ctx[6] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      set_attributes(div, div_data);
      add_location(div, file74, 44, 2, 998);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 128 && ctx2[7],
        (!current || dirty & 64) && { class: ctx2[6] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_14.name,
    type: "else",
    source: "(44:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block29(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_117, create_else_block23];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block29.name,
    type: "if",
    source: "(28:0) {#if bar}",
    ctx
  });
  return block;
}
function create_else_block_23(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[14].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[13], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", ctx[5]);
      set_style(div, "width", ctx[4] + "%");
      attr_dev(div, "role", "progressbar");
      attr_dev(div, "aria-valuenow", ctx[2]);
      attr_dev(div, "aria-valuemin", "0");
      attr_dev(div, "aria-valuemax", ctx[3]);
      add_location(div, file74, 48, 6, 1086);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(default_slot_template, ctx2[13], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 32) {
        attr_dev(div, "class", ctx2[5]);
      }
      if (!current || dirty & 16) {
        set_style(div, "width", ctx2[4] + "%");
      }
      if (!current || dirty & 4) {
        attr_dev(div, "aria-valuenow", ctx2[2]);
      }
      if (!current || dirty & 8) {
        attr_dev(div, "aria-valuemax", ctx2[3]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_23.name,
    type: "else",
    source: "(48:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_212(ctx) {
  let current;
  const default_slot_template = ctx[14].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[13], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(default_slot_template, ctx2[13], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_212.name,
    type: "if",
    source: "(46:4) {#if multi}",
    ctx
  });
  return block;
}
function create_else_block23(ctx) {
  let div;
  let div_style_value;
  let current;
  const default_slot_template = ctx[14].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[13], null);
  let div_levels = [
    ctx[7],
    { class: ctx[5] },
    {
      style: div_style_value = "width: " + ctx[4] + "%"
    },
    { role: "progressbar" },
    { "aria-valuenow": ctx[2] },
    { "aria-valuemin": "0" },
    { "aria-valuemax": ctx[3] }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file74, 31, 4, 752);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(default_slot_template, ctx2[13], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 128 && ctx2[7],
        (!current || dirty & 32) && { class: ctx2[5] },
        (!current || dirty & 16 && div_style_value !== (div_style_value = "width: " + ctx2[4] + "%")) && { style: div_style_value },
        { role: "progressbar" },
        (!current || dirty & 4) && { "aria-valuenow": ctx2[2] },
        { "aria-valuemin": "0" },
        (!current || dirty & 8) && { "aria-valuemax": ctx2[3] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block23.name,
    type: "else",
    source: "(31:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_117(ctx) {
  let current;
  const default_slot_template = ctx[14].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[13], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(default_slot_template, ctx2[13], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_117.name,
    type: "if",
    source: "(29:2) {#if multi}",
    ctx
  });
  return block;
}
function create_fragment75(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block29, create_else_block_14];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment75.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance75($$self, $$props, $$invalidate) {
  let classes;
  let progressBarClasses;
  let percent;
  const omit_props_names = [
    "class",
    "bar",
    "multi",
    "value",
    "max",
    "animated",
    "striped",
    "color",
    "barClassName"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Progress", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { bar = false } = $$props;
  let { multi = false } = $$props;
  let { value = 0 } = $$props;
  let { max: max2 = 100 } = $$props;
  let { animated = false } = $$props;
  let { striped = false } = $$props;
  let { color = "" } = $$props;
  let { barClassName = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(8, className = $$new_props.class);
    if ("bar" in $$new_props)
      $$invalidate(0, bar = $$new_props.bar);
    if ("multi" in $$new_props)
      $$invalidate(1, multi = $$new_props.multi);
    if ("value" in $$new_props)
      $$invalidate(2, value = $$new_props.value);
    if ("max" in $$new_props)
      $$invalidate(3, max2 = $$new_props.max);
    if ("animated" in $$new_props)
      $$invalidate(9, animated = $$new_props.animated);
    if ("striped" in $$new_props)
      $$invalidate(10, striped = $$new_props.striped);
    if ("color" in $$new_props)
      $$invalidate(11, color = $$new_props.color);
    if ("barClassName" in $$new_props)
      $$invalidate(12, barClassName = $$new_props.barClassName);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    bar,
    multi,
    value,
    max: max2,
    animated,
    striped,
    color,
    barClassName,
    percent,
    progressBarClasses,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(8, className = $$new_props.className);
    if ("bar" in $$props)
      $$invalidate(0, bar = $$new_props.bar);
    if ("multi" in $$props)
      $$invalidate(1, multi = $$new_props.multi);
    if ("value" in $$props)
      $$invalidate(2, value = $$new_props.value);
    if ("max" in $$props)
      $$invalidate(3, max2 = $$new_props.max);
    if ("animated" in $$props)
      $$invalidate(9, animated = $$new_props.animated);
    if ("striped" in $$props)
      $$invalidate(10, striped = $$new_props.striped);
    if ("color" in $$props)
      $$invalidate(11, color = $$new_props.color);
    if ("barClassName" in $$props)
      $$invalidate(12, barClassName = $$new_props.barClassName);
    if ("percent" in $$props)
      $$invalidate(4, percent = $$new_props.percent);
    if ("progressBarClasses" in $$props)
      $$invalidate(5, progressBarClasses = $$new_props.progressBarClasses);
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 256) {
      $:
        $$invalidate(6, classes = classnames(className, "progress"));
    }
    if ($$self.$$.dirty & 7937) {
      $:
        $$invalidate(5, progressBarClasses = classnames("progress-bar", bar ? className || barClassName : barClassName, animated ? "progress-bar-animated" : null, color ? `bg-${color}` : null, striped || animated ? "progress-bar-striped" : null));
    }
    if ($$self.$$.dirty & 12) {
      $:
        $$invalidate(4, percent = parseInt(value, 10) / parseInt(max2, 10) * 100);
    }
  };
  return [
    bar,
    multi,
    value,
    max2,
    percent,
    progressBarClasses,
    classes,
    $$restProps,
    className,
    animated,
    striped,
    color,
    barClassName,
    $$scope,
    slots
  ];
}
var Progress = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance75, create_fragment75, safe_not_equal, {
      class: 8,
      bar: 0,
      multi: 1,
      value: 2,
      max: 3,
      animated: 9,
      striped: 10,
      color: 11,
      barClassName: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Progress",
      options,
      id: create_fragment75.name
    });
  }
  get class() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bar() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bar(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multi() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multi(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animated() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animated(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get striped() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set striped(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get barClassName() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set barClassName(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Progress_default = Progress;

// node_modules/sveltestrap/src/Row.svelte
var file75 = "node_modules/sveltestrap/src/Row.svelte";
function create_fragment76(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  let div_levels = [ctx[2], { class: ctx[1] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file75, 40, 0, 1012);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[9](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 4 && ctx2[2],
        (!current || dirty & 2) && { class: ctx2[1] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[9](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment76.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getCols(cols) {
  const colsValue = parseInt(cols);
  if (!isNaN(colsValue)) {
    if (colsValue > 0) {
      return [`row-cols-${colsValue}`];
    }
  } else if (typeof cols === "object") {
    return ["xs", "sm", "md", "lg", "xl"].map((colWidth) => {
      const isXs = colWidth === "xs";
      const colSizeInterfix = isXs ? "-" : `-${colWidth}-`;
      const value = cols[colWidth];
      if (typeof value === "number" && value > 0) {
        return `row-cols${colSizeInterfix}${value}`;
      }
      return null;
    }).filter((value) => !!value);
  }
  return [];
}
function instance76($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "noGutters", "form", "cols", "inner"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Row", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { noGutters = false } = $$props;
  let { form = false } = $$props;
  let { cols = 0 } = $$props;
  let { inner = void 0 } = $$props;
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inner = $$value;
      $$invalidate(0, inner);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("noGutters" in $$new_props)
      $$invalidate(4, noGutters = $$new_props.noGutters);
    if ("form" in $$new_props)
      $$invalidate(5, form = $$new_props.form);
    if ("cols" in $$new_props)
      $$invalidate(6, cols = $$new_props.cols);
    if ("inner" in $$new_props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    noGutters,
    form,
    cols,
    inner,
    getCols,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("noGutters" in $$props)
      $$invalidate(4, noGutters = $$new_props.noGutters);
    if ("form" in $$props)
      $$invalidate(5, form = $$new_props.form);
    if ("cols" in $$props)
      $$invalidate(6, cols = $$new_props.cols);
    if ("inner" in $$props)
      $$invalidate(0, inner = $$new_props.inner);
    if ("classes" in $$props)
      $$invalidate(1, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 120) {
      $:
        $$invalidate(1, classes = classnames(className, noGutters ? "gx-0" : null, form ? "form-row" : "row", ...getCols(cols)));
    }
  };
  return [
    inner,
    classes,
    $$restProps,
    className,
    noGutters,
    form,
    cols,
    $$scope,
    slots,
    div_binding
  ];
}
var Row = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance76, create_fragment76, safe_not_equal, {
      class: 3,
      noGutters: 4,
      form: 5,
      cols: 6,
      inner: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Row",
      options,
      id: create_fragment76.name
    });
  }
  get class() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noGutters() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noGutters(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get form() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set form(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cols() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cols(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inner() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inner(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Row_default = Row;

// node_modules/sveltestrap/src/Spinner.svelte
var file76 = "node_modules/sveltestrap/src/Spinner.svelte";
function fallback_block9(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Loading...");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block9.name,
    type: "fallback",
    source: "(20:10) Loading...",
    ctx
  });
  return block;
}
function create_fragment77(ctx) {
  let div;
  let span;
  let current;
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  const default_slot_or_fallback = default_slot || fallback_block9(ctx);
  let div_levels = [ctx[1], { role: "status" }, { class: ctx[0] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      attr_dev(span, "class", "visually-hidden");
      add_location(span, file76, 18, 2, 399);
      set_attributes(div, div_data);
      add_location(div, file76, 17, 0, 344);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, span);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 2 && ctx2[1],
        { role: "status" },
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment77.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance77($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "type", "size", "color"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Spinner", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { type = "border" } = $$props;
  let { size = "" } = $$props;
  let { color = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("type" in $$new_props)
      $$invalidate(3, type = $$new_props.type);
    if ("size" in $$new_props)
      $$invalidate(4, size = $$new_props.size);
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    type,
    size,
    color,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("type" in $$props)
      $$invalidate(3, type = $$new_props.type);
    if ("size" in $$props)
      $$invalidate(4, size = $$new_props.size);
    if ("color" in $$props)
      $$invalidate(5, color = $$new_props.color);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 60) {
      $:
        $$invalidate(0, classes = classnames(className, size ? `spinner-${type}-${size}` : false, `spinner-${type}`, color ? `text-${color}` : false));
    }
  };
  return [classes, $$restProps, className, type, size, color, $$scope, slots];
}
var Spinner = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance77, create_fragment77, safe_not_equal, { class: 2, type: 3, size: 4, color: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Spinner",
      options,
      id: create_fragment77.name
    });
  }
  get class() {
    throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Spinner_default = Spinner;

// node_modules/sveltestrap/src/Styles.svelte
var file77 = "node_modules/sveltestrap/src/Styles.svelte";
function create_if_block30(ctx) {
  let link;
  const block = {
    c: function create() {
      link = element("link");
      attr_dev(link, "rel", "stylesheet");
      attr_dev(link, "href", "https://cdn.jsdelivr.net/npm/bootstrap-icons@1.9.1/font/bootstrap-icons.css");
      add_location(link, file77, 10, 4, 196);
    },
    m: function mount(target, anchor) {
      insert_dev(target, link, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(link);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block30.name,
    type: "if",
    source: "(10:2) {#if icons}",
    ctx
  });
  return block;
}
function create_fragment78(ctx) {
  let link;
  let if_block_anchor;
  let if_block = ctx[0] && create_if_block30(ctx);
  const block = {
    c: function create() {
      link = element("link");
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr_dev(link, "rel", "stylesheet");
      attr_dev(link, "href", "https://cdn.jsdelivr.net/npm/bootstrap@5.2.1/dist/css/bootstrap.min.css");
      add_location(link, file77, 5, 2, 63);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      append_dev(document.head, link);
      if (if_block)
        if_block.m(document.head, null);
      append_dev(document.head, if_block_anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
        } else {
          if_block = create_if_block30(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      detach_dev(link);
      if (if_block)
        if_block.d(detaching);
      detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment78.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance78($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Styles", slots, []);
  let { icons = true } = $$props;
  const writable_props = ["icons"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Styles> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("icons" in $$props2)
      $$invalidate(0, icons = $$props2.icons);
  };
  $$self.$capture_state = () => ({ icons });
  $$self.$inject_state = ($$props2) => {
    if ("icons" in $$props2)
      $$invalidate(0, icons = $$props2.icons);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [icons];
}
var Styles = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance78, create_fragment78, safe_not_equal, { icons: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Styles",
      options,
      id: create_fragment78.name
    });
  }
  get icons() {
    throw new Error("<Styles>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icons(value) {
    throw new Error("<Styles>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Styles_default = Styles;

// node_modules/sveltestrap/src/Colgroup.svelte
var file78 = "node_modules/sveltestrap/src/Colgroup.svelte";
function create_fragment79(ctx) {
  let colgroup;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  const block = {
    c: function create() {
      colgroup = element("colgroup");
      if (default_slot)
        default_slot.c();
      add_location(colgroup, file78, 6, 0, 92);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, colgroup, anchor);
      if (default_slot) {
        default_slot.m(colgroup, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[0],
            !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(colgroup);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment79.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance79($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Colgroup", slots, ["default"]);
  setContext("colgroup", true);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Colgroup> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ setContext });
  return [$$scope, slots];
}
var Colgroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance79, create_fragment79, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Colgroup",
      options,
      id: create_fragment79.name
    });
  }
};
var Colgroup_default = Colgroup;

// node_modules/sveltestrap/src/ResponsiveContainer.svelte
var file79 = "node_modules/sveltestrap/src/ResponsiveContainer.svelte";
function create_else_block24(ctx) {
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block24.name,
    type: "else",
    source: "(15:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block31(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", ctx[1]);
      add_location(div, file79, 13, 2, 305);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 2) {
        attr_dev(div, "class", ctx2[1]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block31.name,
    type: "if",
    source: "(13:0) {#if responsive}",
    ctx
  });
  return block;
}
function create_fragment80(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block31, create_else_block24];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment80.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance80($$self, $$props, $$invalidate) {
  let responsiveClassName;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ResponsiveContainer", slots, ["default"]);
  let className = "";
  let { responsive = false } = $$props;
  const writable_props = ["responsive"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ResponsiveContainer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("responsive" in $$props2)
      $$invalidate(0, responsive = $$props2.responsive);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    className,
    responsive,
    responsiveClassName
  });
  $$self.$inject_state = ($$props2) => {
    if ("className" in $$props2)
      $$invalidate(4, className = $$props2.className);
    if ("responsive" in $$props2)
      $$invalidate(0, responsive = $$props2.responsive);
    if ("responsiveClassName" in $$props2)
      $$invalidate(1, responsiveClassName = $$props2.responsiveClassName);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(1, responsiveClassName = classnames(className, {
          "table-responsive": responsive === true,
          [`table-responsive-${responsive}`]: typeof responsive === "string"
        }));
    }
  };
  return [responsive, responsiveClassName, $$scope, slots];
}
var ResponsiveContainer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance80, create_fragment80, safe_not_equal, { responsive: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ResponsiveContainer",
      options,
      id: create_fragment80.name
    });
  }
  get responsive() {
    throw new Error("<ResponsiveContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set responsive(value) {
    throw new Error("<ResponsiveContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ResponsiveContainer_default = ResponsiveContainer;

// node_modules/sveltestrap/src/TableFooter.svelte
var file80 = "node_modules/sveltestrap/src/TableFooter.svelte";
function create_fragment81(ctx) {
  let tfoot;
  let tr;
  let current;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  let tfoot_levels = [ctx[0]];
  let tfoot_data = {};
  for (let i = 0; i < tfoot_levels.length; i += 1) {
    tfoot_data = assign(tfoot_data, tfoot_levels[i]);
  }
  const block = {
    c: function create() {
      tfoot = element("tfoot");
      tr = element("tr");
      if (default_slot)
        default_slot.c();
      add_location(tr, file80, 7, 2, 117);
      set_attributes(tfoot, tfoot_data);
      add_location(tfoot, file80, 6, 0, 90);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, tfoot, anchor);
      append_dev(tfoot, tr);
      if (default_slot) {
        default_slot.m(tr, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null),
            null
          );
        }
      }
      set_attributes(tfoot, tfoot_data = get_spread_update(tfoot_levels, [dirty & 1 && ctx2[0]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tfoot);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment81.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance81($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableFooter", slots, ["default"]);
  setContext("footer", true);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ setContext });
  return [$$restProps, $$scope, slots];
}
var TableFooter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance81, create_fragment81, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableFooter",
      options,
      id: create_fragment81.name
    });
  }
};
var TableFooter_default = TableFooter;

// node_modules/sveltestrap/src/TableHeader.svelte
var file81 = "node_modules/sveltestrap/src/TableHeader.svelte";
function create_fragment82(ctx) {
  let thead;
  let tr;
  let current;
  const default_slot_template = ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[1], null);
  let thead_levels = [ctx[0]];
  let thead_data = {};
  for (let i = 0; i < thead_levels.length; i += 1) {
    thead_data = assign(thead_data, thead_levels[i]);
  }
  const block = {
    c: function create() {
      thead = element("thead");
      tr = element("tr");
      if (default_slot)
        default_slot.c();
      add_location(tr, file81, 7, 2, 117);
      set_attributes(thead, thead_data);
      add_location(thead, file81, 6, 0, 90);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, thead, anchor);
      append_dev(thead, tr);
      if (default_slot) {
        default_slot.m(tr, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[1],
            !current ? get_all_dirty_from_scope(ctx2[1]) : get_slot_changes(default_slot_template, ctx2[1], dirty, null),
            null
          );
        }
      }
      set_attributes(thead, thead_data = get_spread_update(thead_levels, [dirty & 1 && ctx2[0]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(thead);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment82.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance82($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableHeader", slots, ["default"]);
  setContext("header", true);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ setContext });
  return [$$restProps, $$scope, slots];
}
var TableHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance82, create_fragment82, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableHeader",
      options,
      id: create_fragment82.name
    });
  }
};
var TableHeader_default = TableHeader;

// node_modules/sveltestrap/src/Table.svelte
var file82 = "node_modules/sveltestrap/src/Table.svelte";
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
var get_default_slot_changes_1 = (dirty) => ({ row: dirty & 2 });
var get_default_slot_context_1 = (ctx) => ({ row: ctx[13] });
var get_default_slot_changes = (dirty) => ({ row: dirty & 2 });
var get_default_slot_context = (ctx) => ({ row: ctx[13] });
function create_else_block25(ctx) {
  let current;
  const default_slot_template = ctx[11].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block25.name,
    type: "else",
    source: "(50:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block32(ctx) {
  let colgroup;
  let t0;
  let tableheader;
  let t1;
  let tbody;
  let t2;
  let tablefooter;
  let current;
  colgroup = new Colgroup_default({
    props: {
      $$slots: { default: [create_default_slot_32] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  tableheader = new TableHeader_default({
    props: {
      $$slots: { default: [create_default_slot_23] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let each_value = ctx[1];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  tablefooter = new TableFooter_default({
    props: {
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(colgroup.$$.fragment);
      t0 = space();
      create_component(tableheader.$$.fragment);
      t1 = space();
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      create_component(tablefooter.$$.fragment);
      add_location(tbody, file82, 39, 6, 1057);
    },
    m: function mount(target, anchor) {
      mount_component(colgroup, target, anchor);
      insert_dev(target, t0, anchor);
      mount_component(tableheader, target, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, tbody, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(tbody, null);
      }
      insert_dev(target, t2, anchor);
      mount_component(tablefooter, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const colgroup_changes = {};
      if (dirty & 4096) {
        colgroup_changes.$$scope = { dirty, ctx: ctx2 };
      }
      colgroup.$set(colgroup_changes);
      const tableheader_changes = {};
      if (dirty & 4098) {
        tableheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tableheader.$set(tableheader_changes);
      if (dirty & 4098) {
        each_value = ctx2[1];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(tbody, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      const tablefooter_changes = {};
      if (dirty & 4096) {
        tablefooter_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablefooter.$set(tablefooter_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(colgroup.$$.fragment, local);
      transition_in(tableheader.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(tablefooter.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(colgroup.$$.fragment, local);
      transition_out(tableheader.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(tablefooter.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(colgroup, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(tableheader, detaching);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(tbody);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(t2);
      destroy_component(tablefooter, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block32.name,
    type: "if",
    source: "(33:4) {#if rows}",
    ctx
  });
  return block;
}
function create_default_slot_32(ctx) {
  let current;
  const default_slot_template = ctx[11].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_32.name,
    type: "slot",
    source: "(34:6) <Colgroup>",
    ctx
  });
  return block;
}
function create_default_slot_23(ctx) {
  let current;
  const default_slot_template = ctx[11].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], get_default_slot_context);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4098)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, get_default_slot_changes),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_23.name,
    type: "slot",
    source: "(37:6) <TableHeader>",
    ctx
  });
  return block;
}
function create_each_block3(ctx) {
  let tr;
  let t;
  let current;
  const default_slot_template = ctx[11].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], get_default_slot_context_1);
  const block = {
    c: function create() {
      tr = element("tr");
      if (default_slot)
        default_slot.c();
      t = space();
      add_location(tr, file82, 41, 10, 1103);
    },
    m: function mount(target, anchor) {
      insert_dev(target, tr, anchor);
      if (default_slot) {
        default_slot.m(tr, null);
      }
      append_dev(tr, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4098)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, get_default_slot_changes_1),
            get_default_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(41:8) {#each rows as row}",
    ctx
  });
  return block;
}
function create_default_slot_15(ctx) {
  let current;
  const default_slot_template = ctx[11].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_15.name,
    type: "slot",
    source: "(47:6) <TableFooter>",
    ctx
  });
  return block;
}
function create_default_slot9(ctx) {
  let table;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block32, create_else_block25];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let table_levels = [ctx[3], { class: ctx[2] }];
  let table_data = {};
  for (let i = 0; i < table_levels.length; i += 1) {
    table_data = assign(table_data, table_levels[i]);
  }
  const block = {
    c: function create() {
      table = element("table");
      if_block.c();
      set_attributes(table, table_data);
      add_location(table, file82, 31, 2, 885);
    },
    m: function mount(target, anchor) {
      insert_dev(target, table, anchor);
      if_blocks[current_block_type_index].m(table, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(table, null);
      }
      set_attributes(table, table_data = get_spread_update(table_levels, [
        dirty & 8 && ctx2[3],
        (!current || dirty & 4) && { class: ctx2[2] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(table);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: "(31:0) <ResponsiveContainer {responsive}>",
    ctx
  });
  return block;
}
function create_fragment83(ctx) {
  let responsivecontainer;
  let current;
  responsivecontainer = new ResponsiveContainer_default({
    props: {
      responsive: ctx[0],
      $$slots: { default: [create_default_slot9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(responsivecontainer.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(responsivecontainer, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const responsivecontainer_changes = {};
      if (dirty & 1)
        responsivecontainer_changes.responsive = ctx2[0];
      if (dirty & 4110) {
        responsivecontainer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      responsivecontainer.$set(responsivecontainer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(responsivecontainer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(responsivecontainer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(responsivecontainer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment83.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance83($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = [
    "class",
    "size",
    "bordered",
    "borderless",
    "striped",
    "dark",
    "hover",
    "responsive",
    "rows"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { size = "" } = $$props;
  let { bordered = false } = $$props;
  let { borderless = false } = $$props;
  let { striped = false } = $$props;
  let { dark = false } = $$props;
  let { hover = false } = $$props;
  let { responsive = false } = $$props;
  let { rows = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("size" in $$new_props)
      $$invalidate(5, size = $$new_props.size);
    if ("bordered" in $$new_props)
      $$invalidate(6, bordered = $$new_props.bordered);
    if ("borderless" in $$new_props)
      $$invalidate(7, borderless = $$new_props.borderless);
    if ("striped" in $$new_props)
      $$invalidate(8, striped = $$new_props.striped);
    if ("dark" in $$new_props)
      $$invalidate(9, dark = $$new_props.dark);
    if ("hover" in $$new_props)
      $$invalidate(10, hover = $$new_props.hover);
    if ("responsive" in $$new_props)
      $$invalidate(0, responsive = $$new_props.responsive);
    if ("rows" in $$new_props)
      $$invalidate(1, rows = $$new_props.rows);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    Colgroup: Colgroup_default,
    ResponsiveContainer: ResponsiveContainer_default,
    TableFooter: TableFooter_default,
    TableHeader: TableHeader_default,
    className,
    size,
    bordered,
    borderless,
    striped,
    dark,
    hover,
    responsive,
    rows,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("size" in $$props)
      $$invalidate(5, size = $$new_props.size);
    if ("bordered" in $$props)
      $$invalidate(6, bordered = $$new_props.bordered);
    if ("borderless" in $$props)
      $$invalidate(7, borderless = $$new_props.borderless);
    if ("striped" in $$props)
      $$invalidate(8, striped = $$new_props.striped);
    if ("dark" in $$props)
      $$invalidate(9, dark = $$new_props.dark);
    if ("hover" in $$props)
      $$invalidate(10, hover = $$new_props.hover);
    if ("responsive" in $$props)
      $$invalidate(0, responsive = $$new_props.responsive);
    if ("rows" in $$props)
      $$invalidate(1, rows = $$new_props.rows);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2032) {
      $:
        $$invalidate(2, classes = classnames(className, "table", size ? "table-" + size : false, bordered ? "table-bordered" : false, borderless ? "table-borderless" : false, striped ? "table-striped" : false, dark ? "table-dark" : false, hover ? "table-hover" : false));
    }
  };
  return [
    responsive,
    rows,
    classes,
    $$restProps,
    className,
    size,
    bordered,
    borderless,
    striped,
    dark,
    hover,
    slots,
    $$scope
  ];
}
var Table = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance83, create_fragment83, safe_not_equal, {
      class: 4,
      size: 5,
      bordered: 6,
      borderless: 7,
      striped: 8,
      dark: 9,
      hover: 10,
      responsive: 0,
      rows: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table",
      options,
      id: create_fragment83.name
    });
  }
  get class() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bordered() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bordered(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderless() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderless(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get striped() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set striped(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dark() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dark(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get responsive() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set responsive(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rows() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rows(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Table_default = Table;

// node_modules/sveltestrap/src/TabHeader.svelte
function create_default_slot10(ctx) {
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: "(8:0) <Nav {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment84(ctx) {
  let nav;
  let current;
  const nav_spread_levels = [ctx[0]];
  let nav_props = {
    $$slots: { default: [create_default_slot10] },
    $$scope: { ctx }
  };
  for (let i = 0; i < nav_spread_levels.length; i += 1) {
    nav_props = assign(nav_props, nav_spread_levels[i]);
  }
  nav = new Nav_default({ props: nav_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(nav.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(nav, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const nav_changes = dirty & 1 ? get_spread_update(nav_spread_levels, [get_spread_object(ctx2[0])]) : {};
      if (dirty & 4) {
        nav_changes.$$scope = { dirty, ctx: ctx2 };
      }
      nav.$set(nav_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(nav.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(nav.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(nav, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment84.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance84($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabHeader", slots, ["default"]);
  setContext("tabs", true);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ setContext, Nav: Nav_default });
  return [$$restProps, slots, $$scope];
}
var TabHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance84, create_fragment84, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabHeader",
      options,
      id: create_fragment84.name
    });
  }
};
var TabHeader_default = TabHeader;

// node_modules/sveltestrap/src/TabContent.svelte
var file83 = "node_modules/sveltestrap/src/TabContent.svelte";
function create_default_slot11(ctx) {
  let current;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: "(29:2) <TabHeader     class={classnames({ 'me-3': vertical })}     {pills}     tabs={!pills}     {vertical}   >",
    ctx
  });
  return block;
}
function create_fragment85(ctx) {
  let div;
  let tabheader;
  let t;
  let current;
  tabheader = new TabHeader_default({
    props: {
      class: classnames({ "me-3": ctx[1] }),
      pills: ctx[0],
      tabs: !ctx[0],
      vertical: ctx[1],
      $$slots: { default: [create_default_slot11] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  let div_levels = [ctx[3], { class: ctx[2] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      create_component(tabheader.$$.fragment);
      t = space();
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file83, 27, 0, 653);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(tabheader, div, null);
      append_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const tabheader_changes = {};
      if (dirty & 2)
        tabheader_changes.class = classnames({ "me-3": ctx2[1] });
      if (dirty & 1)
        tabheader_changes.pills = ctx2[0];
      if (dirty & 1)
        tabheader_changes.tabs = !ctx2[0];
      if (dirty & 2)
        tabheader_changes.vertical = ctx2[1];
      if (dirty & 64) {
        tabheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabheader.$set(tabheader_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 8 && ctx2[3],
        (!current || dirty & 4) && { class: ctx2[2] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabheader.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabheader.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(tabheader);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment85.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance85($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "pills", "vertical"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabContent", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { class: className = "" } = $$props;
  let { pills = false } = $$props;
  let { vertical = false } = $$props;
  const activeTabId = writable();
  setContext("tabContent", {
    activeTabId,
    setActiveTab: (tabId) => {
      activeTabId.set(tabId);
      dispatch("tab", tabId);
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("pills" in $$new_props)
      $$invalidate(0, pills = $$new_props.pills);
    if ("vertical" in $$new_props)
      $$invalidate(1, vertical = $$new_props.vertical);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    setContext,
    writable,
    classnames,
    TabHeader: TabHeader_default,
    dispatch,
    className,
    pills,
    vertical,
    activeTabId,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("pills" in $$props)
      $$invalidate(0, pills = $$new_props.pills);
    if ("vertical" in $$props)
      $$invalidate(1, vertical = $$new_props.vertical);
    if ("classes" in $$props)
      $$invalidate(2, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 18) {
      $:
        $$invalidate(2, classes = classnames("tab-content", className, { "d-flex align-items-start": vertical }));
    }
  };
  return [pills, vertical, classes, $$restProps, className, slots, $$scope];
}
var TabContent = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance85, create_fragment85, safe_not_equal, { class: 4, pills: 0, vertical: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabContent",
      options,
      id: create_fragment85.name
    });
  }
  get class() {
    throw new Error("<TabContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TabContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pills() {
    throw new Error("<TabContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pills(value) {
    throw new Error("<TabContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertical() {
    throw new Error("<TabContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<TabContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabContent_default = TabContent;

// node_modules/sveltestrap/src/TabPane.svelte
var file84 = "node_modules/sveltestrap/src/TabPane.svelte";
var get_tab_slot_changes = (dirty) => ({});
var get_tab_slot_context = (ctx) => ({});
function create_else_block26(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[14], null);
  let div_levels = [ctx[8], { class: ctx[4] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file84, 36, 2, 914);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(default_slot_template, ctx2[14], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 256 && ctx2[8],
        (!current || dirty & 16) && { class: ctx2[4] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block26.name,
    type: "else",
    source: "(36:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block33(ctx) {
  let navitem;
  let current;
  navitem = new NavItem_default({
    props: {
      $$slots: { default: [create_default_slot12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(navitem.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(navitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const navitem_changes = {};
      if (dirty & 16399) {
        navitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navitem.$set(navitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(navitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block33.name,
    type: "if",
    source: "(29:0) {#if tabs}",
    ctx
  });
  return block;
}
function create_if_block_118(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_118.name,
    type: "if",
    source: "(32:6) {#if tab}",
    ctx
  });
  return block;
}
function create_default_slot_16(ctx) {
  let t;
  let current;
  let if_block = ctx[1] && create_if_block_118(ctx);
  const tab_slot_template = ctx[12].tab;
  const tab_slot = create_slot(tab_slot_template, ctx, ctx[14], get_tab_slot_context);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      if (tab_slot)
        tab_slot.c();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, t, anchor);
      if (tab_slot) {
        tab_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_118(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (tab_slot) {
        if (tab_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            tab_slot,
            tab_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(tab_slot_template, ctx2[14], dirty, get_tab_slot_changes),
            get_tab_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tab_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tab_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t);
      if (tab_slot)
        tab_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_16.name,
    type: "slot",
    source: "(31:4) <NavLink active={tabOpen} {disabled} on:click={() => setActiveTab(tabId)}>",
    ctx
  });
  return block;
}
function create_default_slot12(ctx) {
  let navlink;
  let current;
  navlink = new NavLink_default({
    props: {
      active: ctx[3],
      disabled: ctx[0],
      $$slots: { default: [create_default_slot_16] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  navlink.$on("click", ctx[13]);
  const block = {
    c: function create() {
      create_component(navlink.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(navlink, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const navlink_changes = {};
      if (dirty & 8)
        navlink_changes.active = ctx2[3];
      if (dirty & 1)
        navlink_changes.disabled = ctx2[0];
      if (dirty & 16386) {
        navlink_changes.$$scope = { dirty, ctx: ctx2 };
      }
      navlink.$set(navlink_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navlink.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navlink.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(navlink, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: "(30:2) <NavItem>",
    ctx
  });
  return block;
}
function create_fragment86(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block33, create_else_block26];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment86.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance86($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "active", "disabled", "tab", "tabId"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $activeTabId;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabPane", slots, ["tab", "default"]);
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { disabled = false } = $$props;
  let { tab = void 0 } = $$props;
  let { tabId = void 0 } = $$props;
  const tabs = getContext("tabs");
  const { activeTabId, setActiveTab } = getContext("tabContent");
  validate_store(activeTabId, "activeTabId");
  component_subscribe($$self, activeTabId, (value) => $$invalidate(11, $activeTabId = value));
  onMount(() => {
    if (active)
      setActiveTab(tabId);
  });
  let tabOpen = active;
  const click_handler = () => setActiveTab(tabId);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(9, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(10, active = $$new_props.active);
    if ("disabled" in $$new_props)
      $$invalidate(0, disabled = $$new_props.disabled);
    if ("tab" in $$new_props)
      $$invalidate(1, tab = $$new_props.tab);
    if ("tabId" in $$new_props)
      $$invalidate(2, tabId = $$new_props.tabId);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onMount,
    NavItem: NavItem_default,
    NavLink: NavLink_default,
    classnames,
    className,
    active,
    disabled,
    tab,
    tabId,
    tabs,
    activeTabId,
    setActiveTab,
    tabOpen,
    classes,
    $activeTabId
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(9, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(10, active = $$new_props.active);
    if ("disabled" in $$props)
      $$invalidate(0, disabled = $$new_props.disabled);
    if ("tab" in $$props)
      $$invalidate(1, tab = $$new_props.tab);
    if ("tabId" in $$props)
      $$invalidate(2, tabId = $$new_props.tabId);
    if ("tabOpen" in $$props)
      $$invalidate(3, tabOpen = $$new_props.tabOpen);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2052) {
      $:
        if ($activeTabId !== void 0)
          $$invalidate(3, tabOpen = $activeTabId === tabId);
    }
    if ($$self.$$.dirty & 520) {
      $:
        $$invalidate(4, classes = classnames("tab-pane", className, { active: tabOpen, show: tabOpen }));
    }
  };
  return [
    disabled,
    tab,
    tabId,
    tabOpen,
    classes,
    tabs,
    activeTabId,
    setActiveTab,
    $$restProps,
    className,
    active,
    $activeTabId,
    slots,
    click_handler,
    $$scope
  ];
}
var TabPane = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance86, create_fragment86, safe_not_equal, {
      class: 9,
      active: 10,
      disabled: 0,
      tab: 1,
      tabId: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabPane",
      options,
      id: create_fragment86.name
    });
  }
  get class() {
    throw new Error("<TabPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TabPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<TabPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<TabPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TabPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TabPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tab() {
    throw new Error("<TabPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tab(value) {
    throw new Error("<TabPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabId() {
    throw new Error("<TabPane>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabId(value) {
    throw new Error("<TabPane>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabPane_default = TabPane;

// node_modules/sveltestrap/src/ToastBody.svelte
var file85 = "node_modules/sveltestrap/src/ToastBody.svelte";
function create_fragment87(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  let div_levels = [ctx[1], { class: ctx[0] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_attributes(div, div_data);
      add_location(div, file85, 9, 0, 165);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 2 && ctx2[1],
        (!current || dirty & 1) && { class: ctx2[0] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment87.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance87($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToastBody", slots, ["default"]);
  let { class: className = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ classnames, className, classes });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("classes" in $$props)
      $$invalidate(0, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      $:
        $$invalidate(0, classes = classnames(className, "toast-body"));
    }
  };
  return [classes, $$restProps, className, $$scope, slots];
}
var ToastBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance87, create_fragment87, safe_not_equal, { class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToastBody",
      options,
      id: create_fragment87.name
    });
  }
  get class() {
    throw new Error("<ToastBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ToastBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToastBody_default = ToastBody;

// node_modules/sveltestrap/src/ToastHeader.svelte
var file86 = "node_modules/sveltestrap/src/ToastHeader.svelte";
var get_close_slot_changes3 = (dirty) => ({});
var get_close_slot_context3 = (ctx) => ({});
var get_icon_slot_changes = (dirty) => ({});
var get_icon_slot_context = (ctx) => ({});
function create_else_block27(ctx) {
  let current;
  const icon_slot_template = ctx[8].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[7], get_icon_slot_context);
  const block = {
    c: function create() {
      if (icon_slot)
        icon_slot.c();
    },
    m: function mount(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(icon_slot_template, ctx2[7], dirty, get_icon_slot_changes),
            get_icon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block27.name,
    type: "else",
    source: "(29:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_119(ctx) {
  let svg;
  let rect;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      attr_dev(rect, "fill", "currentColor");
      attr_dev(rect, "width", "100%");
      attr_dev(rect, "height", "100%");
      add_location(rect, file86, 26, 6, 640);
      attr_dev(svg, "class", svg_class_value = `rounded text-${ctx[0]}`);
      attr_dev(svg, "width", "20");
      attr_dev(svg, "height", "20");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "preserveAspectRatio", "xMidYMid slice");
      attr_dev(svg, "focusable", "false");
      attr_dev(svg, "role", "img");
      add_location(svg, file86, 17, 4, 426);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, rect);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 1 && svg_class_value !== (svg_class_value = `rounded text-${ctx2[0]}`)) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_119.name,
    type: "if",
    source: "(17:2) {#if icon}",
    ctx
  });
  return block;
}
function create_if_block34(ctx) {
  let current;
  const close_slot_template = ctx[8].close;
  const close_slot = create_slot(close_slot_template, ctx, ctx[7], get_close_slot_context3);
  const close_slot_or_fallback = close_slot || fallback_block10(ctx);
  const block = {
    c: function create() {
      if (close_slot_or_fallback)
        close_slot_or_fallback.c();
    },
    m: function mount(target, anchor) {
      if (close_slot_or_fallback) {
        close_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (close_slot) {
        if (close_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            close_slot,
            close_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(close_slot_template, ctx2[7], dirty, get_close_slot_changes3),
            get_close_slot_context3
          );
        }
      } else {
        if (close_slot_or_fallback && close_slot_or_fallback.p && (!current || dirty & 6)) {
          close_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(close_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(close_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (close_slot_or_fallback)
        close_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block34.name,
    type: "if",
    source: "(35:2) {#if toggle}",
    ctx
  });
  return block;
}
function fallback_block10(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      close: true,
      "aria-label": ctx[2]
    },
    $$inline: true
  });
  button.$on("click", function() {
    if (is_function(ctx[1]))
      ctx[1].apply(this, arguments);
  });
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & 4)
        button_changes["aria-label"] = ctx[2];
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block10.name,
    type: "fallback",
    source: "(36:23)        ",
    ctx
  });
  return block;
}
function create_fragment88(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t0;
  let strong;
  let t1;
  let current;
  const if_block_creators = [create_if_block_119, create_else_block27];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  let if_block1 = ctx[1] && create_if_block34(ctx);
  let div_levels = [ctx[5], { class: ctx[4] }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if_block0.c();
      t0 = space();
      strong = element("strong");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      attr_dev(strong, "class", ctx[3]);
      add_location(strong, file86, 31, 2, 752);
      set_attributes(div, div_data);
      add_location(div, file86, 15, 0, 370);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append_dev(div, t0);
      append_dev(div, strong);
      if (default_slot) {
        default_slot.m(strong, null);
      }
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t0);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 8) {
        attr_dev(strong, "class", ctx2[3]);
      }
      if (ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block34(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 32 && ctx2[5],
        (!current || dirty & 16) && { class: ctx2[4] }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_blocks[current_block_type_index].d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment88.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance88($$self, $$props, $$invalidate) {
  let classes;
  let tagClassName;
  const omit_props_names = ["class", "icon", "toggle", "closeAriaLabel"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToastHeader", slots, ["icon", "default", "close"]);
  let { class: className = "" } = $$props;
  let { icon = null } = $$props;
  let { toggle = null } = $$props;
  let { closeAriaLabel = "Close" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(6, className = $$new_props.class);
    if ("icon" in $$new_props)
      $$invalidate(0, icon = $$new_props.icon);
    if ("toggle" in $$new_props)
      $$invalidate(1, toggle = $$new_props.toggle);
    if ("closeAriaLabel" in $$new_props)
      $$invalidate(2, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    classnames,
    Button: Button_default,
    className,
    icon,
    toggle,
    closeAriaLabel,
    tagClassName,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(6, className = $$new_props.className);
    if ("icon" in $$props)
      $$invalidate(0, icon = $$new_props.icon);
    if ("toggle" in $$props)
      $$invalidate(1, toggle = $$new_props.toggle);
    if ("closeAriaLabel" in $$props)
      $$invalidate(2, closeAriaLabel = $$new_props.closeAriaLabel);
    if ("tagClassName" in $$props)
      $$invalidate(3, tagClassName = $$new_props.tagClassName);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 64) {
      $:
        $$invalidate(4, classes = classnames(className, "toast-header"));
    }
    if ($$self.$$.dirty & 1) {
      $:
        $$invalidate(3, tagClassName = classnames("me-auto", { "ms-2": icon != null }));
    }
  };
  return [
    icon,
    toggle,
    closeAriaLabel,
    tagClassName,
    classes,
    $$restProps,
    className,
    $$scope,
    slots
  ];
}
var ToastHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance88, create_fragment88, safe_not_equal, {
      class: 6,
      icon: 0,
      toggle: 1,
      closeAriaLabel: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToastHeader",
      options,
      id: create_fragment88.name
    });
  }
  get class() {
    throw new Error("<ToastHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ToastHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<ToastHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<ToastHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<ToastHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<ToastHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeAriaLabel() {
    throw new Error("<ToastHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeAriaLabel(value) {
    throw new Error("<ToastHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToastHeader_default = ToastHeader;

// node_modules/sveltestrap/src/Toast.svelte
var file87 = "node_modules/sveltestrap/src/Toast.svelte";
function create_if_block35(ctx) {
  let div;
  let t;
  let current_block_type_index;
  let if_block1;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[4] && create_if_block_213(ctx);
  const if_block_creators = [create_if_block_120, create_else_block28];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [ctx[8], { class: ctx[6] }, { role: "alert" }];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if_block1.c();
      set_attributes(div, div_data);
      add_location(div, file87, 36, 2, 863);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "introstart", ctx[13], false, false, false),
          listen_dev(div, "introend", ctx[14], false, false, false),
          listen_dev(div, "outrostart", ctx[15], false, false, false),
          listen_dev(div, "outroend", ctx[16], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (ctx[4]) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & 16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_213(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block1.c();
        } else {
          if_block1.p(ctx, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 256 && ctx[8],
        (!current || dirty & 64) && { class: ctx[6] },
        { role: "alert" }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(
            div,
            fade,
            {
              duration: ctx[3] && ctx[2]
            },
            true
          );
        div_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      if (!div_transition)
        div_transition = create_bidirectional_transition(
          div,
          fade,
          {
            duration: ctx[3] && ctx[2]
          },
          false
        );
      div_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block35.name,
    type: "if",
    source: "(36:0) {#if isOpen}",
    ctx
  });
  return block;
}
function create_if_block_213(ctx) {
  let toastheader;
  let current;
  toastheader = new ToastHeader_default({
    props: {
      toggle: ctx[5],
      $$slots: { default: [create_default_slot_17] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(toastheader.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(toastheader, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const toastheader_changes = {};
      if (dirty & 32)
        toastheader_changes.toggle = ctx2[5];
      if (dirty & 131088) {
        toastheader_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toastheader.$set(toastheader_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toastheader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toastheader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(toastheader, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_213.name,
    type: "if",
    source: "(47:4) {#if header}",
    ctx
  });
  return block;
}
function create_default_slot_17(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[4]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 16)
        set_data_dev(t, ctx2[4]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_17.name,
    type: "slot",
    source: "(48:6) <ToastHeader {toggle}>",
    ctx
  });
  return block;
}
function create_else_block28(ctx) {
  let current;
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[17], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[17],
            !current ? get_all_dirty_from_scope(ctx2[17]) : get_slot_changes(default_slot_template, ctx2[17], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block28.name,
    type: "else",
    source: "(56:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_120(ctx) {
  let toastbody;
  let current;
  toastbody = new ToastBody_default({
    props: {
      $$slots: { default: [create_default_slot13] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(toastbody.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(toastbody, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const toastbody_changes = {};
      if (dirty & 131072) {
        toastbody_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toastbody.$set(toastbody_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toastbody.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toastbody.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(toastbody, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_120.name,
    type: "if",
    source: "(52:4) {#if body}",
    ctx
  });
  return block;
}
function create_default_slot13(ctx) {
  let current;
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[17], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[17],
            !current ? get_all_dirty_from_scope(ctx2[17]) : get_slot_changes(default_slot_template, ctx2[17], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot13.name,
    type: "slot",
    source: "(53:6) <ToastBody>",
    ctx
  });
  return block;
}
function create_fragment89(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block35(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block35(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment89.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance89($$self, $$props, $$invalidate) {
  let classes;
  const omit_props_names = ["class", "autohide", "body", "delay", "duration", "fade", "header", "isOpen", "toggle"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toast", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { class: className = "" } = $$props;
  let { autohide = false } = $$props;
  let { body = false } = $$props;
  let { delay = 5e3 } = $$props;
  let { duration = 200 } = $$props;
  let { fade: fade2 = true } = $$props;
  let { header = void 0 } = $$props;
  let { isOpen = true } = $$props;
  let { toggle = null } = $$props;
  let timeout;
  onDestroy(() => {
    return () => clearTimeout(timeout);
  });
  const introstart_handler = () => dispatch("opening");
  const introend_handler = () => dispatch("open");
  const outrostart_handler = () => dispatch("closing");
  const outroend_handler = () => dispatch("close");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(9, className = $$new_props.class);
    if ("autohide" in $$new_props)
      $$invalidate(10, autohide = $$new_props.autohide);
    if ("body" in $$new_props)
      $$invalidate(1, body = $$new_props.body);
    if ("delay" in $$new_props)
      $$invalidate(11, delay = $$new_props.delay);
    if ("duration" in $$new_props)
      $$invalidate(2, duration = $$new_props.duration);
    if ("fade" in $$new_props)
      $$invalidate(3, fade2 = $$new_props.fade);
    if ("header" in $$new_props)
      $$invalidate(4, header = $$new_props.header);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("toggle" in $$new_props)
      $$invalidate(5, toggle = $$new_props.toggle);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onDestroy,
    fadeTrans: fade,
    ToastBody: ToastBody_default,
    ToastHeader: ToastHeader_default,
    classnames,
    dispatch,
    className,
    autohide,
    body,
    delay,
    duration,
    fade: fade2,
    header,
    isOpen,
    toggle,
    timeout,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(9, className = $$new_props.className);
    if ("autohide" in $$props)
      $$invalidate(10, autohide = $$new_props.autohide);
    if ("body" in $$props)
      $$invalidate(1, body = $$new_props.body);
    if ("delay" in $$props)
      $$invalidate(11, delay = $$new_props.delay);
    if ("duration" in $$props)
      $$invalidate(2, duration = $$new_props.duration);
    if ("fade" in $$props)
      $$invalidate(3, fade2 = $$new_props.fade);
    if ("header" in $$props)
      $$invalidate(4, header = $$new_props.header);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("toggle" in $$props)
      $$invalidate(5, toggle = $$new_props.toggle);
    if ("timeout" in $$props)
      timeout = $$new_props.timeout;
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3073) {
      $:
        if (isOpen && autohide) {
          timeout = setTimeout(() => $$invalidate(0, isOpen = false), delay);
        }
    }
    if ($$self.$$.dirty & 513) {
      $:
        $$invalidate(6, classes = classnames(className, "toast", { show: isOpen }));
    }
  };
  return [
    isOpen,
    body,
    duration,
    fade2,
    header,
    toggle,
    classes,
    dispatch,
    $$restProps,
    className,
    autohide,
    delay,
    slots,
    introstart_handler,
    introend_handler,
    outrostart_handler,
    outroend_handler,
    $$scope
  ];
}
var Toast = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance89, create_fragment89, safe_not_equal, {
      class: 9,
      autohide: 10,
      body: 1,
      delay: 11,
      duration: 2,
      fade: 3,
      header: 4,
      isOpen: 0,
      toggle: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toast",
      options,
      id: create_fragment89.name
    });
  }
  get class() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autohide() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autohide(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get body() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set body(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get delay() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set delay(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fade() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fade(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get header() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set header(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggle(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toast_default = Toast;

// node_modules/sveltestrap/src/Tooltip.svelte
var file88 = "node_modules/sveltestrap/src/Tooltip.svelte";
function create_if_block36(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[5];
  function switch_props(ctx2) {
    return {
      props: {
        $$slots: { default: [create_default_slot14] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty & 262366) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = ctx2[5])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block36.name,
    type: "if",
    source: "(123:0) {#if isOpen}",
    ctx
  });
  return block;
}
function create_else_block29(ctx) {
  let current;
  const default_slot_template = ctx[16].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[18], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[18],
            !current ? get_all_dirty_from_scope(ctx2[18]) : get_slot_changes(default_slot_template, ctx2[18], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block29.name,
    type: "else",
    source: "(137:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_121(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_121.name,
    type: "if",
    source: "(135:8) {#if children}",
    ctx
  });
  return block;
}
function create_default_slot14(ctx) {
  let div2;
  let div0;
  let t;
  let div1;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_121, create_else_block29];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div2_levels = [
    ctx[7],
    { class: ctx[6] },
    { id: ctx[2] },
    { role: "tooltip" },
    {
      "x-placement": ctx[3]
    }
  ];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t = space();
      div1 = element("div");
      if_block.c();
      attr_dev(div0, "class", "tooltip-arrow");
      attr_dev(div0, "data-popper-arrow", "");
      add_location(div0, file88, 132, 6, 3319);
      attr_dev(div1, "class", "tooltip-inner");
      add_location(div1, file88, 133, 6, 3373);
      set_attributes(div2, div2_data);
      add_location(div2, file88, 124, 4, 3161);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div0);
      append_dev(div2, t);
      append_dev(div2, div1);
      if_blocks[current_block_type_index].m(div1, null);
      ctx[17](div2);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div1, null);
      }
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [
        dirty & 128 && ctx2[7],
        (!current || dirty & 64) && { class: ctx2[6] },
        (!current || dirty & 4) && { id: ctx2[2] },
        { role: "tooltip" },
        (!current || dirty & 8) && {
          "x-placement": ctx2[3]
        }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if_blocks[current_block_type_index].d();
      ctx[17](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot14.name,
    type: "slot",
    source: "(124:2) <svelte:component this={outer}>",
    ctx
  });
  return block;
}
function create_fragment90(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] && create_if_block36(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block36(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment90.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance90($$self, $$props, $$invalidate) {
  let classes;
  let outer;
  const omit_props_names = ["class", "animation", "children", "container", "id", "isOpen", "placement", "target"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tooltip", slots, ["default"]);
  let { class: className = "" } = $$props;
  let { animation = true } = $$props;
  let { children = void 0 } = $$props;
  let { container = void 0 } = $$props;
  let { id = `tooltip_${uuid()}` } = $$props;
  let { isOpen = false } = $$props;
  let { placement = "top" } = $$props;
  let { target = "" } = $$props;
  let bsPlacement;
  let popperInstance;
  let popperPlacement = placement;
  let targetEl;
  let tooltipEl;
  const checkPopperPlacement = {
    name: "checkPopperPlacement",
    enabled: true,
    phase: "main",
    fn({ state }) {
      $$invalidate(3, popperPlacement = state.placement);
    }
  };
  const open = () => $$invalidate(0, isOpen = true);
  const close = () => $$invalidate(0, isOpen = false);
  onMount(registerEventListeners);
  onDestroy(unregisterEventListeners);
  function registerEventListeners() {
    if (target == null || target.length == 0) {
      $$invalidate(15, targetEl = null);
      return;
    }
    try {
      if (target instanceof HTMLElement) {
        $$invalidate(15, targetEl = target);
      }
    } catch (e) {
    }
    if (targetEl == null) {
      try {
        $$invalidate(15, targetEl = document.querySelector(`#${target}`));
      } catch (e) {
      }
    }
    if (targetEl) {
      targetEl.addEventListener("mouseover", open);
      targetEl.addEventListener("mouseleave", close);
      targetEl.addEventListener("focus", open);
      targetEl.addEventListener("blur", close);
    }
  }
  function unregisterEventListeners() {
    if (targetEl) {
      targetEl.removeEventListener("mouseover", open);
      targetEl.removeEventListener("mouseleave", close);
      targetEl.removeEventListener("focus", open);
      targetEl.removeEventListener("blur", close);
      targetEl.removeAttribute("aria-describedby");
    }
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tooltipEl = $$value;
      $$invalidate(4, tooltipEl);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("class" in $$new_props)
      $$invalidate(8, className = $$new_props.class);
    if ("animation" in $$new_props)
      $$invalidate(9, animation = $$new_props.animation);
    if ("children" in $$new_props)
      $$invalidate(1, children = $$new_props.children);
    if ("container" in $$new_props)
      $$invalidate(10, container = $$new_props.container);
    if ("id" in $$new_props)
      $$invalidate(2, id = $$new_props.id);
    if ("isOpen" in $$new_props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("placement" in $$new_props)
      $$invalidate(11, placement = $$new_props.placement);
    if ("target" in $$new_props)
      $$invalidate(12, target = $$new_props.target);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    onMount,
    createPopper: createPopper3,
    classnames,
    uuid,
    InlineContainer: InlineContainer_default,
    Portal: Portal_default,
    className,
    animation,
    children,
    container,
    id,
    isOpen,
    placement,
    target,
    bsPlacement,
    popperInstance,
    popperPlacement,
    targetEl,
    tooltipEl,
    checkPopperPlacement,
    open,
    close,
    registerEventListeners,
    unregisterEventListeners,
    outer,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("className" in $$props)
      $$invalidate(8, className = $$new_props.className);
    if ("animation" in $$props)
      $$invalidate(9, animation = $$new_props.animation);
    if ("children" in $$props)
      $$invalidate(1, children = $$new_props.children);
    if ("container" in $$props)
      $$invalidate(10, container = $$new_props.container);
    if ("id" in $$props)
      $$invalidate(2, id = $$new_props.id);
    if ("isOpen" in $$props)
      $$invalidate(0, isOpen = $$new_props.isOpen);
    if ("placement" in $$props)
      $$invalidate(11, placement = $$new_props.placement);
    if ("target" in $$props)
      $$invalidate(12, target = $$new_props.target);
    if ("bsPlacement" in $$props)
      $$invalidate(13, bsPlacement = $$new_props.bsPlacement);
    if ("popperInstance" in $$props)
      $$invalidate(14, popperInstance = $$new_props.popperInstance);
    if ("popperPlacement" in $$props)
      $$invalidate(3, popperPlacement = $$new_props.popperPlacement);
    if ("targetEl" in $$props)
      $$invalidate(15, targetEl = $$new_props.targetEl);
    if ("tooltipEl" in $$props)
      $$invalidate(4, tooltipEl = $$new_props.tooltipEl);
    if ("outer" in $$props)
      $$invalidate(5, outer = $$new_props.outer);
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 51217) {
      $: {
        if (isOpen && tooltipEl) {
          $$invalidate(14, popperInstance = createPopper3(targetEl, tooltipEl, {
            placement,
            modifiers: [checkPopperPlacement]
          }));
        } else if (popperInstance) {
          popperInstance.destroy();
          $$invalidate(14, popperInstance = void 0);
        }
      }
    }
    if ($$self.$$.dirty & 4096) {
      $:
        if (target) {
          unregisterEventListeners();
          registerEventListeners();
        }
    }
    if ($$self.$$.dirty & 32773) {
      $:
        if (targetEl) {
          if (isOpen)
            targetEl.setAttribute("aria-describedby", id);
          else
            targetEl.removeAttribute("aria-describedby");
        }
    }
    if ($$self.$$.dirty & 8) {
      $: {
        if (popperPlacement === "left")
          $$invalidate(13, bsPlacement = "start");
        else if (popperPlacement === "right")
          $$invalidate(13, bsPlacement = "end");
        else
          $$invalidate(13, bsPlacement = popperPlacement);
      }
    }
    if ($$self.$$.dirty & 8961) {
      $:
        $$invalidate(6, classes = classnames(className, "tooltip", animation ? "fade" : false, `bs-tooltip-${bsPlacement}`, isOpen ? "show" : false));
    }
    if ($$self.$$.dirty & 1024) {
      $:
        $$invalidate(5, outer = container === "inline" ? InlineContainer_default : Portal_default);
    }
  };
  return [
    isOpen,
    children,
    id,
    popperPlacement,
    tooltipEl,
    outer,
    classes,
    $$restProps,
    className,
    animation,
    container,
    placement,
    target,
    bsPlacement,
    popperInstance,
    targetEl,
    slots,
    div2_binding,
    $$scope
  ];
}
var Tooltip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance90, create_fragment90, safe_not_equal, {
      class: 8,
      animation: 9,
      children: 1,
      container: 10,
      id: 2,
      isOpen: 0,
      placement: 11,
      target: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tooltip",
      options,
      id: create_fragment90.name
    });
  }
  get class() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animation() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animation(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get children() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set children(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOpen(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placement() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placement(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tooltip_default = Tooltip;
export {
  Accordion_default as Accordion,
  AccordionHeader_default as AccordionHeader,
  AccordionItem_default as AccordionItem,
  Alert_default as Alert,
  Badge_default as Badge,
  Breadcrumb_default as Breadcrumb,
  BreadcrumbItem_default as BreadcrumbItem,
  Button_default as Button,
  ButtonDropdown_default as ButtonDropdown,
  ButtonGroup_default as ButtonGroup,
  ButtonToolbar_default as ButtonToolbar,
  Card_default as Card,
  CardBody_default as CardBody,
  CardColumns_default as CardColumns,
  CardDeck_default as CardDeck,
  CardFooter_default as CardFooter,
  CardGroup_default as CardGroup,
  CardHeader_default as CardHeader,
  CardImg_default as CardImg,
  CardImgOverlay_default as CardImgOverlay,
  CardLink_default as CardLink,
  CardSubtitle_default as CardSubtitle,
  CardText_default as CardText,
  CardTitle_default as CardTitle,
  Carousel_default as Carousel,
  CarouselCaption_default as CarouselCaption,
  CarouselControl_default as CarouselControl,
  CarouselIndicators_default as CarouselIndicators,
  CarouselItem_default as CarouselItem,
  Col_default as Col,
  Collapse_default as Collapse,
  Column_default as Column,
  Container_default as Container,
  Dropdown_default as Dropdown,
  DropdownItem_default as DropdownItem,
  DropdownMenu_default as DropdownMenu,
  DropdownToggle_default as DropdownToggle,
  Fade_default as Fade,
  Figure_default as Figure,
  Form_default as Form,
  FormCheck_default as FormCheck,
  FormFeedback_default as FormFeedback,
  FormGroup_default as FormGroup,
  FormText_default as FormText,
  Icon_default as Icon,
  Image_default as Image,
  InlineContainer_default as InlineContainer,
  Input_default as Input,
  InputGroup_default as InputGroup,
  InputGroupText_default as InputGroupText,
  Jumbotron_default as Jumbotron,
  Label_default as Label,
  ListGroup_default as ListGroup,
  ListGroupItem_default as ListGroupItem,
  Modal_default as Modal,
  ModalBackdrop_default as ModalBackdrop,
  ModalBody_default as ModalBody,
  ModalFooter_default as ModalFooter,
  ModalHeader_default as ModalHeader,
  Nav_default as Nav,
  NavItem_default as NavItem,
  NavLink_default as NavLink,
  Navbar_default as Navbar,
  NavbarBrand_default as NavbarBrand,
  NavbarToggler_default as NavbarToggler,
  Offcanvas_default as Offcanvas,
  OffcanvasBackdrop_default as OffcanvasBackdrop,
  OffcanvasBody_default as OffcanvasBody,
  OffcanvasHeader_default as OffcanvasHeader,
  Pagination_default as Pagination,
  PaginationItem_default as PaginationItem,
  PaginationLink_default as PaginationLink,
  Popover_default as Popover,
  Portal_default as Portal,
  Progress_default as Progress,
  Row_default as Row,
  Spinner_default as Spinner,
  Styles_default as Styles,
  TabContent_default as TabContent,
  TabPane_default as TabPane,
  Table_default as Table,
  Toast_default as Toast,
  ToastBody_default as ToastBody,
  ToastHeader_default as ToastHeader,
  Tooltip_default as Tooltip
};
//# sourceMappingURL=sveltestrap.js.map
